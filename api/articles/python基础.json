{"title":"python基础笔记","uid":"286489ce507cc84cb34299493322c428","slug":"python基础","date":"2020-11-24T03:30:44.000Z","updated":"2023-01-09T07:15:46.960Z","comments":true,"path":"api/articles/python基础.json","keywords":null,"cover":"https://img1.imgtp.com/2022/12/30/HxSFqoXO.png","content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>旅行者,本破站点旨在原创文章记录学习经历&amp;&amp;收集优秀资源减少学习成本，如果您又更好的想法请联系我。让我们一起传承开源精神🤓……</p></blockquote>\n<h1 id=\"数值类型\"><a href=\"#数值类型\" class=\"headerlink\" title=\"数值类型\"></a>数值类型</h1><table>\n<thead>\n<tr>\n<th>类型</th>\n<th>关键字</th>\n<th>数据</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>整型</td>\n<td>int</td>\n<td>整数，无限</td>\n</tr>\n<tr>\n<td>浮点型</td>\n<td>float</td>\n<td>小数</td>\n</tr>\n<tr>\n<td>复数</td>\n<td>complex</td>\n<td>复数由实数部分和虚数部分构成</td>\n</tr>\n</tbody></table>\n<h1 id=\"关键字\"><a href=\"#关键字\" class=\"headerlink\" title=\"关键字\"></a>关键字</h1><table>\n<thead>\n<tr>\n<th>算术</th>\n<th>引入</th>\n<th>异常</th>\n<th>控制</th>\n<th>操作与状态</th>\n<th>返回退出</th>\n<th>定义</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>and</td>\n<td>import</td>\n<td>except</td>\n<td>while</td>\n<td>del</td>\n<td>return</td>\n<td>lambda</td>\n</tr>\n<tr>\n<td>or</td>\n<td>as</td>\n<td>try</td>\n<td>if</td>\n<td>assert</td>\n<td>yield</td>\n<td>class</td>\n</tr>\n<tr>\n<td>in</td>\n<td>from</td>\n<td>finally</td>\n<td>else</td>\n<td>True</td>\n<td>continue</td>\n<td>global</td>\n</tr>\n<tr>\n<td>is</td>\n<td></td>\n<td>raise</td>\n<td>elif</td>\n<td>False</td>\n<td>pass</td>\n<td>def</td>\n</tr>\n<tr>\n<td>not</td>\n<td></td>\n<td>with</td>\n<td>for</td>\n<td>None</td>\n<td>break</td>\n<td>nonlacal</td>\n</tr>\n</tbody></table>\n<h1 id=\"基础操作与使用\"><a href=\"#基础操作与使用\" class=\"headerlink\" title=\"基础操作与使用\"></a>基础操作与使用</h1><h2 id=\"输入\"><a href=\"#输入\" class=\"headerlink\" title=\"输入\"></a>输入</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\n# 通过 input 可以直接完成一个交互式的输入\nvalue &#x3D; input(&#39;请输入一个整数: &#39;)\n\n# 输入的任何数据最终都会是一个字符串\nprint(value, type(value))\n\n# 通过强制类型转换或 eval 函数可以转换类型\nvalue &#x3D; int(input(&#39;请输入第二个数: &#39;))\nprint(value, type(value))</code></pre>\n\n<h2 id=\"输出\"><a href=\"#输出\" class=\"headerlink\" title=\"输出\"></a>输出</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\n# 使用 print 进行内容的输出，可以输出不定长度不定类型的值\nprint(1, &#39;1&#39;, 1.1, [1, ], (1, ))\n\n# 在使用 print 进行输出的时候，通过参数可以指定一些格式\nprint(1, 2, 3, 4, 5, 6, sep&#x3D;&#39;*&#39;, end&#x3D;&#39;这里是结尾&#39;)\n\n# 格式化输出，使用 % 进行格式化输出，字符串语法支持\nprint(&#39;%5.2f + %d &#x3D; %d&#39; % (1, 2, 1+2))\n\n# 格式化输出，使用字符串的内置方法 format，字符串内置方法\nprint(&#39;&#123;0:.3f&#125;, &#123;1:10d&#125;, &#123;0:.3f&#125;&#39;.format(1, 2))\n\n# 格式化输出，使用 f&#39;&#39; 字符串进行输出，语法支持\nprint(f&#39;&#123;1:.2f&#125; + &#123;2&#125; &#x3D; &#123;1+2&#125;&#39;)</code></pre>\n\n<h2 id=\"函数的定义\"><a href=\"#函数的定义\" class=\"headerlink\" title=\"函数的定义\"></a>函数的定义</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\n# 函数定义的简单例子\ndef my_max(value1&#x3D;0, value2&#x3D;0):\n    # 类似三目运算符的写法\n    return value1 if value1 &gt; value2 else value2\n\n\n# 新的写法，可以限制传入的类型\ndef my_min(value1: int, value2: int) -&gt; int:\n    return value1 if value1 &gt; value2 else value2\n\n\n# pass 类似于 C 语言中的单个分号，即什么也不做，如果一个\n# 函数没有显示的指定返回值，那么就返回 None\ndef no_return():\n    pass\n\n\nprint(no_return())\n\n\n# 参数的传递: 位置传参，按照定义顺序传参\nprint(my_min(10, 20))\n\n# 参数的传递: 关键字传参，按照形参名传参(很常见)\nprint(my_min(value2&#x3D;10, value1&#x3D;20))</code></pre>\n\n<h2 id=\"运算符的使用\"><a href=\"#运算符的使用\" class=\"headerlink\" title=\"运算符的使用\"></a>运算符的使用</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\n# 算数运算符: 幂运算 **\nprint(2 ** 1024)\n\n# 算数运算符: 除法运算 &#x2F;(真除法) &#x2F;&#x2F;(向下取整除法)\nprint(10 &#x2F; 10, 10.0 &#x2F; 3)\nprint(10 &#x2F;&#x2F; 3, -10.0 &#x2F;&#x2F; 3)\n\n# 比较运算 &#x3D;&#x3D; 和身份运算符 is\nl1 &#x3D; [1, 2, 3]\nl2 &#x3D; l1\nprint(hex(id(l1)), hex(id(l2)), l1 &#x3D;&#x3D; l2, l1 is l2)\nl2 &#x3D; l1.copy()\nprint(hex(id(l1)), hex(id(l2)), l1 &#x3D;&#x3D; l2, l1 is l2)\n\n# 成员关系运算符: 判断某元素是否在某容器中\nprint(&#39;a&#39; in &#39;abc&#39;, &#39;d&#39; in &#39;abc&#39;)</code></pre>\n\n<h2 id=\"选择结构\"><a href=\"#选择结构\" class=\"headerlink\" title=\"选择结构\"></a>选择结构</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\n# 判断用户输入的用户名和密码是否符合长度且匹配\n\n# 接收用户的输入\nusername &#x3D; input(&#39;username: &#39;)\npassword &#x3D; input(&#39;password: &#39;)\n\n# 判断用户输入的长度是否准确\nif len(username) &gt;&#x3D; 8 and len(password) &gt;&#x3D; 8:\n    # if 后面直接添加表达式，结尾必须添加冒号(:)\n    if username &#x3D;&#x3D; &#39;username&#39; and password &#x3D;&#x3D; &#39;password&#39;:\n        # if 后面的语句必须拥有一级缩进，并且所有存在一级缩进\n        # 的语句都被认为是语句块的一部分，累哦四花括号作用域\n        print(&#39;登录成功，跳转至个人中心...&#39;)\n        print(&#39;这里是第二条语句，同样是输出的&#39;)\nelse:\n    print(&#39;用户名或密码的长度不够&#39;)</code></pre>\n\n<h2 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\n# 列表的基础知识: 内置的序列类型，可以看作是加强版本的数，通过中括号\n# [] 进行定义，其中不要求元素的类型是一致的，并且长度是可变的\nprint([1, 2, 3, 4, 5], type([]))\nprint([1, 1.1, &#39;1&#39;, [1]])\n\n# 算数运算\nprint([1] + [2])        # 将参与运算的列表组合成新的列表\nprint([1, 2] * 3)       # 将列表的元素重复 3 次\nprint(3 in [0, 1, 2])   # 判断是否在列表中\nprint([1, 2, 3] &#x3D;&#x3D; [3, 2, 1])   # 比较运算符\n\n# 全局函数\nprint(len([1, 2, 3]))\nprint(min([1, 2, 3]))\nprint(max([1, 2, 3]))\nprint(list(reversed([1, 2, 3])))\nprint(list(sorted([1, 2, 3])))\n\n# 内置方法\nl &#x3D; [1, 2, 3, 4, 5]\nl.append(6)\nprint(l)        # 在结尾添加元素\nl.insert(0, 0)\nprint(l)        # 在指定位置添加\nl.remove(3)\nprint(l)        # 删除某元素(元素)\nl.pop(0)\nprint(l)        # 删除某元素(索引)，返回删除的内容\nl.extend([1,2,3,4])\nprint(l)        # 类似列表的加法运算符\n\n# 切片操作(序列操作)  l[a:b:c]\nl &#x3D; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nprint(l[:3], l[:4])         # [起始位置, 结束的索引(不包含)]\nprint(l[3:], l[4:])         # [起始的索引(包含), 结束位置]\nprint(l[::2], l[::3])       # [::间隔的个数(步长)]\nprint(l[:-1])               # [:负数] 倒数第n个的前一个\nprint(l[::-1])              # [::负数] 逆序开始计算步数\nprint(l[1:7:3])             # 从下标 1 开始，到下标 7 的前一个，每次遍历+3\n\n# 元组类型: 可以看作不变的列表，操作方式类似列表，使用 , 定义\nprint((1,), type((1,)))\n\n# 元组的打包和解包(打包)\nt &#x3D; 1, 2, 3, 4, 5\n# 元组的打包和解包(解包): 解包的过程中前面的变量数量和元组的元素数量必须保持一致\na, b, c, d, e &#x3D; t\n\n# 元组打包解包的例子\na &#x3D; 1\nb &#x3D; 2\n# 将 b 和 a 的值，也就是 2 和 1 打包成一个临时的元组，\n# 然后进行解包，将 2 和 1 分别赋值给对应位置的 a 和 b\na, b &#x3D; b, a\n\n\n# 打包可以让函数返回多个参数，解包可以接收多个参数\ndef return_more():\n    return 1, 2, 3\n\n\n# 通过解包接收到了多个返回值\nvalue1, value2, value3 &#x3D; return_more()</code></pre>\n\n<h2 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\n# 字典存储的是键值对，可以通过 &#123;&#125;的方式定义字典\nprint(&#123;&#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3&#125;, &#123;&#125;)\n\nd &#x3D; dict()\n# 通过索引添加键来访问对应的值，第一次赋值时会添加，接下来的操作就是修改\nd[&#39;小明&#39;] &#x3D; 99\nprint(d)            # 添加\nd[&#39;小明&#39;] &#x3D; 0\nprint(d)            # 修改\ndel d[&#39;小明&#39;]\nprint(d)            # 删除\n\n# 不能访问不存在的键，在使用前通常会判断是否拥有键\nif &#39;小明&#39; in d:\n    print(d[&#39;小明&#39;])\n\n# 可变类型，元素可以被修改的类型: list dict set\n# 不可变类型，元素不可以被修改的类型: int float bool str tuple\n\n# 字典的键必须时不可变类型\nd &#x3D; &#123;1: 1, &#39;1&#39;: 1, True: 1, 1.1: 1, (1,): 1&#125;\n\n# 用于获取到字典内的一些信息\nprint(d.items())\nprint(d.values())\nprint(d.keys())\n\n\n# 集合类型: 通过 &#123;值，值，值&#125; 定义非空集合，空集合使用set()定义\n#   set 要求所有的数据必须时常量，且唯一\nprint(&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 8, 7, 6, 5, 4, 3, 2, 1&#125;)\n\n# 可以通过集合来保存一些唯一的数据\nprint(list(set([1, 2, 3, 4, 5, 6, 7, 8])))\n\n# 集合可以用于执行数学运算中的集合运算   | ^ - +</code></pre>\n\n<h2 id=\"深拷贝与浅拷贝\"><a href=\"#深拷贝与浅拷贝\" class=\"headerlink\" title=\"深拷贝与浅拷贝\"></a>深拷贝与浅拷贝</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\nl1 &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# 对列表进行赋值操作，执行的实际是浅拷贝\nl2 &#x3D; l1\nprint(hex(id(l1)), hex(id(l2)))\n\n# 如果是浅拷贝，两个变量指向同一个地址，一方更改，另一方也受影响\nl2[0] &#x3D; 10\nprint(l1, l2)\n\nl1 &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# 通过 copy 方法进行深拷贝\nl2 &#x3D; l1.copy()\nprint(hex(id(l1)), hex(id(l2)))\n\n# 拥有各自独立的空间，不会影响另外一个\nl2[0] &#x3D; 10\nprint(l1, l2)\n\n\n# 动态类型: 类型在运行过程中确定，可以改变，一般不用在定义(如果有定义)时指定类型\n# 静态类型: 类型在编译时确定，运行期间不变，始终保存定义时所提供的类型\n\n# 强类型： 不同类型的变量，所能够执行的操作是不同的，例如整数相乘是乘法，字符串乘法是重复\n# 弱类型： 运算不考虑类型，可以为任何类型提供计算</code></pre>\n\n<h2 id=\"while循环\"><a href=\"#while循环\" class=\"headerlink\" title=\"while循环\"></a>while循环</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\n# 循环，使用 while 编写循环语句，和 C 相同\n\nnumber &#x3D; 1\nwhile number &lt;&#x3D; 100:\n    print(number, end&#x3D;&#39; &#39;)\n    number +&#x3D; 1\nprint(&#39;&#39;)\n\n# for 语句的使用: 可以用于遍历所有的可迭代类型，每次循环从序列中获取第(循环次数)个的元素，\n# 将元素赋值给 for 和 in 中间所提供的变量中，可以被直接的访问到\nfor letter in &#39;hello 15pb&#39;:\n    print(letter)\n\n# 使用 range 可以快速生成一个指定规则的列表，参数同切片\nprint(list(range(1, 100, 3)))\n\n# 通过 range 生成一个可迭代序列，从中取出元素，并输出\nfor value in range(101):\n    print(value)\n\n\n# while 一般用于不确定的循环，for 一般用于序列的遍历\n# break 和 continue 和 C++ 的完全一致，对于break，for 和 while 有扩展语法\n\nfor i in range(100):\n    # 对于 for else 或者 while else 语句，如果采用 break 跳出\n    # 循环就不执行 else，如果正常退出则执行\n    pass\nelse:\n    print(&#39;正常退出&#39;)</code></pre>\n\n<h2 id=\"for循环\"><a href=\"#for循环\" class=\"headerlink\" title=\"for循环\"></a>for循环</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\nl &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# 使用 for 遍历的几种方式: 值的遍历\nfor item in l:\n    print(item, end&#x3D;&#39; &#39;)\nprint(&#39;&#39;)\n\n# 使用下标的方式进行遍历\nfor index in range(len(l)):\n    print(f&#39;l[&#123;index&#125;]&#x3D;&#123;l[index]&#125;&#39;, end&#x3D;&#39; &#39;)\nprint(&#39;&#39;)\n\n# 通过枚举的方式进行索引\nfor index, item in enumerate(l):\n    print(f&#39;l[&#123;index&#125;]&#x3D;&#123;item&#125;&#39;, end&#x3D;&#39; &#39;)\nprint(&#39;&#39;)\n\nd &#x3D; &#123;&#39;小明&#39;: 100, &quot;小红&quot;: 101, &#39;小刚&#39;: 99&#125;\n\n# 字典的遍历方式: 键，默认使用字典名就是 keys\nfor key in d.keys():\n    print(f&#39;d[&#123;key&#125;]&#x3D;&#123;d[key]&#125;&#39;, end&#x3D;&#39; &#39;)\nprint(&#39;&#39;)\n\n# 字典的遍历方式: 值\nfor value in d.values():\n    print(f&#39;&#123;value&#125;&#39;, end&#x3D;&#39; &#39;)\nprint(&#39;&#39;)\n\n# 字典的遍历方式: 键值对\nfor key, value in d.items():\n    print(f&#39;d[&#123;key&#125;]&#x3D;&#123;value&#125;&#39;, end&#x3D;&#39; &#39;)\nprint(&#39;&#39;)</code></pre>\n\n<h2 id=\"生成式\"><a href=\"#生成式\" class=\"headerlink\" title=\"生成式\"></a>生成式</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\n# 列表生成式: 快速生成列表\nprint([i for i in range(1000)])                         # 生成指定序列\nprint([i for i in range(1000) if i % 2 &#x3D;&#x3D; 0])           # 生成指定序列 + 判断\nprint([i**2 for i in range(1000) if i % 2 &#x3D;&#x3D; 0])        # 生成指定序列 + 判断 + 表达式\nprint([i*j for i in range(1, 10) for j in range(1, 10)])\n\nimport os\ndir_base &#x3D; r&#39;D:\\Microsoft\\Visual Studio 2019\\Common7\\IDE\\\\&#39;\nprint([os.path.splitext(path) for path in os.listdir(dir_base) if os.path.isfile(dir_base+path)])\n\n# 元组生成式，改成圆括号\n# 字典生成式，改成键值对的花括号\n# 集合生成式，改成花括号</code></pre>\n\n<h2 id=\"global关键字\"><a href=\"#global关键字\" class=\"headerlink\" title=\"global关键字\"></a>global关键字</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\n# 全局变量: 定义在所有函数之外的变量\ng_number &#x3D; 0\n\n\n# 局部变量: 定义在任何一个函数之内的变量\ndef function1():\n    l_number &#x3D; 1\n    # 分别用于输出当前的全局变量以及所在作用域的局部变量\n    print(globals(), locals())\n\n\nfunction1()\n\n\n# 尝试在函数中访问一个全局变量\ndef function2():\n    # 在局部空间中可以直接访问全局变量\n    print(g_number)\n\n\nfunction2()\n\n\ndef function3():\n    # 一旦尝试在函数内修改全局变量，实际上会定义出一个\n    # 和全局变量同名的局部变量\n    g_number &#x3D; 10000\n    print(locals(), globals())\n\n\nfunction3()\n\n\ndef function4():\n    # 通过 global 关键字，可以声明使用的是全局范围内的 g_number\n    global g_number\n    g_number &#x3D; 100000000\n    print(locals(), globals())\n\n\nfunction4()\n\n\ndef function5():\n    # 如果想在函数内定义一个全局变量，也可以使用 global\n    global g_value2\n    g_value2 &#x3D; 0x12345\n    print(locals(), globals())\n\n\nfunction5()</code></pre>\n\n<h2 id=\"模块\"><a href=\"#模块\" class=\"headerlink\" title=\"模块\"></a>模块</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">Python\n# 任何一个以 .py 结尾的文件，都被成为模块，可以使用 import 语句导入\n# 导入的时候首先需要找到目标模块，接下来将目标模块转换成字节码，使用\n# PVM执行字节码，由于这是一个十分消耗性能的事情，所以 python 只允许\n# 我们对一个模块直接进行一次导入\nimport module\nimport module\n\n# 如果一定想要代码被执行多遍，可以使用内置模块 importlib\nimport importlib\nimportlib.reload(module)\n\n# 如何使用模块中的内容（概念类似C++中的头文件和命名空间）\nimport module                       # 类似于 #include &lt;iostream&gt;\nprint(module.module_value1)\n\nfrom module import module_value2    # 类似于在包含头文件的基础上 using std::name\nprint(module_value2)\n\nfrom module import *                # 在包含头文件的基础上 using namespace std\nprint(module_value3)\n\n# 单下划线开头的模块全局变量只能使用命名空间访问\nprint(module._module_private_value)</code></pre>\n\n<h2 id=\"类的定义\"><a href=\"#类的定义\" class=\"headerlink\" title=\"类的定义\"></a>类的定义</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\n# class 开头后面紧跟类名，类名的首字母应该大写，后面的括号中是父类\n# python3 定义的类称之为新式类，无论是否显式说明父类的 object，默\n# 认都继承自 object，并且继承下来了一些内置的方法\nclass Student(object):\n    # 类内直接定义了一些变量，被称为[类]属性，所有的类属性\n    # 归类所有，能够被任何一个实例访问到，类似于静态变量\n    count &#x3D; 0\n    books &#x3D; []\n\n    # 构造访问，任何一个类都拥有名称为 __init__ 的构造方法，\n    # 当一个实例被创建之后，会被自动的调用\n    def __init__(self, name, age):\n        # 所有使用 self 以及实例名创建的变量都成为实例属性\n        # 每一个实例都拥有自己的实例属性，可以动态添加\n        self.name &#x3D; name\n        self.age &#x3D; age\n        print(&#39;这是一个构造方法&#39;)\n\n    # 任何一个类都拥有名称为 __del__ 的析构方法\n    def __del__(self):\n        print(&#39;这是一个析构方法&#39;)\n\n\n# 如果存在构造方法，那么创建实例的时候，必须提供除\n# self 以外的其它所有参数，self 类似于 this，表示\n# 调用方法的是哪一个实例\nobjStudent1 &#x3D; Student(&quot;xiaoming&quot;, 19)</code></pre>\n\n<h2 id=\"类属性的使用\"><a href=\"#类属性的使用\" class=\"headerlink\" title=\"类属性的使用\"></a>类属性的使用</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\n# 定义一个类，类内添加了类属性\nclass Demo(object):\n    # 一个类属性\n    class_value &#x3D; 0\n\n\ndemo &#x3D; Demo()\n# 想要访问类属性，可以使用类名以及实例名(不推荐)\nprint(demo.class_value)\nprint(Demo.class_value)\n\n# 对于类属性的修改，\ndemo.class_value &#x3D; 100          # 创建了一个同名的实例属性\nprint(Demo.class_value)\nDemo.class_value &#x3D; 200          # 修改类属性只能使用类名\nprint(Demo.class_value)\n\n# 动态增减类属性的方式\n#   增加: 通过类名或类方法中的 cls 关键字可以动态添加\nDemo.class_value2 &#x3D; 1000\nprint(Demo.__dict__)        # 包含类内所有的属性组合的键值对\n#   删除: 通过关键字 del 进行删除\ndel Demo.class_value\nprint(Demo.__dict__)</code></pre>\n\n<h2 id=\"实例属性的使用\"><a href=\"#实例属性的使用\" class=\"headerlink\" title=\"实例属性的使用\"></a>实例属性的使用</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\n# 一个类，包含了实例属性的使用\nclass Demo(object):\n\n    # 如果在构造方法内添加实例属性，可以保证每一个实例都拥有\n    def __init__(self, value):\n        self.value &#x3D; value\n\n    # 一个实例方法，其中使用了 self 关键字添加实例属性\n    def add_value(self):\n        self.value1 &#x3D; 0\n\n\n# 创建一个实例(每个实例都有自己的属性)\ndemo1 &#x3D; Demo(1000)\ndemo2 &#x3D; Demo(2000)\n\n# 输出两个实例中的所有元素\nprint(demo1.__dict__)\nprint(demo2.__dict__)\n\n# 通过 self 以及实例名动态的添加属性\ndemo1.add_value()\ndemo2.value2 &#x3D; 1000\nprint(demo1.__dict__)\nprint(demo2.__dict__)\nPython\n# 定义一个空类，用于测试内部属性\nclass Demo(object):\n    pass\n\n# 如果想看到一个类提供了哪些属性，就使用 dir\nprint(dir(Demo))\n\n# 可以使用 help 查找某一个类的帮助信息\nprint(help(list))\n\n# 可以通过内置的一些属性，输出想要的内容\nprint(Demo.__dict__)内置属性的查看</code></pre>\n\n<h2 id=\"成员方法\"><a href=\"#成员方法\" class=\"headerlink\" title=\"成员方法\"></a>成员方法</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\n# 在类内测试python提供的三种成员方法\nclass Demo(object):\n\n    # 实例方法: 第一个参数表示的是调用当前方法的实例，类似 this，通常名称为\n    #   self，也可以换做其它名称(不推荐)，通过 self 可以动态操作实例属性\n    def member_function(self):\n        print(&#39;member_function&#39;)\n\n    # 类方法: 第一个参数表示当前方法所在的类，类似类名，通常名称为 cls，类\n    #   方法常用于需要访问类属性但是不访问实例属性的情况\n    @classmethod\n    def class_function(cls):\n        print(&#39;class_function&#39;)\n\n    # 静态方法: 对方法名没有任何的要求，如果方法没有访问任何的属性，就可以设为静态的\n    @staticmethod\n    def static_method():\n        print(&#39;static_method&#39;)</code></pre>\n\n<h2 id=\"属性限制\"><a href=\"#属性限制\" class=\"headerlink\" title=\"属性限制\"></a>属性限制</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\nclass Demo(object):\n    # 仅双下划线开头表示这是私有的\n    __private_value &#x3D; 1000\n\n    # __slots__ 可以限定我们能够创建什么样的属性\n    __slots__ &#x3D; (&#39;value1&#39;, &#39;value2&#39;)\n\n    # 通常双下划线开头表示私有，双下划线开头结尾表示解释器提供\n    # 单下划线开头约定俗称是私有的，但实际没有任何控制\n\n# 通过 __dict__ 属性查看当前类内的所有类属性\nprint(Demo.__dict__)\n\n# python 中的私有实际只是以一定的方式为属性修改了名称: _类名+属性名\nprint(Demo._Demo__private_value)\n\n# 创建实例并使用实例动态添加属性\ndemo &#x3D; Demo()\ndemo.value1 &#x3D; 1000\ndemo.value2 &#x3D; 1000\ndemo.value3 &#x3D; 1000\n\n\nclass Demo2(object):\n    def __init__(self, name: int, age: int):\n        self._name &#x3D; name\n        self._age &#x3D; age\n\n# 类魔术方法的重定义: __add__ __truediv__ __init__ __str__</code></pre>\n\n<h2 id=\"类的继承\"><a href=\"#类的继承\" class=\"headerlink\" title=\"类的继承\"></a>类的继承</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\n# 创建一个父类，提供了自己的属性和方法\nclass Parent(object):\n    # 父类提供的类属性\n    parent_value &#x3D; 1000\n\n    # 构造方法，父类的构造方法\n    def __init__(self, name):\n        print(f&#39;Parent.__init__(&#123;name&#125;)&#39;)\n\n\nclass Parent2(object):\n    parent_value &#x3D; 2000\n\n    def __init__(self):\n        print(f&#39;Parent2.__init__()&#39;)\n\n\n# 创建一个子类，继承自 Parent\nclass Child(Parent, Parent2):\n\n    # 如果子类没有提供构造方法，就会使用父类的构造方法\n    def __init__(self):\n        print(&#39;Child.__init__()&#39;)\n        # 不会自动调用父类的构造方法\n        Parent.__init__(self, &#39;xiaoming&#39;)\n        # 使用 super 调用父类的构造方法\n        super().__init__(&#39;xiaoming&#39;)\n\n        # 如果对 super 进行传参，那么实际调用的将是参数\n        # 一在 mro(继承) 链中的下一个类的方法\n        Parent2.__init__(self)\n        super(Parent, self).__init__()\n        super(Child, self).__init__(&#39;xiaoming&#39;)\n\n\n    # 在子类中访问父类是属性\n    def visit_value(self):\n        # 直接以类名进行访问，访问父类的属性\n        print(Parent.parent_value)\n\nchild &#x3D; Child()\nchild.visit_value()\nprint(Child.__mro__)\n\n\n#                          object(1)\n#               parent1(3)         parent2(2)\n#                child(parent1, parent2)(4)\n\n\n# python 中继承的核心就是 mro</code></pre>\n\n<h2 id=\"异常处理\"><a href=\"#异常处理\" class=\"headerlink\" title=\"异常处理\"></a>异常处理</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\ntry:\n    # 包含的是可能产生异常的语句\n    print(10 &#x2F; 1)\nexcept ZeroDivisionError:\n    # 如果产生了异常，就跳转到这个位置执行\n    print(&#39;产生了异常&#39;)\nelse:\n    # 正常情况下，所执行的代码\n    print(&#39;没有产生异常&#39;)\n\n\n# 如果接收的异常类型和实际产生的不一致，就接收不了异常\ntry:\n    print(10 &#x2F; 0)\nexcept ZeroDivisionError: #NameError:\n    print(&#39;产生了名称异常&#39;)\n\n\n# 在 python 中，产生任何一个异常都会抛出一个异常对象，\n# 通过 except type as name 的方式可以接收到异常对象\ntry:\n    l &#x3D; []\n    print(l[0])\n    # 接收到了 IndexError 异常对象并取名为 e\nexcept IndexError as e:\n    print(e)\n\n\n# 通常为了节省时间和精力会直接使用精简写法\ntry:\n    pass\n# Exception 是通用异常(语法\\网络\\文件)的基类，通过这个类型\n# 就可以接收到大多数的异常了\nexcept Exception as e:\n    pass\n\n\nimport sys\n\n\n# 通过 finally 可以保证程序无论以何种方式正常退出，其中的代码都被执行\n#   例如这些语句: return continue break sys.exit(0)\ntry:\n    if True:\n        # sys.exit(0)\n        pass\nfinally:\n    # 用于执行清理操作\n    print(&#39;finally&#39;)\n\n\n# 主动抛出异常，如果想要自定义异常，可以实现一个自己的继承自 BaseException 的异常类\n# 然后通过 raise 主动的抛出这个类型，并进行处理\npassword &#x3D; input(&#39;password: &#39;)\nif len(password) &lt; 8:\n    raise Exception(&#39;密码长度过短&#39;)</code></pre>\n\n<h2 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\n# 使用 Python 内置函数完成文件操作\n\n# 参数一是文件所在的路径，参数二是打开方式，可能需要注意 encoding\nfile &#x3D; open(&#39;content.txt&#39;, &#39;w+&#39;)\n\n# 向文件的内部写入数据\nfile.write(&#39;hello 15pb&#39;)\nfile.writelines([&#39;第一行\\n&#39;, &#39;第二行\\n&#39;, &#39;第三行\\n&#39;])\n\n# 关闭文件，将对文件的修改保存到硬盘\nfile.close()\n\n# 通过 with open() as name 的形式打开一个文件\nwith open(&#39;content.txt&#39;, &#39;r&#39;) as file:\n    # 将 open 函数的返回值保存到变量 file 中\n    # 对于文件对象，在离开 with 作用域的时候\n    # 会自动的进行关闭，只需要关注逻辑部分\n    print(file.read())          # 默认读取所有内容\n    print(file.readline())      # 一行最大字符个数\n    print(file.readlines())     # 读取的最多行数\n\n# 以只读方式打开文件的时候，如果文件不存在就会产生异常\ntry:\n    with open(&#39;content2.txt&#39;) as file:\n        pass\nexcept Exception as e:\n    print(e)\n\n# 更多的函数: file.seek + file.tell -&gt; 计算文件大小\n\n# 文件操作模块: os，os 的使用方式和 C 语言的函数完全一致</code></pre>\n\n<h1 id=\"内置函数和模块的使用\"><a href=\"#内置函数和模块的使用\" class=\"headerlink\" title=\"内置函数和模块的使用\"></a>内置函数和模块的使用</h1><h2 id=\"struct\"><a href=\"#struct\" class=\"headerlink\" title=\"struct\"></a>struct</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\n# 通过 struct 可以实现字节流到结构体的转换\nimport struct\n\n# 打包成 int + int + char[1024] 的结构体\nbytes_content &#x3D; struct.pack(&#39;ii1024s&#39;, 10, 20, b&#39;hello15pb&#39;)\nprint(bytes_content)\n\n# 将 nt + int + char[1024] 的结构体进行解包\ntype, length, content &#x3D; struct.unpack(&#39;ii1024s&#39;, bytes_content)\nprint(type, length, content.decode(&#39;utf8&#39;).strip(&#39;\\0&#39;))</code></pre>\n\n<h2 id=\"filter\"><a href=\"#filter\" class=\"headerlink\" title=\"filter\"></a>filter</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\n# filer: 将参数二指定的序列中，每一个元素都传入到参数一指定的函数中\n#   如果该函数返回为 true，就将元素保存到一个新的序列中，否则丢弃\n\n# 该函数最少需要有一个参数，用于接收序列中的每一个元素\ndef filer_function(letter):\n    # 如果是大写的，就保留，否则丢弃\n    return letter.isupper()\n\n\ndef filer_function2(value):\n    return True if value % 3 &#x3D;&#x3D; 0 else False\n\n\nprint(list(filter(filer_function, &#39;AaBbCcDdEeFfGg&#39;)))\nprint(list(filter(filer_function2, range(1000))))</code></pre>\n\n<h2 id=\"reduce\"><a href=\"#reduce\" class=\"headerlink\" title=\"reduce\"></a>reduce</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\nimport functools\n\n# reduce: 第一个参数是一个函数，该函数一定要接收两个参数，在使用\n#   reduce 时，第一次会将可迭代对象红的元素一和元素二传入到函数中，\n#   计算出一个返回值，接下来每次都将函数的返回结果和下一个元素进行\n#   计算，知道序列遍历结束\n\n\ndef add_value(left, right):\n    return left + right\n\ndef mul_value(left, right):\n    return left * right\n\n\n# 首先将 1 和 2 放入函数，返回 3，再将 3 和 3 计算返回 6，再将 6 和 4\n# 计算返回 10，最终一直加到 10，返回的是 10 到 1 相加的和\nprint(functools.reduce(add_value, range(1, 11)))\nprint(functools.reduce(mul_value, range(1, 11)))</code></pre>\n\n<h2 id=\"map\"><a href=\"#map\" class=\"headerlink\" title=\"map\"></a>map</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">Python\n# map: 可以传入多个序列，参数一要求传入一个函数，函数接收的参数\n#   个数必须和传入的序列个数相同，在使用 map 的时候，会分别将每\n#   一个序列中的每一个元素传入函数，并且将函数的返回值组合成新\n#   的序列\n\ndef function(left, right):\n    return left* right\n\nprint(list(map(function, &#39;abcdefg&#39;, [1, 2, 3, 4, 5, 6, 7])))</code></pre>\n\n<h2 id=\"lambda\"><a href=\"#lambda\" class=\"headerlink\" title=\"lambda\"></a>lambda</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\n# lambda 表达式的语法，表达式的结果是一个匿名函数\nfunc &#x3D; lambda letter, count: letter * count\n\n# 1. 参数使用逗号隔开\n# 2. 函数体使用冒号隔开\n# 3. 函数体只能有一条语句\n# 4. 函数体内的一条语句会被作为返回值\nprint(func(&#39;a&#39;, 10))\n\n\nimport functools\n\n\n# 使用匿名函数可以在某些程度上，减少代码量\nprint(list(filter(lambda letter: letter.isupper(), &quot;AaBbCcDdEeFfGg&quot;)))\nprint(functools.reduce(lambda left, right: left * right, range(1, 11)))\nprint(functools.reduce(lambda left, right: left + right, range(1, 11)))\nprint(list(map(lambda letter, count: letter * count, &quot;abcdefg&quot;, [1, 2, 3, 4, 5, 6, 7])))</code></pre>\n\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\n# 使用 threading 可以实现线程操作(伪线程)\nimport threading\nimport time\n\n\n# 不带参数的线程回调函数\ndef worker_thread():\n    for i in range(1000):\n        # current_thread 表示的始终都是当前的线程\n        print(threading.current_thread().name, i)\n        time.sleep(0.1)\n\n\n# 模拟主函数的使用\ndef main():\n    # 通过 Thread 函数创建一个线程，需要指定起始位置(函数)\n    t &#x3D; threading.Thread(target&#x3D;worker_thread, name&#x3D;&#39;worker_thread&#39;)\n    # Thread 创建的实际是线程对象，默认并没有运行，需要调用 start 函数\n    t.start()\n\n    for i in range(1000):\n        # current_thread 表示的始终都是当前的线程\n        print(threading.current_thread().name, i)\n        time.sleep(0.1)\n\n    # 通常，为了确保主线程退出之前，所有其它线程执行完毕，需要等待\n    t.join()\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()</code></pre>\n\n<h3 id=\"参数传递\"><a href=\"#参数传递\" class=\"headerlink\" title=\"参数传递\"></a>参数传递</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\nimport threading\n\n\n# 线程回调函数，带参\ndef thread1(arg1, arg2, arg3):\n    print(arg1, type(arg1))\n    print(arg2, type(arg2))\n    print(arg3, type(arg3))\n\n\n# 线程回调函数，带元组变参\ndef thread2(*args):\n    print(args, type(args))\n\n\n# 线程回调函数，带字典变参\ndef thread3(**kwargs):\n    print(kwargs, type(kwargs))\n\n\n# 线程回调函数，带元组和字典变参\ndef thread4(*args, **kwargs):\n    print(args, type(args))\n    print(kwargs, type(kwargs))\n\n\n# 创建多个线程，传递相应的参数\nthreading.Thread(target&#x3D;thread2, args&#x3D;(1, 2, 3)).start()\nthreading.Thread(target&#x3D;thread3, kwargs&#x3D;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3&#125;).start()\nthreading.Thread(target&#x3D;thread4, args&#x3D;(1, 2, 3), kwargs&#x3D;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3&#125;).start()\nthreading.Thread(target&#x3D;thread1, args&#x3D;(1, 2, 3)).start()</code></pre>\n\n<h3 id=\"线程的锁\"><a href=\"#线程的锁\" class=\"headerlink\" title=\"线程的锁\"></a>线程的锁</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\n# 使用 threading 可以实现线程操作(伪线程)\nimport threading\nimport time\n\n\n# 定义一个全局的锁\nlock &#x3D; threading.Lock()\n\n\n# 不带参数的线程回调函数\ndef worker_thread():\n    for i in range(1000):\n        lock.acquire()\n        # current_thread 表示的始终都是当前的线程\n        print(threading.current_thread().name, i)\n        time.sleep(0.1)\n        lock.release()\n\n\n# 模拟主函数的使用\ndef main():\n    # 通过 Thread 函数创建一个线程，需要指定起始位置(函数)\n    t &#x3D; threading.Thread(target&#x3D;worker_thread, name&#x3D;&#39;worker_thread&#39;)\n    # Thread 创建的实际是线程对象，默认并没有运行，需要调用 start 函数\n    t.start()\n\n    for i in range(1000):\n        lock.acquire()\n        # current_thread 表示的始终都是当前的线程\n        print(threading.current_thread().name, i)\n        time.sleep(0.1)\n        lock.release()\n\n    # 通常，为了确保主线程退出之前，所有其它线程执行完毕，需要等待\n    t.join()\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()</code></pre>\n\n<h2 id=\"map与lambda结合实现杨辉三角\"><a href=\"#map与lambda结合实现杨辉三角\" class=\"headerlink\" title=\"map与lambda结合实现杨辉三角\"></a>map与lambda结合实现杨辉三角</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\ndef generate(numRows):\n        if numRows&#x3D;&#x3D;0:\n            return []\n        l1 &#x3D; [[1]]\n        n &#x3D; 1\n        while n&lt;numRows:\n            l1.append(map(lambda x,y:x+y, [0]+l1[-1], l1[-1]+[0]))\n            n +&#x3D; 1\n        return l1</code></pre>\n\n<h2 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\n# python 中高阶函数的定义: 参数或返回值为函数的函数就是高阶函数\n\n# 闭包: 内部函数使用了外部函数的局部变量\ndef outer(left):\n    def inner(right):\n        return left * right\n    return inner\n\n\n# 将做操作数传入给函数，实际上返回的是下列函数\n&quot;&quot;&quot;\n    def inner(right):\n        return 10 * right \n&quot;&quot;&quot;\ninner &#x3D; outer(10)\n\n# 可以调用返回的函数，传入右操作数并得到结果\nprint(inner(20))\n\n\n# 装饰器: 在闭包的基础上，使用了外部传入的函数\n#   作用: 在不更改函数名称，参数个数和调用方式的前提下为某个函数添加新的功能\n\ndef w1(func):\n    def inner():\n        print(&#39;这里是新添加的内容&#39;)\n        func()\n        print(&#39;这里也是新添加的内容&#39;)\n    return inner\n\n# @w1\n# f1 是需要被装饰的函数\ndef f1():\n    print(&#39;f1&#39;)\n\nf1()\n\n\n# 装饰器实际上叫做语法糖，例如数组 arr[i][j] -&gt; *(*(arr+i)+j)\n&quot;&quot;&quot;\n    def 新的f1():\n        print(&#39;这里是新添加的内容&#39;)\n        f1() -&gt; 旧的\n        print(&#39;这里也是新添加的内容&#39;)\n&quot;&quot;&quot;\nf1 &#x3D; w1(f1)         # @w1  def f1(): ....\nf1()</code></pre>\n\n<h2 id=\"time模块\"><a href=\"#time模块\" class=\"headerlink\" title=\"time模块\"></a>time模块</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\nimport time\n\n# 获取当前的时间戳(使用浮点数记录的秒数)\nprint(time.time())\n\n# 将指定的时间戳转换为当前时区的元组\nprint(time.localtime())\nprint(time.gmtime())        # 标准时区\n\n# 将时间元组转换为时间戳\nprint(time.mktime(time.localtime()))\n\n# 睡眠一定的时间\ntime.sleep(0.500)\n\n# 将时间元组转换成时间字符串\nprint(time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,time.localtime()))</code></pre>\n\n<h2 id=\"random模块\"><a href=\"#random模块\" class=\"headerlink\" title=\"random模块\"></a>random模块</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\nimport random\n\n# randint 和 randrange\nfor i in range(100):\n    # 生成 0&lt;&#x3D;value&lt;&#x3D;10 的一个随机数值\n    print(random.randint(0, 10))\n    # 先生成一个 range 序列，从中获取一个随机值\n    print(random.randrange(0, 10))\n\n# 创建一个字符串，用于保存验证码\ntmp &#x3D; &quot;&quot;\n# 主要在于遍历的次数，循环 6 次\nfor i in range(6):\n    # 生成一个满足 range 条件的随机值\n    rad1 &#x3D; random.randrange(4)\n    # 有一半的概率进入下面的两个分支\n    if rad1 &#x3D;&#x3D; 1 or rad1 &#x3D;&#x3D; 3:\n        # 生成一个随机的整数并转换为字符串添加到末尾\n        rad2 &#x3D; random.randrange(0, 10)\n        tmp +&#x3D; str(rad2)\n    else:\n        # 生成一个随机的大小字母添加到结尾\n        rad3 &#x3D; random.randrange(65, 91)\n        tmp +&#x3D; chr(rad3)\nprint(tmp)\n\n\n# 从指定序列中随机取出一个元素\nprint(random.choice([&#39;饭&#39;, &#39;粥&#39;, &#39;面&#39;, &#39;饿&#39;]))\n\n# 打乱一个序列(洗牌)\nl &#x3D; [1, 2, 3, 4, 5, 6, 7]\nrandom.shuffle(l)\nprint(l)</code></pre>\n\n<h2 id=\"os模块\"><a href=\"#os模块\" class=\"headerlink\" title=\"os模块\"></a>os模块</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\n# os 模块提供了目录和文件能够执行的一些操作\nimport os\n\nbase &#x3D; &#39;D:\\\\&#39;\n\n# 通过循环获取到指定目录下的所有文件和文件夹\nfor name in os.listdir(base):\n    # 判断目标名称是否为文件\n    if os.path.isfile(base+name):\n        # 输出文件名称以及后缀名\n        print(os.path.splitext(name))</code></pre>\n\n<h1 id=\"网络编程\"><a href=\"#网络编程\" class=\"headerlink\" title=\"网络编程\"></a>网络编程</h1><h2 id=\"套接字\"><a href=\"#套接字\" class=\"headerlink\" title=\"套接字\"></a>套接字</h2><h3 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\nfrom socket import *\n\n\ndef main():\n    # 1. 创建套接字对象\n    server &#x3D; socket(AF_INET, SOCK_STREAM)\n\n    # 2. 绑定对象到指定的ip和端口\n    server.bind((&#39;127.0.0.1&#39;, 0x1515))\n\n    # 3. 开启套接字的监听状态\n    server.listen(SOMAXCONN)\n\n    # 4. 等待客户端的连接\n    client, address &#x3D; server.accept()\n\n    # 5. 收发数据\n    client.send(&#39;welcome&#39;.encode(&#39;utf-8&#39;))\n\n    # 6. 关闭套接字\n    client.close()\n    server.close()\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()</code></pre>\n\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\nfrom socket import *\n\n\ndef main():\n    # 1. 创建套接字对象\n    client &#x3D; socket(AF_INET, SOCK_STREAM)\n\n    # 2. 等待客户端的连接\n    client.connect((&#39;127.0.0.1&#39;, 0x1515))\n\n    # 3. 收发数据\n    print(client.recv(100).decode(&#39;utf-8&#39;))\n\n    # 6. 关闭套接字\n    client.close()\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()</code></pre>\n\n<h2 id=\"聊天室-可多开\"><a href=\"#聊天室-可多开\" class=\"headerlink\" title=\"聊天室(可多开)\"></a>聊天室(可多开)</h2><h3 id=\"服务端-1\"><a href=\"#服务端-1\" class=\"headerlink\" title=\"服务端\"></a>服务端</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\nfrom socket import *\nfrom struct import *\nfrom threading import *\nMysql &#x3D; __import__(&#39;数据库操作&#39;)#源码就在下一个节点\n\n\n# 提供一个列表保存所有的在线用户\nclients &#x3D; &#123;&#125;\n\n# 创建一个数据库对象，连接到 chatroom\nmysql &#x3D; Mysql.Mysql(&#39;chatroom&#39;)\n\n\n# 线程回调函数: 接收来自另一边的信息\ndef reciver(sock):\n    # 接收目标发送过来的用户名和密码 char[32] + char[32]\n    username, password &#x3D; unpack(&#39;32s32s&#39;, sock.recv(64))\n    username &#x3D; username.decode(&#39;utf-8&#39;).strip(&#39;\\0&#39;)\n    password &#x3D; password.decode(&#39;utf-8&#39;).strip(&#39;\\0&#39;)\n\n    # 查询目标用户名和密码是否匹配\n    count, result &#x3D; mysql.select(f&quot;SELECT * FROM user WHERE username&#x3D;&#39;&#123;username&#125;&#39; AND password&#x3D;MD5(&#39;&#123;password&#125;&#39;);&quot;)\n\n    # 如果登录成功，就添加到在线列表\n    if count &#x3D;&#x3D; 0:\n        sock.send(&#39;不ok&#39;.encode())\n        return\n\n    if username in clients:\n        sock.send(&#39;不ok&#39;.encode())\n        return\n    else:\n        sock.send(&#39;ok&#39;.encode())\n        clients[username] &#x3D; sock\n        print(sock.getpeername(), &#39;连接到了聊天室&#39;)\n\n    while True:\n        try:\n            # 接收客户端发送的数据，由于只是转发，不做解码\n            content &#x3D; sock.recv(100)\n            # 遍历在线用户，如果不是发送者就转发\n            for client in clients.values():\n                if client !&#x3D; sock:\n                    client.send(username.encode() + b&#39;: &#39; + content)\n        except Exception as e:\n            # print(&#39;error&#39;, e)\n            # 客户端或服务器连接中断，需要从列表中移除\n            print(sock.getpeername(), &#39;离开了聊天室&#39;)\n            del clients[username]\n            # 一定要记得 break 跳出当前的循环\n            break\n\n\ndef main():\n    # 1. 创建套接字对象\n    server &#x3D; socket(AF_INET, SOCK_STREAM)\n\n    # 2. 绑定对象到指定的ip和端口\n    server.bind((&#39;127.0.0.1&#39;, 0x1515))\n\n    # 3. 开启套接字的监听状态\n    server.listen(SOMAXCONN)\n\n    while True:\n        # 4. 等待客户端的连接\n        client, address &#x3D; server.accept()\n\n        # 5. 收发数据\n        Thread(target&#x3D;reciver, args&#x3D;(client,)).start()\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()</code></pre>\n\n<h3 id=\"客户端-1\"><a href=\"#客户端-1\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\nfrom socket import *\nfrom struct import *\nfrom threading import *\n\n\n# 线程回调函数: 接收来自另一边的信息\ndef reciver(sock):\n    while True:\n        try:\n            # 如果客户端或服务器断开连接，会产生异常\n            print(sock.recv(100).decode(&#39;utf-8&#39;))\n        except Exception as e:\n            print(&#39;error&#39;, e)\n            # 一定要记得 break 跳出当前的循环\n            break\n\n\ndef main():\n    # 1. 创建套接字对象\n    client &#x3D; socket(AF_INET, SOCK_STREAM)\n\n    # 2. 等待客户端的连接\n    client.connect((&#39;127.0.0.1&#39;, 0x1515))\n\n    # 填写用户名和密码尝试进行登录\n    username &#x3D; input(&#39;username: &#39;)\n    password &#x3D; input(&#39;password: &#39;)\n    content &#x3D; pack(&#39;32s32s&#39;, username.encode(), password.encode())\n    client.send(content)\n\n    # 接收登录的结果，如果失败，就退出\n    if client.recv(100).decode() &#x3D;&#x3D; &#39;不ok&#39;:\n        return\n    print(&#39;xxxxxxx&#39;)\n\n    # 3. 收发数据\n    Thread(target&#x3D;reciver, args&#x3D;(client, )).start()\n    while True:\n        content &#x3D; input(&#39;&#39;)\n        if content &#x3D;&#x3D; &#39;quit&#39;:\n            break\n        else:\n            client.send(content.encode())\n\n    # 6. 关闭套接字\n    client.close()\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()</code></pre>\n\n<h2 id=\"数据库操作\"><a href=\"#数据库操作\" class=\"headerlink\" title=\"数据库操作\"></a>数据库操作</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\n# 通过 pymysql 连接并操作 mysql 数据库\nimport pymysql\n\n\nclass Mysql(object):\n\n    def __init__(self, database_name):\n        try:\n            # 通过 connect 函数传入数据库的配置信息连接到数据库\n            self.connect &#x3D; pymysql.connect(host&#x3D;&#39;127.0.0.1&#39;, user&#x3D;&#39;root&#39;, password&#x3D;&#39;123456&#39;, port&#x3D;3306, database&#x3D;database_name)\n            # 一旦数据库连接成功，我们就需要获取到游标对象\n            self.cursor &#x3D; self.connect.cursor()#获取操作游标\n        except Exception as e:\n            print(&#39;error&#39;, e)\n\n    def insert(self, sql: str):\n        try:\n            # execute执行sql语句\n            self.cursor.execute(sql)\n            # 对于所有修改数据库的操作，都需要提交\n            self.connect.commit()\n        except Exception as e:\n            #回滚操作\n            self.connect.rollback()\n            print(&#39;error&#39;, e)\n\n    def select(self, sql: str):\n        try:\n            self.cursor.execute(sql)\n            # 从数据库中获取到查询的结果集，返回的是一个元组，\n            # 元组中的每一个元素表示一行，保存的是一行中的每一列\n            result &#x3D; self.cursor.fetchall()&#x2F;#获取所有内容\n            count &#x3D; self.cursor.rowcount&#x2F;#获取行数\n            # 将查询到的行数和内容进行打包，返回给调用方\n            return count, result\n        except Exception as e:\n            print(&#39;error&#39;, e)\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    sql &#x3D; Mysql(&#39;student&#39;)\n    sql.insert(&quot;INSERT INTO stu_class VALUE(10, &#39;ten&#39;)&quot;)\n    print(sql.select(&#39;select * from stu_class;&#39;))</code></pre>\n\n<h1 id=\"小功能实现\"><a href=\"#小功能实现\" class=\"headerlink\" title=\"小功能实现\"></a>小功能实现</h1><h2 id=\"阶乘\"><a href=\"#阶乘\" class=\"headerlink\" title=\"阶乘\"></a>阶乘</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Code\ndef Get_Num(Num):\n    j &#x3D; 0\n    for b in range(1, Num+1):\n        i &#x3D; 1\n        for c in range(1, b+1):\n                i *&#x3D;c\n                #print(i)\n        j +&#x3D; i\n    return j\n    \nprint(Get_Num(5))</code></pre>\n\n<h2 id=\"水仙花数\"><a href=\"#水仙花数\" class=\"headerlink\" title=\"水仙花数\"></a>水仙花数</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\n&#39;&#39;&#39;水仙花数&#39;&#39;&#39;\n\nNum &#x3D; 100\n\nwhile Num &lt; 1000:\n    if Num &#x3D;&#x3D; (Num&#x2F;&#x2F;100 % 10) **3 + (Num&#x2F;&#x2F;10 % 10) **3 + (Num&#x2F;&#x2F;1 % 10)**3:\n        print(Num)\n    Num +&#x3D;1</code></pre>\n\n<h2 id=\"三角图形\"><a href=\"#三角图形\" class=\"headerlink\" title=\"三角图形\"></a>三角图形</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">Code\n打印如下图形\n\n               *\n              ***\n             *****\n            *******</code></pre>\n\n<h3 id=\"方法1\"><a href=\"#方法1\" class=\"headerlink\" title=\"方法1\"></a>方法1</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\nfor i in range(4):\n    print(&quot; &quot;*(4-i),&quot;*&quot;*(2*i+1))</code></pre>\n\n<h3 id=\"方法2\"><a href=\"#方法2\" class=\"headerlink\" title=\"方法2\"></a>方法2</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\nnum &#x3D; 1\nnum2 &#x3D; 4\nnum3 &#x3D; 4\nwhile num &lt;&#x3D; 4:\n    num1 &#x3D; 1\n    while num1 &lt;&#x3D; 7:\n        if num1 &gt;&#x3D; num2 and num1 &lt;&#x3D;num3:\n            print(&#39;*&#39;, end&#x3D;&#39;&#39;)\n        else:\n            print(&#39; &#39;, end&#x3D;&#39;&#39;)\n        num1 +&#x3D; 1\n    num2 -&#x3D; 1\n    num3 +&#x3D; 1\n    print(&#39;&#39;)\n    num +&#x3D; 1</code></pre>\n\n<h2 id=\"菱形\"><a href=\"#菱形\" class=\"headerlink\" title=\"菱形\"></a>菱形</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Code\n打印如下图型\n               *\n              ***\n             *****\n            *******\n             *****\n              ***\n               *\nPython\nnum &#x3D; 1\nnum2 &#x3D; 4\nnum3 &#x3D; 4\nwhile num &lt;&#x3D; 7:\n    num1 &#x3D; 1\n    while num1 &lt;&#x3D; 7:\n        if num1 &gt;&#x3D; num2 and num1 &lt;&#x3D;num3:\n            print(&#39;*&#39;, end&#x3D;&#39;&#39;)\n        else:\n            print(&#39; &#39;, end&#x3D;&#39;&#39;)\n        num1 +&#x3D; 1\n    if num &lt; 4:\n        num2 -&#x3D; 1\n        num3 +&#x3D; 1\n    else:\n        num2 +&#x3D; 1\n        num3 -&#x3D; 1\n    print(&#39;&#39;)\n    num +&#x3D; 1</code></pre>\n\n<h2 id=\"空菱形\"><a href=\"#空菱形\" class=\"headerlink\" title=\"空菱形\"></a>空菱形</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Code\n   打印如下图型\n   *\n  * *\n *   *\n*     *\n *   *\n  * *\n   *\nPython\nnum &#x3D; 1\nnum2 &#x3D; 4\nnum3 &#x3D; 4\nwhile num &lt;&#x3D; 7:\n    num1 &#x3D; 1\n    while num1 &lt;&#x3D; 7:\n        if num1 &#x3D;&#x3D; num2 or num1 &#x3D;&#x3D;num3:\n            print(&#39;*&#39;, end&#x3D;&#39;&#39;)\n        else:\n            print(&#39; &#39;, end&#x3D;&#39;&#39;)\n        num1 +&#x3D; 1\n    if num &lt; 4:\n        num2 -&#x3D; 1\n        num3 +&#x3D; 1\n    else:\n        num2 +&#x3D; 1\n        num3 -&#x3D; 1\n    print(&#39;&#39;)\n    num +&#x3D; 1</code></pre>\n\n<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\n&#39;&#39;&#39;冒泡排序&#39;&#39;&#39;\nList &#x3D; [20, 30, 40, 3, 6, 47, 25, 77, 15]\n\nNum &#x3D; 0\ntemp &#x3D; 0\nlenth &#x3D;  len(List) - 1\nwhile Num &lt;&#x3D; lenth-1:\n    for i in range(len(List)):\n        if i &lt; lenth:\n            if List[i] &gt; List[i+1]:\n                temp &#x3D; List[i]\n                List[i] &#x3D; List[i+1]\n                List[i+1] &#x3D; temp\n    Num +&#x3D; 1\nprint(List)</code></pre>\n\n<h2 id=\"杨辉三角\"><a href=\"#杨辉三角\" class=\"headerlink\" title=\"杨辉三角\"></a>杨辉三角</h2><h3 id=\"方法1-1\"><a href=\"#方法1-1\" class=\"headerlink\" title=\"方法1\"></a>方法1</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\ndef generate(numRows):\n        if numRows&#x3D;&#x3D;0:\n            return []\n        l1 &#x3D; [[1]]\n        n &#x3D; 1\n        while n&lt;numRows:\n            l1.append(map(lambda x,y:x+y, [0]+l1[-1], l1[-1]+[0]))\n            n +&#x3D; 1\n        return l1</code></pre>\n\n<h3 id=\"方法2-1\"><a href=\"#方法2-1\" class=\"headerlink\" title=\"方法2\"></a>方法2</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\n#杨辉三角\ndef generate(numRows):\n        if numRows&#x3D;&#x3D;0:\n            return []\n        if numRows&#x3D;&#x3D;1:\n            return[[1]]\n        if numRows&#x3D;&#x3D;2:\n            return [[1],[1,1]]\n        numRows -&#x3D; 2\n        rList &#x3D; [[1],[1,1]]\n        while numRows&gt;0:\n            newList &#x3D; [1]\n            for i in range(len(rList[-1])-1):\n                newList.append(rList[-1][i]+rList[-1][i+1])\n            newList.append(1)\n            rList.append(newList)\n            numRows -&#x3D; 1\n        return rList</code></pre>\n\n<h3 id=\"方法3\"><a href=\"#方法3\" class=\"headerlink\" title=\"方法3\"></a>方法3</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\ndef Yhsj(row):\n    result &#x3D; [1]\n    n &#x3D; 0\n    while n &lt; row:\n        if n &lt; 1:\n            yield result\n        else:\n            a &#x3D; 1\n            t &#x3D; tuple(x for x in result)\n            result &#x3D; [1, 1]\n            while a &lt; n:\n                result.insert(a, t[a - 1] + t[a])\n                a +&#x3D; 1\n            yield result\n        n +&#x3D; 1</code></pre>\n\n<h3 id=\"方法4\"><a href=\"#方法4\" class=\"headerlink\" title=\"方法4\"></a>方法4</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\ndef generate(self, numRows):\n        &quot;&quot;&quot;\n        :type numRows: int\n        :rtype: List[List[int]]\n        &quot;&quot;&quot;\n        l1 &#x3D; [1]\n        l2 &#x3D; []\n        n &#x3D; 0\n        while n&lt;numRows:\n            l2.append(l1)\n            l1 &#x3D; [sum(t) for t in zip([0]+l1, l1+[0])]\n            n +&#x3D; 1\n        return l2</code></pre>\n\n<h3 id=\"方法5\"><a href=\"#方法5\" class=\"headerlink\" title=\"方法5\"></a>方法5</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\ndef generate(self, numRows):\n        &quot;&quot;&quot;\n        :type numRows: int\n        :rtype: List[List[int]]\n        &quot;&quot;&quot;\n        if numRows&#x3D;&#x3D;0:\n            return []\n        if numRows&#x3D;&#x3D;1:\n            return[[1]]\n        if numRows&#x3D;&#x3D;2:\n            return [[1],[1,1]]\n        numRows -&#x3D; 2\n        rList &#x3D; [[1],[1,1]]\n        while numRows&gt;0:\n            newList &#x3D; [1]\n            for i in range(len(rList[-1])-1):\n                newList.append(rList[-1][i]+rList[-1][i+1])\n            newList.append(1)\n            rList.append(newList)\n            numRows -&#x3D; 1\n        return rList</code></pre>\n\n<h3 id=\"方法6\"><a href=\"#方法6\" class=\"headerlink\" title=\"方法6\"></a>方法6</h3><pre class=\"line-numbers language-python\" data-language=\"python\"><code class=\"language-python\">Python\ndef Yanghui():\n    n &#x3D; [1]\n    while True:\n        yield n\n        n.append(0)\n        n &#x3D; [n[i] + n[i-1] for i in range(len(n))]\n\ndef fun(n):\n    for i in Yanghui():\n        print(i)\n        n -&#x3D; 1\n        if n &#x3D;&#x3D; 0:\n            break\n            \n            \n            \nfun(10)</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>粗略的写一下，后面补上</p></blockquote>\n","text":" 旅行者,本破站点旨在原创文章记录学习经历&amp;&amp;收集优秀资源减少学习成本，如果您又更好的想法请联系我。让我们一起传承开源精神🤓…… 数值类型 类型 关键字 数据 整型 int 整数，无限 浮点型 float 小数 复数 complex 复数由实数部分和虚数部分构成 ...","link":"","photos":[],"count_time":{"symbolsCount":"33k","symbolsTime":"30 mins."},"categories":[{"name":"Python基础","slug":"Python基础","count":1,"path":"api/categories/Python基础.json"}],"tags":[{"name":"Python基础","slug":"Python基础","count":1,"path":"api/tags/Python基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%95%B0%E5%80%BC%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">数值类型</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">关键字</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E4%B8%8E%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">基础操作与使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%85%A5\"><span class=\"toc-text\">输入</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BE%93%E5%87%BA\"><span class=\"toc-text\">输出</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">函数的定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">运算符的使用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">选择结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%97%E8%A1%A8\"><span class=\"toc-text\">列表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%97%E5%85%B8\"><span class=\"toc-text\">字典</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B7%B1%E6%8B%B7%E8%B4%9D%E4%B8%8E%E6%B5%85%E6%8B%B7%E8%B4%9D\"><span class=\"toc-text\">深拷贝与浅拷贝</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#while%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">while循环</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#for%E5%BE%AA%E7%8E%AF\"><span class=\"toc-text\">for循环</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%9F%E6%88%90%E5%BC%8F\"><span class=\"toc-text\">生成式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#global%E5%85%B3%E9%94%AE%E5%AD%97\"><span class=\"toc-text\">global关键字</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">模块</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">类的定义</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">类属性的使用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">实例属性的使用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">成员方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B1%9E%E6%80%A7%E9%99%90%E5%88%B6\"><span class=\"toc-text\">属性限制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">类的继承</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86\"><span class=\"toc-text\">异常处理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">文件操作</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E5%92%8C%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">内置函数和模块的使用</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#struct\"><span class=\"toc-text\">struct</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#filter\"><span class=\"toc-text\">filter</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#reduce\"><span class=\"toc-text\">reduce</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#map\"><span class=\"toc-text\">map</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#lambda\"><span class=\"toc-text\">lambda</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B\"><span class=\"toc-text\">线程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92\"><span class=\"toc-text\">参数传递</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%94%81\"><span class=\"toc-text\">线程的锁</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#map%E4%B8%8Elambda%E7%BB%93%E5%90%88%E5%AE%9E%E7%8E%B0%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92\"><span class=\"toc-text\">map与lambda结合实现杨辉三角</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A3%85%E9%A5%B0%E5%99%A8\"><span class=\"toc-text\">装饰器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#time%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">time模块</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#random%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">random模块</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#os%E6%A8%A1%E5%9D%97\"><span class=\"toc-text\">os模块</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B\"><span class=\"toc-text\">网络编程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A5%97%E6%8E%A5%E5%AD%97\"><span class=\"toc-text\">套接字</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%8D%E5%8A%A1%E7%AB%AF\"><span class=\"toc-text\">服务端</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%A2%E6%88%B7%E7%AB%AF\"><span class=\"toc-text\">客户端</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%81%8A%E5%A4%A9%E5%AE%A4-%E5%8F%AF%E5%A4%9A%E5%BC%80\"><span class=\"toc-text\">聊天室(可多开)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9C%8D%E5%8A%A1%E7%AB%AF-1\"><span class=\"toc-text\">服务端</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%A2%E6%88%B7%E7%AB%AF-1\"><span class=\"toc-text\">客户端</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">数据库操作</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E5%8A%9F%E8%83%BD%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">小功能实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%98%B6%E4%B9%98\"><span class=\"toc-text\">阶乘</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B0%B4%E4%BB%99%E8%8A%B1%E6%95%B0\"><span class=\"toc-text\">水仙花数</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%89%E8%A7%92%E5%9B%BE%E5%BD%A2\"><span class=\"toc-text\">三角图形</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%951\"><span class=\"toc-text\">方法1</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%952\"><span class=\"toc-text\">方法2</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%8F%B1%E5%BD%A2\"><span class=\"toc-text\">菱形</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A9%BA%E8%8F%B1%E5%BD%A2\"><span class=\"toc-text\">空菱形</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F\"><span class=\"toc-text\">冒泡排序</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9D%A8%E8%BE%89%E4%B8%89%E8%A7%92\"><span class=\"toc-text\">杨辉三角</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%951-1\"><span class=\"toc-text\">方法1</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%952-1\"><span class=\"toc-text\">方法2</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%953\"><span class=\"toc-text\">方法3</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%954\"><span class=\"toc-text\">方法4</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%955\"><span class=\"toc-text\">方法5</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%956\"><span class=\"toc-text\">方法6</span></a></li></ol></li></ol></li></ol>","author":{"name":"Akpigs","slug":"blog-author","avatar":"https://img1.imgtp.com/2022/12/28/m2fD4XcB.jpg","link":"/","description":"Sharp tools make good work, 2023新年快乐！","socials":{"github":"https://github.com/akpigs","twitter":"https://twitter.com/EmilyLe443","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://akpigs.blog.csdn.net/","juejin":"","customs":{"discord":{"icon":"/svg/discord.svg","link":"https://discord.gg/vS7yaWgW"},"bilibili":{"icon":"/svg/bilibili.svg","link":"https://www.bilibili.com"},"facebook":{"icon":"/svg/facebook.svg","link":"https://facebook.com"}}}},"mapped":true,"prev_post":{"title":"PE文件结构笔记","uid":"10c7004a7002a3a59c138ce2388db213","slug":"PE文件结构","date":"2020-11-24T06:55:09.000Z","updated":"2023-01-09T07:15:38.556Z","comments":true,"path":"api/articles/PE文件结构.json","keywords":null,"cover":"https://img1.imgtp.com/2022/12/30/tRphgbmC.jpg","text":"什么是文件存储数据的实体。 不同的文件是给不同的软件去使用的。不同的文件主要是格式不同。 格式就是数组的排列组织方式 。软件读取文件，按照固定的形式去解析文件的。 什么是PE文件（Portable Executable）可执行 文件的缩写。这种类型的文件，是供windows系统解...","link":"","photos":[],"count_time":{"symbolsCount":"43k","symbolsTime":"39 mins."},"categories":[{"name":"Windows安全","slug":"Windows安全","count":4,"path":"api/categories/Windows安全.json"}],"tags":[{"name":"PE文件结构","slug":"PE文件结构","count":1,"path":"api/tags/PE文件结构.json"}],"author":{"name":"Akpigs","slug":"blog-author","avatar":"https://img1.imgtp.com/2022/12/28/m2fD4XcB.jpg","link":"/","description":"Sharp tools make good work, 2023新年快乐！","socials":{"github":"https://github.com/akpigs","twitter":"https://twitter.com/EmilyLe443","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://akpigs.blog.csdn.net/","juejin":"","customs":{"discord":{"icon":"/svg/discord.svg","link":"https://discord.gg/vS7yaWgW"},"bilibili":{"icon":"/svg/bilibili.svg","link":"https://www.bilibili.com"},"facebook":{"icon":"/svg/facebook.svg","link":"https://facebook.com"}}}}},"next_post":{"title":"C/C++那些事","uid":"57d886b036cac1f1f4453ef4a9cee3e6","slug":"C++核心编程","date":"2020-11-21T12:53:51.000Z","updated":"2022-12-30T15:24:45.737Z","comments":true,"path":"api/articles/C++核心编程.json","keywords":null,"cover":"https://img1.imgtp.com/2022/12/30/g3lktEkb.jpg","text":"C&#x2F;C++教程本阶段主要针对C++&#x3D;&#x3D;面向对象&#x3D;&#x3D;编程技术做详细讲解，探讨C++中的核心和精髓。 内存分区模型C++程序在执行时，将内存大方向划分为4个区域 代码区：存放函数体的二进制代码，由操作系统进行管理的 全局区：存放全局变...","link":"","photos":[],"count_time":{"symbolsCount":"64k","symbolsTime":"58 mins."},"categories":[{"name":"C/C++","slug":"C-C","count":2,"path":"api/categories/C-C.json"}],"tags":[{"name":"C/C++基础","slug":"C-C-基础","count":2,"path":"api/tags/C-C-基础.json"}],"author":{"name":"Akpigs","slug":"blog-author","avatar":"https://img1.imgtp.com/2022/12/28/m2fD4XcB.jpg","link":"/","description":"Sharp tools make good work, 2023新年快乐！","socials":{"github":"https://github.com/akpigs","twitter":"https://twitter.com/EmilyLe443","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://akpigs.blog.csdn.net/","juejin":"","customs":{"discord":{"icon":"/svg/discord.svg","link":"https://discord.gg/vS7yaWgW"},"bilibili":{"icon":"/svg/bilibili.svg","link":"https://www.bilibili.com"},"facebook":{"icon":"/svg/facebook.svg","link":"https://facebook.com"}}}}}}