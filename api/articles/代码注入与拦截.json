{"title":"代码注入与拦截","uid":"c0336200d69e06897233b94f464cbc3b","slug":"代码注入与拦截","date":"2020-06-21T07:47:31.000Z","updated":"2020-08-09T04:20:21.000Z","comments":true,"path":"api/articles/代码注入与拦截.json","keywords":null,"cover":"https://img1.imgtp.com/2022/12/30/dLfWgNue.jpg","content":"<h1 id=\"权限\"><a href=\"#权限\" class=\"headerlink\" title=\"权限\"></a>权限</h1><h2 id=\"权限管理\"><a href=\"#权限管理\" class=\"headerlink\" title=\"权限管理\"></a>权限管理</h2><img src=\"https://img1.imgtp.com/2022/12/29/CG5E5gCr.png\" alt=\"1.png\" title=\"1.png\" />\n\n<h2 id=\"UAC机制\"><a href=\"#UAC机制\" class=\"headerlink\" title=\"UAC机制\"></a>UAC机制</h2><h3 id=\"管理方式\"><a href=\"#管理方式\" class=\"headerlink\" title=\"管理方式\"></a>管理方式</h3><p>在管理员账户下，运行一个程序，也是低权限，只有选择管理员方式运行，才会分配高权限。</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/rxUZxnfC.png\" alt=\"2.png\" title=\"2.png\" />\n\n<h3 id=\"调整UAC\"><a href=\"#调整UAC\" class=\"headerlink\" title=\"调整UAC\"></a>调整UAC</h3><p>方法1：gpedit</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/NrwcXjWf.png\" alt=\"3.png\" title=\"3.png\" />\n\n<p>方法2 ：设置</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/LXbF9oYC.png\" alt=\"4.png\" title=\"4.png\" />\n\n<h3 id=\"使用案例\"><a href=\"#使用案例\" class=\"headerlink\" title=\"使用案例\"></a>使用案例</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">BOOL CMy01UACDlg::OnInitDialog()\n&#123;\n\tCDialogEx::OnInitDialog();\n\n\n\t&#x2F;&#x2F; 给按钮加小盾牌\n\t&#x2F;&#x2F; 3. 判断具体的权限状况\n\n\n\t&#x2F;&#x2F; 1. 获得本进程的令牌\n\tHANDLE hToken &#x3D; NULL;\n\tif (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &amp;hToken))\n\t\treturn false;\n\t&#x2F;&#x2F; 2. 获取提升类型\n\tTOKEN_ELEVATION_TYPE ElevationType &#x3D; TokenElevationTypeDefault;\n\tBOOL                 bIsAdmin &#x3D; false;\n\tDWORD                dwSize &#x3D; 0;\n\tif (GetTokenInformation(hToken, TokenElevationType, &amp;ElevationType,\n\t\tsizeof(TOKEN_ELEVATION_TYPE), &amp;dwSize)) &#123;\n\t\t&#x2F;&#x2F; 2.1 创建管理员组的对应SID\n\t\tBYTE adminSID[SECURITY_MAX_SID_SIZE];\n\t\tdwSize &#x3D; sizeof(adminSID);\n\t\tCreateWellKnownSid(WinBuiltinAdministratorsSid, NULL, &amp;adminSID, &amp;dwSize);\n\t\t&#x2F;&#x2F; 2.2 判断当前进程运行用户角色是否为管理员\n\t\tif (ElevationType &#x3D;&#x3D; TokenElevationTypeLimited) &#123;\n\t\t\t&#x2F;&#x2F; a. 获取连接令牌的句柄\n\t\t\tHANDLE hUnfilteredToken &#x3D; NULL;\n\t\t\tGetTokenInformation(hToken, TokenLinkedToken, (PVOID)&amp;hUnfilteredToken,\n\t\t\t\tsizeof(HANDLE), &amp;dwSize);\n\t\t\t&#x2F;&#x2F; b. 检查这个原始的令牌是否包含管理员的SID\n\t\t\tif (!CheckTokenMembership(hUnfilteredToken, &amp;adminSID, &amp;bIsAdmin))\n\t\t\t\treturn false;\n\t\t\tCloseHandle(hUnfilteredToken);\n\t\t&#125;\n\t\telse &#123;\n\t\t\tbIsAdmin &#x3D; IsUserAnAdmin();\n\t\t&#125;\n\t\tCloseHandle(hToken);\n\t&#125;\n\tBOOL bFullToken &#x3D; false;\n\tswitch (ElevationType) &#123;\n\tcase TokenElevationTypeDefault: &#x2F;* 默认的用户或UAC被禁用 *&#x2F;\n\t\tif (IsUserAnAdmin())  bFullToken &#x3D; true; &#x2F;&#x2F; 默认用户有管理员权限\n\t\telse                  bFullToken &#x3D; false;&#x2F;&#x2F; 默认用户不是管理员组\n\t\tbreak;\n\tcase TokenElevationTypeFull:    &#x2F;* 已经成功提高进程权限 *&#x2F;\n\t\tif (IsUserAnAdmin())  bFullToken &#x3D; true; &#x2F;&#x2F;当前以管理员权限运行\n\t\telse                  bFullToken &#x3D; false;&#x2F;&#x2F;当前未以管理员权限运行\n\t\tbreak;\n\tcase TokenElevationTypeLimited: &#x2F;* 进程在以有限的权限运行 *&#x2F;\n\t\tif (bIsAdmin)  bFullToken &#x3D; false;&#x2F;&#x2F;用户有管理员权限，但进程权限有限\n\t\telse           bFullToken &#x3D; false;&#x2F;&#x2F;用户不是管理员组，且进程权限有限\n\t&#125;\n\t&#x2F;&#x2F; 4. 根据权限的不同控制按钮的显示\n\tif (!bFullToken)\n\t\tButton_SetElevationRequiredState(::GetDlgItem(m_hWnd, IDC_BUTTON1),!bFullToken);\n\telse\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_BUTTON1), SW_HIDE);\n\treturn TRUE;  &#x2F;&#x2F; 除非将焦点设置到控件，否则返回 TRUE\n&#125;\n\n\nvoid CMy01UACDlg::OnBnClickedButton1()\n&#123;\n\t&#x2F;&#x2F; TODO: 在此添加控件通知处理程序代码\n\t&#x2F;&#x2F;以UAC的方式，重新启动程序\n\t\t&#x2F;&#x2F; 1. 获得本进程的令牌\n\n\t&#x2F;&#x2F; 1. 隐藏当前窗口\n\tShowWindow(SW_HIDE);\n\t&#x2F;&#x2F; 2. 获取当前程序路径\n\tWCHAR szApplication[MAX_PATH] &#x3D; &#123; 0 &#125;;\n\tDWORD cchLength &#x3D; _countof(szApplication);\n\tQueryFullProcessImageName(GetCurrentProcess(), 0,\n\t\tszApplication, &amp;cchLength);\n\t&#x2F;&#x2F; 3. 以管理员权限重新打开进程\n\tSHELLEXECUTEINFO sei &#x3D; &#123; sizeof(SHELLEXECUTEINFO) &#125;;\n\tsei.lpVerb &#x3D; L&quot;runas&quot;;      &#x2F;&#x2F; 请求提升权限\n\tsei.lpFile &#x3D; szApplication; &#x2F;&#x2F; 可执行文件路径\n\tsei.lpParameters &#x3D; NULL;          &#x2F;&#x2F; 不需要参数\n\tsei.nShow &#x3D; SW_SHOWNORMAL; &#x2F;&#x2F; 正常显示窗口\n\tif (ShellExecuteEx(&amp;sei))\n\t\texit(0);\n\telse\n\t\tShowWindow( SW_SHOWNORMAL);\n&#125;\n\n\nvoid CMy01UACDlg::OnBnClickedButton2()\n&#123;\n\tEnableDebugPrivilege(TRUE);\n&#125;\n\nBOOL CMy01UACDlg::EnableDebugPrivilege(BOOL fEnable) &#123;   &#x2F;&#x2F;提升为调试权限\n\tBOOL fOk &#x3D; FALSE;    HANDLE hToken;\n\t&#x2F;&#x2F; 以修改权限的方式，打开进程的令牌\n\tif (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES,\n\t\t&amp;hToken)) &#123;\n\t\t&#x2F;&#x2F; 令牌权限结构体\n\t\tTOKEN_PRIVILEGES tp;\n\t\ttp.PrivilegeCount &#x3D; 1;\n\t\t&#x2F;&#x2F;获得LUID\n\t\tLookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;tp.Privileges[0].Luid);\n\t\ttp.Privileges[0].Attributes &#x3D; fEnable ? SE_PRIVILEGE_ENABLED : 0;\n\t\tAdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(tp), NULL, NULL); &#x2F;&#x2F;修改权限\n\t\tfOk &#x3D; (GetLastError() &#x3D;&#x3D; ERROR_SUCCESS);\n\t\tCloseHandle(hToken);\n\t&#125;\n\treturn(fOk);\n&#125;</code></pre>\n\n<h1 id=\"内存管理\"><a href=\"#内存管理\" class=\"headerlink\" title=\"内存管理\"></a>内存管理</h1><p>Windows系统使用虚拟内存的好处是什么</p>\n<p>a) 无论物理内存实际有多大，每一个进程都有4GB的虚拟地址空间。<br>b) 每一个进程在虚拟地址空间的使用上都是相似的，低2GB是用户空间，高2GB是系统空间，低2GB的用户代码空间的代码无法访问高2GB系统空间。<br>c) 在进程中使用的全部都是虚拟地址，具体虚拟地址到物理地址的转换由操作系统内核完成，故而你无法在自己的进程中访问到其他进程的内存，虽然大家的地址长得如此类似。<br>d) 一个进程的虚拟空间只有使用一部分与物理内存有映射关系，并且windows尽量保证对于不同进程的同一份数据，在物理内存中只有一份，分别映射到多个进程中。从而节约内存。<br>e) 当各个进程所使用的内存数量超出物理内存的时候，操作系统还能够将物理内存中暂时用不到的数据交换到硬盘中。</p>\n<h2 id=\"堆的管理\"><a href=\"#堆的管理\" class=\"headerlink\" title=\"堆的管理\"></a>堆的管理</h2><table>\n<thead>\n<tr>\n<th>API</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>HeapCreate</td>\n<td>在进程中创建一个堆，返回一个堆句柄</td>\n</tr>\n<tr>\n<td>GetProcessHeap</td>\n<td>获取当前进程中的一个堆，返回一个句柄</td>\n</tr>\n<tr>\n<td>GetProcessHeaps</td>\n<td>获取进程中的所用堆，堆的数量和堆的各个句柄</td>\n</tr>\n<tr>\n<td>HeapAlloc</td>\n<td>从指定的堆上分配块</td>\n</tr>\n<tr>\n<td>HeapReAlloc</td>\n<td>重新分配内存，改变已经分配好的堆内存块大小</td>\n</tr>\n<tr>\n<td>GetSystemInfo</td>\n<td>获取系统信息</td>\n</tr>\n<tr>\n<td>HeapSize</td>\n<td>获取指定堆的大小</td>\n</tr>\n<tr>\n<td>HeapFree</td>\n<td>释放HeapAlloc和HeapReAlloc申请的内存</td>\n</tr>\n<tr>\n<td>HeapDestroy</td>\n<td>销毁由HeapCreate创建的堆</td>\n</tr>\n<tr>\n<td>CreateToolhelp32Snapshot</td>\n<td>可以分别创建进程、线程、进程模块、进程堆的快照</td>\n</tr>\n<tr>\n<td>Heap32First</td>\n<td>用来首次调用，获得第一个堆对象的信息</td>\n</tr>\n<tr>\n<td>Heap32Next</td>\n<td>以后的调用由他来完成，不断的获取堆对象信息</td>\n</tr>\n</tbody></table>\n<h3 id=\"基本使用\"><a href=\"#基本使用\" class=\"headerlink\" title=\"基本使用\"></a>基本使用</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">void Test()\n&#123;\n\t&#x2F;&#x2F;我们不创建堆，进程也会有默认的堆\n\tHANDLE      hHeap &#x3D; GetProcessHeap(); &#x2F;&#x2F; 获取默认堆\n\tSYSTEM_INFO si;                       &#x2F;&#x2F;系统信息\n\tGetSystemInfo(&amp;si);                   &#x2F;&#x2F; 获取系统信息\n\t&#x2F;&#x2F;在堆上分配3个页面大小的内存\n\tLPVOID lpMem &#x3D; HeapAlloc(hHeap, HEAP_ZERO_MEMORY, si.dwPageSize * 3);\n\tHeapFree(hHeap, 0, lpMem);\n\t&#x2F;&#x2F;默认堆，不应该去销毁它\n\t&#x2F;&#x2F;HeapDestroy( hHeap );\n&#125;\n\n\n\nint main()\n&#123;\n\tTest();\n\t&#x2F;&#x2F;1 创建一个堆\n\tHANDLE      hHeap &#x3D; HeapCreate(0, 0, 0);\n\tSYSTEM_INFO si;     &#x2F;&#x2F;系统信息\n\tGetSystemInfo(&amp;si); &#x2F;&#x2F; 获取系统信息，主要是为了获取内存分页大小\n\t&#x2F;&#x2F;在堆上分配3个页面大小的内存\n\tLPVOID lpMem &#x3D; HeapAlloc(hHeap, HEAP_ZERO_MEMORY, si.dwPageSize * 3);\n\t&#x2F;&#x2F;。。。。。\n\t&#x2F;&#x2F;释放堆内存\n\tHeapFree(hHeap, 0, lpMem);\n\t&#x2F;&#x2F;销毁堆，这个堆，没有任何需要使用的内存了，就销毁\n\tHeapDestroy(hHeap);\n\n&#125;</code></pre>\n\n<p>使用场景：</p>\n<p>一般情况下，咱么都是使用malloc或者new。如果有以下场景可以尝试使用堆，假如咱们的程序需要大量的去申请小块的内存，管理这些地址，就会比较麻烦，此时就可以使用自己创建的堆，在用完了内存之后，去直接销毁堆，此时内存就自动释放了，也就免去了挨个去释放的麻烦。</p>\n<h3 id=\"遍历堆\"><a href=\"#遍历堆\" class=\"headerlink\" title=\"遍历堆\"></a>遍历堆</h3><p>和遍历进程，线程一致的，使用快照去遍历即可。</p>\n<h2 id=\"虚拟内存管理函数\"><a href=\"#虚拟内存管理函数\" class=\"headerlink\" title=\"虚拟内存管理函数\"></a>虚拟内存管理函数</h2><table>\n<thead>\n<tr>\n<th>作用</th>\n<th>函数名</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>分配</td>\n<td>VirtualAlloc</td>\n<td>分配或预定一块虚拟内存</td>\n</tr>\n<tr>\n<td></td>\n<td>VirtualAllocEx</td>\n<td>可以在其他进程分配或预定一块虚拟内存</td>\n</tr>\n<tr>\n<td>释放</td>\n<td>VirtualFree</td>\n<td>将一块虚拟内存释放</td>\n</tr>\n<tr>\n<td></td>\n<td>VirtualFreeEX</td>\n<td>可以将释放其他进程的内存</td>\n</tr>\n<tr>\n<td>锁定与解锁</td>\n<td>VirtualLook</td>\n<td>可以将内存锁定，不能交换数据到硬盘</td>\n</tr>\n<tr>\n<td></td>\n<td>VirtualUnlook</td>\n<td>为内存解锁</td>\n</tr>\n<tr>\n<td>修改保护属性</td>\n<td>VirtualProtect</td>\n<td>修改一块虚拟内存的属性</td>\n</tr>\n<tr>\n<td></td>\n<td>VirtualProtectEx</td>\n<td>可以修改其他内存的属性</td>\n</tr>\n<tr>\n<td>读写其他进程内存</td>\n<td>ReadProcessMemory</td>\n<td>读写远程进程的内存数据</td>\n</tr>\n<tr>\n<td></td>\n<td>WriteProcessMemory</td>\n<td>将数据写入远程进程内存</td>\n</tr>\n<tr>\n<td>查询内存状态</td>\n<td>VirtualQuery</td>\n<td>查询内存状态</td>\n</tr>\n<tr>\n<td></td>\n<td>VirtualQueryEx</td>\n<td>可以查询其他内存状态</td>\n</tr>\n</tbody></table>\n<h3 id=\"安全属性\"><a href=\"#安全属性\" class=\"headerlink\" title=\"安全属性\"></a>安全属性</h3><table>\n<thead>\n<tr>\n<th>属性</th>\n<th>值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PAGE_NOACCESS</td>\n<td>0x01</td>\n<td>不可访问</td>\n</tr>\n<tr>\n<td>PAGE_READONLY</td>\n<td>0x02</td>\n<td>只读</td>\n</tr>\n<tr>\n<td>PAGE_READWRITE</td>\n<td>0x04</td>\n<td>可读可写</td>\n</tr>\n<tr>\n<td>PAGE_WRITECOPY</td>\n<td>0x08</td>\n<td>可写可读</td>\n</tr>\n<tr>\n<td>PAGE_EXECUTE</td>\n<td>0x10</td>\n<td>可执行</td>\n</tr>\n<tr>\n<td>PAGE_EXECUTE_READ</td>\n<td>0x20</td>\n<td>可读可执行</td>\n</tr>\n<tr>\n<td>PAGE_EXECUTE_READWRITE</td>\n<td>0x40</td>\n<td>可读可写可执行</td>\n</tr>\n<tr>\n<td>PAGE_EXECUTE_WRITECOPY</td>\n<td>0x80</td>\n<td>可执行，写时复制</td>\n</tr>\n<tr>\n<td>PAGE_GUARD</td>\n<td>0x100</td>\n<td></td>\n</tr>\n<tr>\n<td>PAGE_NOCACHE</td>\n<td>0x200</td>\n<td></td>\n</tr>\n<tr>\n<td>PAGE_WRITECOMBINE</td>\n<td>0x400</td>\n<td></td>\n</tr>\n<tr>\n<td>PAGE_GRAPHICS_NOACCESS</td>\n<td>0x0800</td>\n<td></td>\n</tr>\n<tr>\n<td>PAGE_GRAPHICS_READONLY</td>\n<td>0x1000</td>\n<td></td>\n</tr>\n<tr>\n<td>PAGE_GRAPHICS_READWRITE</td>\n<td>0x2000</td>\n<td></td>\n</tr>\n<tr>\n<td>PAGE_GRAPHICS_EXECUTE</td>\n<td>0x4000</td>\n<td></td>\n</tr>\n<tr>\n<td>PAGE_GRAPHICS_EXECUTE_READ</td>\n<td>0x8000</td>\n<td></td>\n</tr>\n<tr>\n<td>PAGE_GRAPHICS_EXECUTE_READWRITE</td>\n<td>0x10000</td>\n<td></td>\n</tr>\n<tr>\n<td>PAGE_GRAPHICS_COHERENT</td>\n<td>0x20000</td>\n<td></td>\n</tr>\n<tr>\n<td>PAGE_ENCLAVE_THREAD_CONTROL</td>\n<td>0x80000000</td>\n<td></td>\n</tr>\n<tr>\n<td>PAGE_REVERT_TO_FILE_MAP</td>\n<td>0x80000000</td>\n<td></td>\n</tr>\n<tr>\n<td>PAGE_TARGETS_NO_UPDATE</td>\n<td>0x40000000</td>\n<td></td>\n</tr>\n<tr>\n<td>PAGE_TARGETS_INVALID</td>\n<td>0x40000000</td>\n<td></td>\n</tr>\n<tr>\n<td>PAGE_ENCLAVE_UNVALIDATED</td>\n<td>0x20000000</td>\n<td></td>\n</tr>\n<tr>\n<td>PAGE_ENCLAVE_DECOMMIT</td>\n<td>0x10000000</td>\n<td></td>\n</tr>\n</tbody></table>\n<h3 id=\"申请和释放\"><a href=\"#申请和释放\" class=\"headerlink\" title=\"申请和释放\"></a>申请和释放</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int main()\n&#123;\n\t&#x2F;&#x2F;1 申请\n\tLPVOID lpvResult &#x3D; VirtualAlloc(\n\t\tNULL,\n\t\t4097,              &#x2F;&#x2F; 4KB * 1\n\t\tMEM_RESERVE | MEM_COMMIT,   &#x2F;&#x2F; 预定并调拨内存\n\t\tPAGE_READWRITE);            &#x2F;&#x2F; 可读写\n\t&#x2F;&#x2F;使用\n\twcscpy_s((LPWSTR)lpvResult, wcslen(L&quot;Hello!&quot;)+2, L&quot;World!&quot;);\n\tMessageBox(NULL, (LPWSTR)lpvResult, NULL, MB_OK);\n\t&#x2F;&#x2F;释放\n\tVirtualFree(lpvResult, 1, MEM_RELEASE);\n&#125;</code></pre>\n\n<h3 id=\"修改保护属性\"><a href=\"#修改保护属性\" class=\"headerlink\" title=\"修改保护属性\"></a>修改保护属性</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">int main()\n&#123;\n\tchar* p &#x3D; (char*)&quot;hello World&quot;;\n\tDWORD dwNewProtect &#x3D; PAGE_READWRITE;\n\tDWORD dwOldProtect &#x3D; 0;\n\tVirtualProtect(p, 1, dwNewProtect, &amp;dwOldProtect);\n\tp[0] &#x3D; &#39;m&#39;;\n\tp[1] &#x3D; &#39;k&#39;;\n\tp[2] &#x3D; &#39;m&#39;;\n&#125;</code></pre>\n\n<h2 id=\"文件映射\"><a href=\"#文件映射\" class=\"headerlink\" title=\"文件映射\"></a>文件映射</h2><p>可以将文件直接映射进内存的一种技术。</p>\n<table>\n<thead>\n<tr>\n<th>API</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>GetSystemInfo</td>\n<td>获取系统信信息，用于确定分配粒度</td>\n</tr>\n<tr>\n<td>CreateFileMapping</td>\n<td>创建一个mapping对象</td>\n</tr>\n<tr>\n<td>OpenFileMapping</td>\n<td>打开已命名的mapping对象（可跨进程）</td>\n</tr>\n<tr>\n<td>UnmapViewOfFile</td>\n<td>取消文件映射</td>\n</tr>\n<tr>\n<td>MapViewOfFile</td>\n<td>将mapping对象的文件映射到内存</td>\n</tr>\n<tr>\n<td>FlushViewOfFile</td>\n<td>将映射到内存的文件写回到硬盘</td>\n</tr>\n</tbody></table>\n<p>有两个作用：</p>\n<p>1 操作文件比较方便</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">int main()\n&#123;\n\t&#x2F;&#x2F;1. 打开文件，得到一个文件句柄\n\tHANDLE hFile &#x3D;  CreateFile(\n\t\tL&quot;D:\\\\test\\\\123.txt&quot;,\n\t\tGENERIC_READ | GENERIC_WRITE,\n\t\tNULL,\n\t\tNULL,\n\t\tOPEN_EXISTING,\n\t\tFILE_ATTRIBUTE_NORMAL,\n\t\t0\n\t);\n\t&#x2F;&#x2F;2. 创建一个文件映射对象，和文件句柄关联如果，要超过文件大小的话\n\t&#x2F;&#x2F;   创建的时候，就需要写一个大小。\n\t&#x2F;&#x2F;   \n\tHANDLE hFileMapping  &#x3D; \n\t\tCreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 100, 0);\n\t&#x2F;&#x2F;3. 将文件映射到内存\n\tchar *p &#x3D; (char*)MapViewOfFile(hFileMapping, FILE_MAP_ALL_ACCESS, 0,0, 0);\n\n\t&#x2F;&#x2F;4. 读取或者写入\n\tstrcpy_s(p, 100,&quot;15pb hello  15pb hello&quot;);\n\n\t&#x2F;&#x2F;5. 文件映射的写入，会自动刷，也可以手动刷 \n\tFlushViewOfFile(p, 0);\n\t&#x2F;&#x2F;6. 关闭句柄\n\tCloseHandle(hFileMapping);\n\tCloseHandle(hFile);\n\n&#125;</code></pre>\n\n<p>2 文件映射是一个内核对象，可以在多进程中去访问，所以文件映射也是一种进程间通讯机制。</p>\n<h3 id=\"进程间通讯\"><a href=\"#进程间通讯\" class=\"headerlink\" title=\"进程间通讯\"></a>进程间通讯</h3><h4 id=\"通讯A端\"><a href=\"#通讯A端\" class=\"headerlink\" title=\"通讯A端\"></a>通讯A端</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; 06_进程间通讯.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。\n&#x2F;&#x2F;\n\n#include &lt;iostream&gt;\n#include &lt;Windows.h&gt;\nint main()\n&#123;\n\t&#x2F;&#x2F;1 创建文件映射\n\tHANDLE hFileMapping &#x3D;\n\t\tCreateFileMapping(\n\t\t\tINVALID_HANDLE_VALUE, \n\t\t\tNULL, PAGE_READWRITE, \n\t\t\t0, \n\t\t\t100,\n\t\t\tL&quot;hello 15pb&quot;&#x2F;&#x2F;起了名字，别的进程才能打开它\n\t\t);\n\t&#x2F;&#x2F;2 映射内存\n\tchar* pBuf &#x3D; (char*)MapViewOfFile(hFileMapping, FILE_MAP_ALL_ACCESS, 0, 0, 16);\n\n\tpBuf[0] &#x3D; 1;\n\n\t&#x2F;&#x2F;3 时刻检测，第一个字节是否被修改了\n\twhile (pBuf[0] &#x3D;&#x3D; 1)\n\t&#123;\n\n\t&#125;\n\t&#x2F;&#x2F;4 如果被修改了，那么就结束\n\tprintf(&quot;数据已经被更改&quot;);\n\tCloseHandle(hFileMapping);\n&#125;</code></pre>\n\n<h4 id=\"通讯B端\"><a href=\"#通讯B端\" class=\"headerlink\" title=\"通讯B端\"></a>通讯B端</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;Windows.h&gt;\nint main()\n&#123;\n\t&#x2F;&#x2F; 1. 打开文件Mapping\n\tHANDLE hMapFile &#x3D; OpenFileMapping(FILE_MAP_ALL_ACCESS,\n\t\tFALSE, L&quot;hello 15pb&quot;);\n\t&#x2F;&#x2F;2. 映射到内存\n\tchar* pBuf &#x3D; (char*)MapViewOfFile(hMapFile, FILE_MAP_ALL_ACCESS,\n\t\t0, 0, 0);\n\t&#x2F;&#x2F;3. 修改数据\n\tpBuf[0] &#x3D; 0;\n\t&#x2F;&#x2F;4. 通讯完毕，退出\n\tprintf(&quot;数据已经更改完毕了&quot;);\n\tCloseHandle(hMapFile);\n&#125;</code></pre>\n\n<h2 id=\"虚拟内存的遍历\"><a href=\"#虚拟内存的遍历\" class=\"headerlink\" title=\"虚拟内存的遍历\"></a>虚拟内存的遍历</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">SIZE_T WINAPI VirtualQueryEx(\n  _In_      HANDLE hProcess,   &#x2F;&#x2F; 进程句柄\n  _In_opt_  LPCVOID lpAddress, &#x2F;&#x2F; 查询地址\n  _Out_     PMEMORY_BASIC_INFORMATION lpBuffer,\n  _In_      SIZE_T dwLength    &#x2F;&#x2F; 传出结构体的大小\n);</code></pre>\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef struct _MEMORY_BASIC_INFORMATION &#123;\n    PVOID  BaseAddress;       &#x2F;&#x2F; 将参数向下取整到页面大小\n    PVOID  AllocationBase;    &#x2F;&#x2F; 区域地址，此区域包含传入地址\n    DWORD  AllocationProtect; &#x2F;&#x2F; 此区域在预定时的保护属性\n    SIZE_T RegionSize;        &#x2F;&#x2F; 区域的大小\n    DWORD  State;             &#x2F;&#x2F; 区域的页面状态[注1]\n    DWORD  Protect;           &#x2F;&#x2F; 页面保护属性\n    DWORD  Type;              &#x2F;&#x2F; 页面类型[注2]\n&#125; MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;</code></pre>\n\n<h3 id=\"页面的状态\"><a href=\"#页面的状态\" class=\"headerlink\" title=\"页面的状态\"></a>页面的状态</h3><table>\n<thead>\n<tr>\n<th><strong>状态</strong></th>\n<th>值</th>\n<th><strong>说明</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>空闲的(Free)</td>\n<td>0x00010000</td>\n<td>进程不能访问这种页面，此页面还没有被分配。</td>\n</tr>\n<tr>\n<td>保留的(reserve)</td>\n<td>0x00002000</td>\n<td>这个页面被预定了。但是还未与物理内存映射，因此这里也是不能访问的。</td>\n</tr>\n<tr>\n<td>提交的(commit)</td>\n<td>0x00001000</td>\n<td>内存已经被分配了，并且也与物理存储器映射了，进程已经可以访问这里</td>\n</tr>\n</tbody></table>\n<h3 id=\"页面类型\"><a href=\"#页面类型\" class=\"headerlink\" title=\"页面类型\"></a>页面类型</h3><table>\n<thead>\n<tr>\n<th><strong>映射方式</strong></th>\n<th><strong>描述</strong></th>\n</tr>\n</thead>\n<tbody><tr>\n<td>private</td>\n<td>进程私有内存,不被其他进程所<strong>共享</strong>, 一般是堆,栈</td>\n</tr>\n<tr>\n<td>mapped</td>\n<td>从别的进程内存映射而来</td>\n</tr>\n<tr>\n<td>image</td>\n<td>从程序的PE映像映射而来,一般是映像的区段.</td>\n</tr>\n</tbody></table>\n<h3 id=\"遍历代码\"><a href=\"#遍历代码\" class=\"headerlink\" title=\"遍历代码\"></a>遍历代码</h3><pre class=\"line-numbers language-none\"><code class=\"language-none\">#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;TlHelp32.h&gt;\n#include &lt;string&gt;\nusing std::wstring;\nvoid EnumProcess();\nvoid EnumVirtualMemroy(HANDLE Process);\nMEMORY_BASIC_INFORMATION VirtualMemroy;\nint main()\n&#123;\n\tEnumProcess();\n\t\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;遍历进程\nvoid EnumProcess()\n&#123;\n\twstring buffer;\n\n\t&#x2F;&#x2F; 2. 创建一个快照用于遍历进程，参数2可以留空\n\tHANDLE Snapshot &#x3D; CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);\n\n\t&#x2F;&#x2F; 3. 创建一个用于保存进程信息的结构体\n\tPROCESSENTRY32 ProcessInfo &#x3D; &#123; sizeof(PROCESSENTRY32) &#125;;\n\n\t&#x2F;&#x2F; 4. 尝试遍历第一个进程的信息，成功就继续，失败就跳过\n\tif (Process32First(Snapshot, &amp;ProcessInfo))\n\t&#123;\n\t\tdo &#123;\n\t\t\t\t&#x2F;&#x2F; 5.5.2 通过指定的权限获取进程句柄\n\t\t\t\tHANDLE Process &#x3D; OpenProcess(PROCESS_QUERY_INFORMATION,FALSE, ProcessInfo.th32ProcessID);\n\t\t\t\tif (Process&amp;&amp; Process !&#x3D; INVALID_HANDLE_VALUE)\n\t\t\t\t&#123;\n\t\t\t\t\t&#x2F;&#x2F; 5.5.3 通过API查询到进程对应的Exe的路径，获取不到是因为权限不够\n\t\t\t\t\t&#x2F;&#x2F;QueryFullProcessImageName(Process, 0, ImagePath, &amp;PathSize);\n\t\t\t\t\tprintf(&quot;%ls\\n&quot;, ProcessInfo.szExeFile);\n\t\t\t\t\tEnumVirtualMemroy(Process);\n\t\t\t\t\t&#x2F;&#x2F; 5.5.4 关闭句柄并打印数据\n\t\t\t\t\tCloseHandle(Process);\n\t\t\t\t&#125;\n\n\t\t\t&#x2F;&#x2F; 6. 尝试遍历进程快照内的下一个进程\n\t\t&#125; while (Process32Next(Snapshot, &amp;ProcessInfo));\n\t&#125;\n\n&#125;\n&#x2F;&#x2F;虚拟内存的遍历\nvoid EnumVirtualMemroy(HANDLE Process)\n&#123;\n\tint dwLength &#x3D; sizeof(MEMORY_BASIC_INFORMATION);\n\tLPVOID Base &#x3D; NULL;\n\twhile (Base&lt;(LPVOID)0x7fffffff)\n\t&#123;\n\t\tVirtualQueryEx(Process, Base, &amp;VirtualMemroy, dwLength);\n\n\t\tBase &#x3D; (LPVOID)((DWORD)Base + VirtualMemroy.RegionSize);\n\n\t\tprintf(&quot;\\t类型：%d\\t属性：%d\\t状态：%d\\t大小：%d\\n&quot;,\n\t\t\tVirtualMemroy.Type,\n\t\t\tVirtualMemroy.AllocationProtect,\n\t\t\tVirtualMemroy.State,\n\t\t\tVirtualMemroy.RegionSize\n\t\t);\n\t&#125;\n&#125;</code></pre>\n\n<h1 id=\"Dll注入\"><a href=\"#Dll注入\" class=\"headerlink\" title=\"Dll注入\"></a>Dll注入</h1><p>注：职业黑客的必修课</p>\n<p>重点内容）</p>\n<p>1 什么是DLL注入？？为什么要DLL注入？？</p>\n<p>在一个本来不需要加载此DLL的进程中，强行的使其加载此DLL文件。那么这个就叫做DLL注入技术。</p>\n<p>我们在向一个进程中注入我们自己的DLL，相当于在对方的进程中加入了我们自己的代码，可以修改对方程序的功能。</p>\n<p>游戏辅助，输入法，对于软件行为的拦截。</p>\n<p>2 DLL注入的方式有哪些？？</p>\n<p>远程线程注入</p>\n<p>消息钩子注入</p>\n<p>注册表注入</p>\n<p>APC注入</p>\n<p>输入法注入</p>\n<h2 id=\"远程线程注入\"><a href=\"#远程线程注入\" class=\"headerlink\" title=\"远程线程注入\"></a>远程线程注入</h2><pre class=\"line-numbers language-none\"><code class=\"language-none\">#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n\n#define DLLPATH  L&quot;DLL地址&quot;\nint main()\n&#123;\n\t&#x2F;&#x2F;通过ID获得目标句柄\n\tHANDLE hHandle &#x3D; OpenProcess(PROCESS_ALL_ACCESS,FALSE,9740);\n\t&#x2F;&#x2F;先获取字符串长度\n\tint  nLength &#x3D; wcslen(DLLPATH);\n\t&#x2F;&#x2F;在目标进程中申请一块空间\n\tLPVOID address &#x3D; VirtualAllocEx(hHandle,0, nLength*2+2,MEM_COMMIT,PAGE_READWRITE);\n\t&#x2F;&#x2F;将DLL名字写入到目标进程之前还需要一个参数是返回的实际写入大小\n\tDWORD dwConst &#x3D; 0;\n\t&#x2F;&#x2F;将DLL名字写入到目标进程空间\n\tWriteProcessMemory(hHandle, address,DLLPATH, nLength * 2 + 2, &amp;dwConst);\n\t&#x2F;&#x2F;创建远程线程\n\tHANDLE hRhread &#x3D; CreateRemoteThread(hHandle,0,0,(LPTHREAD_START_ROUTINE)LoadLibrary, address,0,0);\n\t&#x2F;&#x2F;等待线程执行完成\n\tWaitForSingleObject(hRhread,-1);\n\t&#x2F;&#x2F;销毁在目标进程申请的空间\n\tVirtualFreeEx(hHandle, address, nLength * 2 + 2,MEM_COMMIT);\n\t&#x2F;&#x2F;线程计数-1\n\tCloseHandle(hRhread);\n\treturn 0;\n&#125;</code></pre>\n\n<p>4 关于64位的注入</p>\n<p>32位的dll正常情况只能注入到32位程序中，注入程序也应该是32位，64位的dll正常情况只能注入到64位的程序中，注入程序也应该是64位。</p>\n<h2 id=\"消息钩子注入\"><a href=\"#消息钩子注入\" class=\"headerlink\" title=\"消息钩子注入\"></a>消息钩子注入</h2><p>什么是Hook，这个概念应该从何说起？？？</p>\n<p>Hook：是钩子的意思</p>\n<p>Hook技术主要指的是<strong>拦截</strong>程序原有的信息，数据，代码，</p>\n<p>1 使得你有机会对拦截到的信息数据做处理。然后再交给原来的程序去使用，从而能够截获到程序的关键信息。可以查看，也可以修改。</p>\n<p>2 能够修改程序的部分功能。</p>\n<p>2 Hook是怎么分类的？？</p>\n<p>在windows系统下，有两类Hook：</p>\n<p>2.1 windows消息Hook。windows提供的能够让程序员截获到所有窗口程序消息的机制。</p>\n<p> 消息Hook也是我们的一种Dll注入手段。</p>\n<p>2.2 自定义Hook 非常普遍的Hook方式，也是我们通常意义所说的Hook。</p>\n<p> 2.2.1 修改程序的代码，使得其能够执行到Hook者提供的“善意代码”中。 inline-Hook</p>\n<p> 2.2.2 修改存储函数地址的变量，当程序从变量中获取函数地址并调用的时候，就会调用到Hook者提供的“善意代码”了。</p>\n<p> IAT-Hook</p>\n<p> IDT-Hook</p>\n<p> SYSENTR-Hook</p>\n<p>3 windows消息钩子的实现的原理以及代码</p>\n<p>3.1 windows消息钩子的实现的原理</p>\n<p>SetWindowsHookEx这个函数，能够实现的功能是截获 1 系统中所有的窗口程序的消息或者 2 某一个线程的窗口消息。</p>\n<p>截获到了消息，必然是需要执行自己的代码，自己的代码需要放置在一个dll中，然后消息钩子设置成功之后，会将dll注入到目标进程，从而使得自己的回调函数能够在对方的进程中执行。</p>\n<p>额外的知识点：窗口程序的消息是被某一个线程获取到的，哪一个线程创建了窗口，哪一个线程就能够获得此窗口的消息。此线程在创建完窗口之后，就变成了GUI线程。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">HHOOK SetWindowsHookExA(\n int       idHook,   &#x2F;&#x2F; 要截获的是哪种类型的消息\n  HOOKPROC  lpfn,     &#x2F;&#x2F;截获到消息之后，调用的回调函数\n  HINSTANCE hmod,     &#x2F;&#x2F;回调函数所在的模块，这个模块需要是一个dll。\n  DWORD     dwThreadId  &#x2F;&#x2F;填0  截获系统中所有的窗口的消息  填线程ID  那就仅截获此线程的窗口消息\n);</code></pre>\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;当钩子使用完毕之后，卸载钩子\nBOOL WINAPI UnhookWindowsHookEx(\n    _In_ HHOOK hhk      &#x2F;&#x2F;填充返回的句柄\n    );</code></pre>\n\n<p>在钩子的消息拦截函数的最后，应该调用这个函数，因为程序可能会有多个钩子，新添加的在最上面，为了不影响其他钩子的功能，需要调用这个函数。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">WINUSERAPI\nLRESULT\nWINAPI\nCallNextHookEx(\n    _In_opt_ HHOOK hhk,    &#x2F;&#x2F;钩子的句柄\n    _In_ int nCode,\n    _In_ WPARAM wParam,\n    _In_ LPARAM lParam);</code></pre>\n\n<p>消息钩子的代码</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#define _countof(a) sizeof(a)&#x2F;sizeof(a[0])\nHHOOK g_Hook &#x3D; 0;\n&#x2F;&#x2F;拦截消息的回调函数\nLRESULT CALLBACK KeyboardProc(\n    int code,           &#x2F;&#x2F; 消息类型\n    WPARAM wParam,      &#x2F;&#x2F; 虚拟码\n    LPARAM lParam) &#123;    &#x2F;&#x2F; 按键信息\n    &#x2F;&#x2F; 判断是否wParam与lParam都有键盘消息，是的话则执行打印操作\n    if (code &#x3D;&#x3D; HC_ACTION) &#123;\n        &#x2F;&#x2F; 将256个虚拟键的状态拷贝到指定的缓冲区中，如果成功则继续\n        BYTE KeyState[256] &#x3D; &#123; 0 &#125;;\n        if (GetKeyboardState(KeyState)) &#123;\n            &#x2F;&#x2F; 得到第16–23位，键盘虚拟码\n            LONG  KeyInfo &#x3D; lParam;\n            UINT  keyCode &#x3D; (KeyInfo &gt;&gt; 16) &amp; 0x00ff;\n            WCHAR wKeyCode &#x3D; 0;\n            ToAscii((UINT)wParam, keyCode, KeyState, (LPWORD)&amp;wKeyCode, 0);\n            &#x2F;&#x2F; 将其打印出来\n            WCHAR szInfo[512] &#x3D; &#123; 0 &#125;;\n            swprintf_s(szInfo, _countof(szInfo), L&quot;Hook_%c&quot;, (char)wKeyCode);\n            OutputDebugString(szInfo);\n            return 0;\n        &#125;\n    &#125;\n    return CallNextHookEx(g_Hook, code, wParam, lParam);\n&#125;\n&#x2F;&#x2F;开启Hook的函数\nvoid OnHook()\n&#123;\n    HMODULE hModule &#x3D;  GetModuleHandle(L&quot;MessageHookdll.dll&quot;);\n    g_Hook &#x3D; SetWindowsHookEx(\n        WH_KEYBOARD,\n        KeyboardProc,\n        hModule,\n        NULL\n    );\n&#125;\n&#x2F;&#x2F;关闭Hook的函数\nvoid UnHook()\n&#123;\n    if (g_Hook!&#x3D;0)\n    &#123;\n        UnhookWindowsHookEx(g_Hook);\n        g_Hook &#x3D; 0;\n    &#125;\n&#125;</code></pre>\n\n<p>消息钩子使用了调试函数 OutputDebugString(szInfo);输出按键码，但我们看不到对方程序的调试信息，可以通过下图程序查看</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/CAMG3TfF.png\" alt=\"5.png\" title=\"5.png\" />\n\n<p>自定义钩子：</p>\n<p>自定义钩子两大类：内联钩子 修改存储函数地址变量的钩子</p>\n<p>4.1 什么是内联钩子 inline-Hook</p>\n<p>任何位置，都可以修改为jmp，使其执行到此处时，能够跳转到我们自己的代码去执行：</p>\n<p>1 被修改的指令，是否是有用的，如果是有用的，那么你就需要在你自己的代码中，将有用的指令写一遍，使其在你代码中能够执行。</p>\n<p>2 jmp指令一般是5个字节，所以我们选取的指令最好也是5个字节，如果不是5个字节，那么会发生指令截断，跳转回来的时候，就需要考虑跳转到完整的指令后去执行程序本身的代码。</p>\n<p>3 jmp指令OPCODE的操作数怎么求得，也是Hook的关键知识点</p>\n<p>jmp指令OPCODE的操作数 &#x3D; 要跳转的目标地址-hook点所在的地址-5</p>\n<h2 id=\"DLL测试代码\"><a href=\"#DLL测试代码\" class=\"headerlink\" title=\"DLL测试代码\"></a>DLL测试代码</h2><h3 id=\"InLine-HOOK\"><a href=\"#InLine-HOOK\" class=\"headerlink\" title=\"InLine_HOOK\"></a>InLine_HOOK</h3><p>.h文件</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#pragma once\nvoid OnHook();\nvoid OffHook();\nvoid InitHook();</code></pre>\n\n<p>.cpp文件</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &quot;HookMessageBox.h&quot;\n#include &lt;Windows.h&gt;\n\nunsigned char g_NewCode[5] &#x3D; &#123; 0xE9 &#125;;\nunsigned char g_OldCode[5] &#x3D; &#123;  &#125;;\nvoid OffHook();\nvoid OnHook();\nint WINAPI MyMessageBoxW(\n\t_In_opt_ HWND hWnd,\n\t_In_opt_ LPCWSTR lpText,\n\t_In_opt_ LPCWSTR lpCaption,\n\t_In_ UINT uType)\n&#123;\n\tlpText &#x3D; (wchar_t*)L&quot;你被打劫了^_^&quot;;\n\tDWORD dwReturnCode &#x3D; 0;\n\tOffHook();\n\tdwReturnCode &#x3D; MessageBoxW(hWnd, lpText, lpCaption, uType);\n\tOnHook();\n\treturn dwReturnCode;\n&#125;\nvoid InitHook()\n&#123;\n\t&#x2F;&#x2F;1 得到Hook的指令\n\tDWORD dwOffset &#x3D; (DWORD)MyMessageBoxW - (DWORD)MessageBoxW - 5;\n\t&#x2F;&#x2F;*(PDWORD)(code + 1) &#x3D; dwOffset;\n\tmemcpy(g_NewCode + 1, &amp;dwOffset, 4);\n\t&#x2F;&#x2F;2 得到原始的指令\n\tmemcpy(g_OldCode, MessageBoxW, 5);\n&#125;\n\nvoid OnHook()\n&#123;\n\n\t&#x2F;&#x2F;1 修改Hook点的属性\n\tDWORD dwOldProtect &#x3D; 0;\n\tVirtualProtect(MessageBoxW, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);\n\t&#x2F;&#x2F;2 修改指令\n\tmemcpy(MessageBoxW, g_NewCode,5);\n\t&#x2F;&#x2F;3 属性还原\n\tVirtualProtect(MessageBoxW, 5, dwOldProtect, &amp;dwOldProtect);\n&#125;\n\n\nvoid OffHook()\n&#123;\n\t&#x2F;&#x2F;1 改属性\n\tDWORD dwOldProtect &#x3D; 0;\n\tVirtualProtect(MessageBoxW, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);\n\t&#x2F;&#x2F;2 改指令\n\tmemcpy(MessageBoxW, g_OldCode, 5);\n\t&#x2F;&#x2F;3 属性还原\n\tVirtualProtect(MessageBoxW, 5, dwOldProtect, &amp;dwOldProtect);\n&#125;</code></pre>\n\n<p>dllmain.cpp文件</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &quot;framework.h&quot;\n#include &quot;HookMessageBox.h&quot;\nBOOL APIENTRY DllMain( HMODULE hModule,\n                       DWORD  ul_reason_for_call,\n                       LPVOID lpReserved\n                     )\n&#123;\n    switch (ul_reason_for_call)\n    &#123;\n    case DLL_PROCESS_ATTACH:\n\t&#123;\n\t\tInitHook();\n\t\tOnHook();\n\t&#125;\n\t\tbreak;\n    case DLL_THREAD_ATTACH:\n\t\tbreak;\n    case DLL_THREAD_DETACH:\n\t\tbreak;\n    case DLL_PROCESS_DETACH:\n\t&#123;\n\t\tOffHook();\n\t&#125;\n        break;\n    &#125;\n    return TRUE;\n&#125;</code></pre>\n\n<h3 id=\"IAT-HOOK\"><a href=\"#IAT-HOOK\" class=\"headerlink\" title=\"IAT_HOOK\"></a>IAT_HOOK</h3><p>.h文件</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#pragma once\n#include &lt;windows.h&gt;\nvoid IatHook(char* lpModuleAddress, DWORD FunAddress, const char* szTarFunName, const char* szTarDllName &#x3D; NULL);\nint WINAPI MyMessageBoxW(\n\t_In_opt_ HWND hWnd,\n\t_In_opt_ LPCWSTR lpText,\n\t_In_opt_ LPCWSTR lpCaption,\n\t_In_ UINT uType);</code></pre>\n\n<p>.cpp文件</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &quot;IATHookMessageBoxW.h&quot;\n#include &lt;Windows.h&gt;\ntypedef int (WINAPI* MESSAGEBOX)(\n\t_In_opt_ HWND hWnd,\n\t_In_opt_ LPCWSTR lpText,\n\t_In_opt_ LPCWSTR lpCaption,\n\t_In_ UINT uType);\nMESSAGEBOX g_OldMessageBox;\n\nvoid IatHook(char* lpModuleAddress, DWORD FunAddress, const char* szTarFunName, const char* szTarDllName)\n&#123;\n\t&#x2F;&#x2F;1 获取到导入表结构\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpModuleAddress;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpModuleAddress);\n\t&#x2F;&#x2F;1 获取到导入表的数据目录结构\n\tPIMAGE_DATA_DIRECTORY dwImportDir &#x3D; &amp;pNt-&gt;OptionalHeader.DataDirectory[1];\n\t&#x2F;&#x2F;1 获取到导入表结构\n\tPIMAGE_IMPORT_DESCRIPTOR pImportTable &#x3D;\n\t\t(PIMAGE_IMPORT_DESCRIPTOR)(lpModuleAddress + dwImportDir-&gt;VirtualAddress);\n\t&#x2F;&#x2F;2 解析导入表\n\t\t&#x2F;&#x2F;2 开始解析\n\twhile (pImportTable-&gt;Name !&#x3D; 0)\n\t&#123;\n\n\t\tchar* pDllName &#x3D; (pImportTable-&gt;Name + lpModuleAddress);\n\t\tchar* pbuf &#x3D; new char[strlen(pDllName) + 1]&#123; 0 &#125;;\n\t\tstrcpy_s(pbuf, strlen(pDllName) + 1, pDllName);\n\t\t_strlwr_s(pbuf, strlen(pDllName) + 1);\n\t\tif (szTarDllName !&#x3D; NULL)\n\t\t&#123;\n\t\t\tif (strcmp(szTarDllName, pbuf) &#x3D;&#x3D; 0)\n\t\t\t&#123;\n\t\t\t\t&#x2F;&#x2F;得到目标函数的地址\n\t\t\t\tHMODULE hModule &#x3D; GetModuleHandleA(pDllName);\n\t\t\t\tDWORD dwTarAddress &#x3D; (DWORD)GetProcAddress(hModule, szTarFunName);\n\t\t\t\t&#x2F;&#x2F;在IAT中寻找这个函数地址\n\t\t\t\tPIMAGE_THUNK_DATA32 pIat &#x3D; (PIMAGE_THUNK_DATA32)\n\t\t\t\t\t(pImportTable-&gt;FirstThunk + lpModuleAddress);\n\t\t\t\twhile (pIat-&gt;u1.Function!&#x3D;0)\n\t\t\t\t&#123;\n\t\t\t\t\t&#x2F;&#x2F;找到了之后开始Hook，IAT也是不可写的\n\t\t\t\t\tif (pIat-&gt;u1.Function &#x3D;&#x3D; dwTarAddress)\n\t\t\t\t\t&#123;\n\n\t\t\t\t\t\t&#x2F;&#x2F;保存了一下MessageBox的地址。\n\t\t\t\t\t\tg_OldMessageBox &#x3D; (MESSAGEBOX)pIat-&gt;u1.Function;\n\t\t\t\t\t\t&#x2F;&#x2F;1 修改Hook点的属性\n\t\t\t\t\t\tDWORD dwOldProtect &#x3D; 0;\n\t\t\t\t\t\tVirtualProtect(&amp;pIat-&gt;u1.Function, 4, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);\n\t\t\t\t\t\tpIat-&gt;u1.Function &#x3D; FunAddress;\n\t\t\t\t\t\tVirtualProtect(&amp;pIat-&gt;u1.Function, 4, dwOldProtect, &amp;dwOldProtect);\n\t\t\t\t\t&#125;\n\t\t\t\t\tpIat++;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\tpImportTable++;\n\t&#125;\n&#125;\nint WINAPI MyMessageBoxW(\n\t_In_opt_ HWND hWnd,\n\t_In_opt_ LPCWSTR lpText,\n\t_In_opt_ LPCWSTR lpCaption,\n\t_In_ UINT uType)\n&#123;\n\tlpText &#x3D; (wchar_t*)L&quot;你被打劫了^_^&quot;;\n\tDWORD dwReturnCode &#x3D; 0;\n\tdwReturnCode &#x3D; g_OldMessageBox(hWnd, lpText, lpCaption, uType);\n\treturn dwReturnCode;\n&#125;</code></pre>\n\n<p>dllmain.cpp</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &quot;framework.h&quot;\n#include &quot;IATHookMessageBoxW.h&quot;\nBOOL APIENTRY DllMain( HMODULE hModule,\n                       DWORD  ul_reason_for_call,\n                       LPVOID lpReserved\n                     )\n&#123;\n    switch (ul_reason_for_call)\n    &#123;\n    case DLL_PROCESS_ATTACH:\n\t&#123;\n\t\tLPVOID ExeBase &#x3D; GetModuleHandle(0);\n\t\tIatHook((char*)ExeBase,(DWORD)MyMessageBoxW,&quot;MessageBoxW&quot;,&quot;user32.dll&quot;);\n\t&#125;\n\n\t\t\tbreak;\n    case DLL_THREAD_ATTACH:\n    case DLL_THREAD_DETACH:\n    case DLL_PROCESS_DETACH:\n        break;\n    &#125;\n    return TRUE;\n&#125;</code></pre>\n\n<h3 id=\"Process-Hook\"><a href=\"#Process-Hook\" class=\"headerlink\" title=\"Process_Hook\"></a>Process_Hook</h3><h4 id=\"DLL文件\"><a href=\"#DLL文件\" class=\"headerlink\" title=\"DLL文件\"></a>DLL文件</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; dllmain.cpp : 定义 DLL 应用程序的入口点。\n#include &quot;stdafx.h&quot;\n#include &lt;TlHelp32.h&gt;\n\n&#x2F;&#x2F; 通过进程名获取进程id\nDWORD GetPid(const wchar_t* filePath);\n&#x2F;&#x2F; 获取helloworld程序pid\nDWORD g_dwPid &#x3D; GetPid(L&quot;FileCleaner2.0.exe&quot;);\n&#x2F;&#x2F; 旧的函数地址\nDWORD* g_pOldAddr &#x3D; (DWORD*)OpenProcess;\n&#x2F;&#x2F; 旧的函数数据\nchar g_oldCode[5] &#x3D; &#123;&#125;;\n\nvoid OnHook();\nvoid UnHook();\n\n&#x2F;&#x2F; 编写自己的OpenProcess函数\nHANDLE WINAPI MyOpenProcess(\n\t_In_ DWORD dwDesiredAccess,\n\t_In_ BOOL bInheritHandle,\n\t_In_ DWORD dwProcessId\n)\n&#123;\n\t&#x2F;&#x2F; 比对pid是否与helloworld程序相等\n\tif (dwProcessId &#x3D;&#x3D; g_dwPid)\n\t&#123;\n\t\tMessageBox(0,L&quot;进程被保护&quot;,L&quot;提示&quot;,0);\n\t&#125;\n\telse\n\t&#123;\n\t\t&#x2F;&#x2F; 如果不相等，重新调用原来的OpenProcess函数\n\t\t&#x2F;&#x2F; 先恢复原来函数数据\n\t\tUnHook();\n\t\tHANDLE hProcess &#x3D; OpenProcess(\n\t\t\tdwDesiredAccess, bInheritHandle, dwProcessId);\n\t\t&#x2F;&#x2F; 调用完之后重新hook\n\t\tOnHook();\n\t\treturn hProcess;\n\t&#125;\n&#125;\n\nBOOL APIENTRY DllMain(HMODULE hModule,\n\tDWORD  ul_reason_for_call,\n\tLPVOID lpReserved\n)\n&#123;\n\tswitch (ul_reason_for_call)\n\t&#123;\n\tcase DLL_PROCESS_ATTACH:\n\t&#123;\n\t\tOnHook();\n\t\tMessageBox(NULL, L&quot;注入成功&quot;, L&quot;提示&quot;, NULL);\n\t\tbreak;\n\t&#125;\n\tcase DLL_THREAD_ATTACH:\n\tcase DLL_THREAD_DETACH:\n\tcase DLL_PROCESS_DETACH:\n\t\tbreak;\n\t&#125;\n\treturn TRUE;\n&#125;\n\nvoid OnHook()\n&#123;\n\t&#x2F;&#x2F; 1.先保存OpenProcess原来的数据\n\tmemcpy(g_oldCode, g_pOldAddr, 5);\n\n\t&#x2F;&#x2F; 2.设置新的指令,jmp\n\tchar opcode[5] &#x3D; &#123; 0xE9 &#125;;\n\t&#x2F;&#x2F; 2.1 计算偏移并赋值\n\t*(DWORD*)(opcode + 1) &#x3D; (DWORD)MyOpenProcess - (DWORD)OpenProcess - 5;\n\n\t&#x2F;&#x2F; 3.修改保护属性\n\tDWORD dwOldProtect &#x3D; 0;\n\tVirtualProtect(g_pOldAddr, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);\n\n\t&#x2F;&#x2F; 4.写入跳转指令\n\tmemcpy(g_pOldAddr, opcode, 5);\n\t\n\t&#x2F;&#x2F; 5.还原保护属性\n\tVirtualProtect(g_pOldAddr, 5, dwOldProtect, &amp;dwOldProtect);\n&#125;\n\nvoid UnHook()\n&#123;\n\t&#x2F;&#x2F; 1.修改保护属性\n\tDWORD dwOldProtect &#x3D; 0;\n\tVirtualProtect(g_pOldAddr, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);\n\t&#x2F;&#x2F; 2.还原旧的指令数据\n\tmemcpy(g_pOldAddr, g_oldCode, 5);\n\t&#x2F;&#x2F; 3.还原保护属性\n\tVirtualProtect(g_pOldAddr, 5, dwOldProtect, &amp;dwOldProtect);\n&#125;\n\nDWORD GetPid(const wchar_t* szExeName)\n&#123;\n\t&#x2F;&#x2F; 创建进程快照\n\tHANDLE hSnapshot &#x3D; CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\t&#x2F;&#x2F; 判断快照句柄是否有效\n\tif (hSnapshot !&#x3D; INVALID_HANDLE_VALUE)\n\t&#123;\n\t\t&#x2F;&#x2F;定义进程结构体，第一个元素必须赋值为结构体大小\n\t\tPROCESSENTRY32 stcPe32 &#x3D; &#123; sizeof(PROCESSENTRY32) &#125;;\n\t\t&#x2F;&#x2F;查找第一个进程\n\t\tProcess32First(hSnapshot, &amp;stcPe32);\n\t\tdo\n\t\t&#123;\t&#x2F;&#x2F; 如果进程名一致，返回进程id\n\t\t\tif (!wcscmp(stcPe32.szExeFile, szExeName))\n\t\t\t\treturn stcPe32.th32ProcessID;\n\n\t\t\t&#x2F;&#x2F;查找下一个进程\n\t\t&#125; while (Process32Next(hSnapshot, &amp;stcPe32));\n\t\t&#x2F;&#x2F;关闭快照句柄\n\t\tCloseHandle(hSnapshot);\n\t&#125;\n\treturn -1;\n&#125;</code></pre>\n\n<h4 id=\"测试文件\"><a href=\"#测试文件\" class=\"headerlink\" title=\"测试文件\"></a>测试文件</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; 注入.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。\n&#x2F;&#x2F;\n\n#include &quot;pch.h&quot;\n#include &lt;iostream&gt;\n#include &lt;windows.h&gt;\n#include &lt;TlHelp32.h&gt;\n\n#define DLLPATH &quot;C:\\\\Users\\\\hugan\\\\Documents\\\\15PB\\\\代码注入与拦截\\\\OD注入\\\\x64\\\\Debug\\\\InlineHook.dll&quot;\n&#x2F;&#x2F;#define DLLPATH &quot;D:\\\\041\\\\test\\\\Debug\\\\IatHook.dll&quot;\n\n&#x2F;&#x2F; 通过进程名获取进程id\nDWORD GetPid(const wchar_t* szExeName);\n\nint main()\n&#123;\n\t&#x2F;&#x2F; 1.获取目标进程句柄\n\t&#x2F;&#x2F; 1.1 获取指定进程id\n\tDWORD dwPid &#x3D; GetPid(L&quot;Taskmgr.exe&quot;);\n\t&#x2F;&#x2F; 1.2 打开进程（注入OD需要以管理员身份运行vs，否则无法打开进程)\n\tHANDLE hProcess &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);\n\t&#x2F;&#x2F; 1.3 检测进程句柄\n\tif (hProcess &#x3D;&#x3D; INVALID_HANDLE_VALUE)\n\t\treturn -1;\n\n\t&#x2F;&#x2F; 2.1 计算dll路径长度\n\tDWORD dwSize &#x3D; strlen(DLLPATH) + 1;\n\t&#x2F;&#x2F; 2.在目标进程申请一段空间\n\tLPVOID lpAddr &#x3D; VirtualAllocEx(\n\t\thProcess, 0, dwSize, MEM_COMMIT, PAGE_READWRITE);\n\n\t&#x2F;&#x2F; 3.1 写入之前可以先测试加载一下看能否成功\n\t&#x2F;*HMODULE hMod &#x3D; LoadLibraryA(DLLPATH);\n\tMessageBoxW(0, 0, 0, 0);*&#x2F;\n\n\t&#x2F;&#x2F; 3.将dll名字写入到目标进程空间中\n\t&#x2F;&#x2F; 注意：路径与函数必须匹配，A版函数配A版字符串。如果用W版，写入的时候，长度要乘以2，\n\t\t&#x2F;&#x2F;\t因为wcslen求出的是字符串长度而不是字节数\n\tif (!WriteProcessMemory(hProcess, lpAddr, DLLPATH, dwSize, NULL))\n\t\treturn -1;\n\n\t&#x2F;&#x2F; 4.创建远程线程\n\tHANDLE hRtThread &#x3D; CreateRemoteThread(hProcess, NULL, 0,\n\t\t(LPTHREAD_START_ROUTINE)LoadLibraryA,lpAddr, NULL, NULL);\n\n\t&#x2F;&#x2F; 5.等待执行结果\n\tWaitForSingleObject(hRtThread, -1);\n\t\n\t&#x2F;&#x2F; 6.获取线程退出码\n\tDWORD dwExitCode &#x3D; 0;\n\tGetExitCodeThread(hRtThread, &amp;dwExitCode);\n\t&#x2F;&#x2F; 6.1 退出码也就是LoadLibrary的返回值（如果执行成功，就是dll的模块句柄）\n\tHMODULE hModule &#x3D; (HMODULE)dwExitCode;\n\n\t&#x2F;&#x2F; 7.释放空间\n\tif (!VirtualFreeEx(hProcess, lpAddr, dwSize, MEM_DECOMMIT))\n\t\treturn -1;\n\tCloseHandle(hProcess);\n\n\treturn 0;\n&#125;\n\nDWORD GetPid(const wchar_t* szExeName)\n&#123;\n\t&#x2F;&#x2F; 创建进程快照\n\tHANDLE hSnapshot &#x3D; CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\t&#x2F;&#x2F; 判断快照句柄是否有效\n\tif (hSnapshot !&#x3D; INVALID_HANDLE_VALUE)\n\t&#123;\n\t\t&#x2F;&#x2F;定义进程结构体，第一个元素必须赋值为结构体大小\n\t\tPROCESSENTRY32 stcPe32 &#x3D; &#123; sizeof(PROCESSENTRY32) &#125;;\n\t\t&#x2F;&#x2F;查找第一个进程\n\t\tProcess32First(hSnapshot, &amp;stcPe32);\n\t\tdo\n\t\t&#123;\t&#x2F;&#x2F; 如果进程名一致，返回进程id\n\t\t\tif (!wcscmp(stcPe32.szExeFile, szExeName))\n\t\t\t\treturn stcPe32.th32ProcessID;\n\n\t\t\t&#x2F;&#x2F;查找下一个进程\n\t\t&#125; while (Process32Next(hSnapshot, &amp;stcPe32));\n\t\t&#x2F;&#x2F;关闭快照句柄\n\t\tCloseHandle(hSnapshot);\n\t&#125;\n\treturn -1;\n&#125;</code></pre>\n\n<h1 id=\"CAPIHook函数封装\"><a href=\"#CAPIHook函数封装\" class=\"headerlink\" title=\"CAPIHook函数封装\"></a>CAPIHook函数封装</h1><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#ifndef __APIHOOK_H__\n#define __APIHOOK_H__\n#include &lt;windows.h&gt;\nclass CAPIHook \n\n&#123;\n\npublic:\n       CAPIHook(LPSTR  pszModName, LPSTR pszFuncName,\n        PROC pfnHook, BOOL bExcludeAPIHookMod&#x3D;TRUE);\n       virtual ~CAPIHook();\n       operator PROC() &#123;return m_pfnOrig;&#125;\nprivate:\n\n       LPSTR m_pszModName;        &#x2F;&#x2F;导出要HOOK函数的模块的名字\n       LPSTR m_pszFuncName;  &#x2F;&#x2F;要HOOK的函数的名字\n       PROC m_pfnOrig;                  &#x2F;&#x2F;原API函数地址\n       PROC m_pfnHook;                &#x2F;&#x2F;HOOK后函数的地址\n       BOOL m_bExcludeAPIHookMod; &#x2F;&#x2F;是否将HOOK API的模块本身排除在外\nprivate:\n       static void ReplaceIATEntryInAllMods(LPSTR pszExportMod, PROC pfnCurrent,PROC pfnNew, BOOL bExcludeAPIHookMod);\n       static void ReplaceIATEntryInOneMod(LPSTR pszExportMod, PROC pfnCurrent,PROC pfnNew, HMODULE hModCaller);\n\n       &#x2F;&#x2F;下面的代码用来解决其他模块动态加载DLL的问题\nprivate:\n\n       &#x2F;&#x2F;这两个指针用来将所有的CAPIHook对象连在一起\n       static CAPIHook *sm_pHeader;\n       CAPIHook *m_pNext;\n\nprivate:\n\n       &#x2F;&#x2F;当一个新的DLL被加载时，调用此函数\n       static void WINAPI HookNewlyLoadedModule(HMODULE hModule, DWORD dwFlags);\n       &#x2F;&#x2F;用来跟踪当前进程加载新的DLL\n       static HMODULE WINAPI LoadLibraryA(PCSTR pszModulePath);\n       static HMODULE WINAPI LoadLibraryW(PCWSTR pszModulePath);\n       static HMODULE WINAPI LoadLibraryExA(PCSTR pszModulePath, HANDLE hFile, DWORD dwFlags);\n       static HMODULE WINAPI LoadLibraryExW(PCWSTR pszModulePath, HANDLE hFile, DWORD dwFlags);\n       &#x2F;&#x2F;如果请求已HOOK的API函数，则返回用户自定义函数的地址\n       static FARPROC WINAPI GetProcAddress(HMODULE hModule, PCSTR pszProcName); \n\nprivate:\n       &#x2F;&#x2F;自动对这些函数进行挂钩\n       static CAPIHook sm_LoadLibraryA;\n       static CAPIHook sm_LoadLibraryW;\n       static CAPIHook sm_LoadLibraryExA;\n       static CAPIHook sm_LoadLibraryExW;\n       static CAPIHook sm_GetProcAddress;\n&#125;;\n\n#endif\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;APIHook.cpp&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n#include &quot;APIHook.h&quot;\n#include &quot;Tlhelp32.h&quot;\n#include &lt;ImageHlp.h&gt;  &#x2F;&#x2F;为了调用ImageDirectoryEntryToData函数\n#pragma comment(lib, &quot;ImageHlp&quot;)\n\n&#x2F;&#x2F;CAPIHook对象链表的头指针\nCAPIHook *CAPIHook::sm_pHeader &#x3D; NULL;\nCAPIHook::CAPIHook(LPSTR pszModName, LPSTR pszFuncName,PROC pfnHook, BOOL bExcludeAPIHookMod&#x2F;* &#x3D;TRUE *&#x2F;)\n&#123;\n       &#x2F;&#x2F;保存这个Hook函数的信息\n       m_bExcludeAPIHookMod &#x3D; bExcludeAPIHookMod;\n       m_pszModName &#x3D; pszModName;\n       m_pszFuncName &#x3D; pszFuncName;\n       m_pfnHook &#x3D; pfnHook;\n       m_pfnOrig &#x3D; ::GetProcAddress(::GetModuleHandle(pszModName), pszFuncName);\n\n       &#x2F;&#x2F;将此对象添加到链表中\n       m_pNext &#x3D; sm_pHeader;\n       sm_pHeader &#x3D; this;\n       &#x2F;&#x2F;在所有当前已加载的模块中HOOK这个函数\n       ReplaceIATEntryInAllMods(m_pszModName, m_pfnOrig, m_pfnHook, bExcludeAPIHookMod);\n&#125; \n\nCAPIHook::~CAPIHook()\n&#123;\n       &#x2F;&#x2F;取消对所有模块中函数的HOOK\n       ReplaceIATEntryInAllMods(m_pszModName, m_pfnHook, m_pfnOrig,  m_bExcludeAPIHookMod);\n       CAPIHook *p &#x3D; sm_pHeader;\n\n       &#x2F;&#x2F;从链表中移除此对象\n       if(p &#x3D;&#x3D; this)\n       &#123;\n              sm_pHeader &#x3D; p-&gt;m_pNext;\n       &#125;\n       else\n       &#123;\n              while(p !&#x3D; NULL)\n              &#123;\n                     if(p-&gt;m_pNext &#x3D;&#x3D; this)\n                     &#123;\n                            p-&gt;m_pNext &#x3D; this-&gt;m_pNext;\n                            break;\n                     &#125;\n                     p &#x3D; p-&gt;m_pNext;\n              &#125;\n       &#125;     \n&#125; \n\nvoid CAPIHook::ReplaceIATEntryInOneMod(LPSTR pszExportMod, PROC pfnCurrent, PROC pfnNew, HMODULE hModCaller)\n&#123;\n       &#x2F;&#x2F;取得模块的导入表(import descriptor)的首地址\n       &#x2F;&#x2F;ImageDirectoryEntryToData函数可以返回导入表地址\n       ULONG ulSize;\n       PIMAGE_IMPORT_DESCRIPTOR pImportDesc &#x3D;(PIMAGE_IMPORT_DESCRIPTOR)::ImageDirectoryEntryToData(hModCaller, TRUE,IMAGE_DIRECTORY_ENTRY_IMPORT, &amp;ulSize);\n\n       if(pImportDesc &#x3D;&#x3D; NULL)      &#x2F;&#x2F;这个模块没有导入表项\n              return;  \n\n       &#x2F;&#x2F;查找包含pszExportMod模块中函数导入信息的导入表项\n       while(pImportDesc-&gt;Name !&#x3D; 0)\n       &#123;\n              LPSTR pszMod &#x3D; (LPSTR)((DWORD)hModCaller + pImportDesc-&gt;Name);\n              if (lstrcmpi(pszMod, pszExportMod) &#x3D;&#x3D; 0)    \n              &#123;\n                     break;\n              &#125;\n              pImportDesc++;\n       &#125;\n       if (pImportDesc-&gt;Name &#x3D;&#x3D; 0)    &#x2F;&#x2F;hModCaller模块没有从pszExportMod模块导入任何函数\n       &#123;\n              return;\n       &#125;\n\n       &#x2F;&#x2F;取得调用者的导入地址表(import address table, IAT)\n       PIMAGE_THUNK_DATA pThunk &#x3D; (PIMAGE_THUNK_DATA)(pImportDesc-&gt;FirstThunk +  (DWORD)hModCaller);\n\n       &#x2F;&#x2F;查找我们要HOOK的函数，将它的地址用新函数的地址替换掉\n       while (pThunk-&gt;u1.Function)\n       &#123;\n              &#x2F;&#x2F;lpAddr指向的内存保存了函数的地址\n              PDWORD lpAddr &#x3D; (PDWORD)&amp;(pThunk-&gt;u1.Function);\n              if (*lpAddr &#x3D;&#x3D; (DWORD)pfnCurrent)\n              &#123;\n                     &#x2F;&#x2F;修改页的保护属性\n                     DWORD dwOldProtect;\n                     MEMORY_BASIC_INFORMATION mbi;\n                     ::VirtualQuery(lpAddr, &amp;mbi, sizeof(mbi));\n                     ::VirtualProtect(lpAddr, sizeof(DWORD), PAGE_READWRITE, &amp;dwOldProtect);\n \n\n                     &#x2F;&#x2F;修改内存地址，相当于&quot;lpAddr &#x3D; (DWORD)pfnNew;&quot;\n                     ::WriteProcessMemory(::GetCurrentProcess(), lpAddr,  &amp;pfnNew, sizeof(DWORD), NULL);\n                     ::VirtualProtect(lpAddr, sizeof(DWORD), dwOldProtect, 0);\n                     break;\n              &#125;\n              pThunk++;\n       &#125;\n&#125;\n\n \n\nvoid CAPIHook::ReplaceIATEntryInAllMods(LPSTR pszExportMod, PROC pfnCurrent, PROC pfnNew, BOOL bExcludeAPIHookMod)\n&#123;\n       &#x2F;&#x2F;取得当前模块的句柄\n       HMODULE hModThis &#x3D; NULL;\n       if(bExcludeAPIHookMod)\n       &#123;\n              MEMORY_BASIC_INFORMATION mbi;\n              if(::VirtualQuery(ReplaceIATEntryInAllMods, &amp;mbi, sizeof(mbi)) !&#x3D; 0)\n                     hModThis &#x3D; (HMODULE)mbi.AllocationBase;\n       &#125;\n\n       &#x2F;&#x2F;取得本进程的模块列表\n       HANDLE hSnap &#x3D; ::CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, ::GetCurrentProcessId());\n \n\n       &#x2F;&#x2F;遍历所有模块，分别对它们调用ReplaceIATEntryInOnMod函数，修改导入地址表\n       MODULEENTRY32 me &#x3D; &#123;sizeof(MODULEENTRY32)&#125;;\n       BOOL bOK &#x3D; ::Module32First(hSnap, &amp;me);\n       while (bOK)\n       &#123;\n              &#x2F;&#x2F;注意，我们不HOOK当前模块的函数\n              if (me.hModule !&#x3D; hModThis)\n              &#123;\n                    ReplaceIATEntryInOneMod(pszExportMod, pfnCurrent, pfnNew, me.hModule);\n              &#125;\n\n              bOK &#x3D; ::Module32Next(hSnap, &amp;me);\n       &#125;\n       ::CloseHandle(hSnap);\n&#125;\n\n \n\n&#x2F;&#x2F;挂钩LoadLibrary和GetProcAddress函数，以便在这些函数被调用以后，挂钩的函数也能够被正确的处理\nCAPIHook CAPIHook::sm_LoadLibraryA(&quot;Kernel32.dll&quot;, &quot;LoadLibraryA&quot;, (PROC)CAPIHook::LoadLibraryA, TRUE);\nCAPIHook CAPIHook::sm_LoadLibraryW(&quot;Kernel32.dll&quot;, &quot;LoadLibraryW&quot;, (PROC)CAPIHook::LoadLibraryW, TRUE);\nCAPIHook CAPIHook::sm_LoadLibraryExA(&quot;Kernel32.dll&quot;, &quot;LoadLibraryExA&quot;,(PROC)CAPIHook::LoadLibraryExA, TRUE);\nCAPIHook CAPIHook::sm_LoadLibraryExW(&quot;Kernel32.dll&quot;, &quot;LoadLibraryExW&quot;,(PROC)CAPIHook::LoadLibraryExW, TRUE);\nCAPIHook CAPIHook::sm_GetProcAddress(&quot;Kernel32.dll&quot;, &quot;GetProcAddress&quot;, (PROC)CAPIHook::GetProcAddress, TRUE);\n\nvoid WINAPI CAPIHook::HookNewlyLoadedModule(HMODULE hModule, DWORD dwFlags)\n&#123;\n       &#x2F;&#x2F;如果一个新的模块被加载，挂钩各CAPIHook对象要求的API函数\n       if((hModule !&#x3D; NULL) &amp;&amp; ((dwFlags&amp;LOAD_LIBRARY_AS_DATAFILE) &#x3D;&#x3D; 0))\n       &#123;\n              CAPIHook *p &#x3D; sm_pHeader;\n              while (p !&#x3D; NULL)\n              &#123;\n                     ReplaceIATEntryInOneMod(p-&gt;m_pszModName, p-&gt;m_pfnOrig, p-&gt;m_pfnHook, hModule);\n                     p &#x3D; p-&gt;m_pNext;\n              &#125;\n       &#125;\n&#125;\n\n \n\nHMODULE WINAPI CAPIHook::LoadLibraryA(PCSTR pszModulePath)\n&#123;\n       HMODULE hModule &#x3D; ::LoadLibraryA(pszModulePath);\n       HookNewlyLoadedModule(hModule, 0);\n       return hModule;\n&#125;\n\n \n\nHMODULE WINAPI CAPIHook::LoadLibraryW(PCWSTR pszModulePath)\n&#123;\n       HMODULE hModule &#x3D; ::LoadLibraryW(pszModulePath);\n       HookNewlyLoadedModule(hModule, 0);\n       return hModule;\n&#125;\n\n \n\nHMODULE WINAPI CAPIHook::LoadLibraryExA(PCSTR pszModulePath, HANDLE hFile, DWORD dwFlags)\n&#123;\n       HMODULE hModule &#x3D; ::LoadLibraryExA(pszModulePath, hFile, dwFlags);\n       HookNewlyLoadedModule(hModule, dwFlags);\n       return hModule;\n&#125;\n\n \n\nHMODULE WINAPI CAPIHook::LoadLibraryExW(PCWSTR pszModulePath, HANDLE hFile, DWORD dwFlags)\n&#123;\n       HMODULE hModule &#x3D; ::LoadLibraryExW(pszModulePath, hFile, dwFlags);\n       HookNewlyLoadedModule(hModule, dwFlags);\n       return hModule;\n&#125;\n\n \n\nFARPROC WINAPI CAPIHook::GetProcAddress(HMODULE hModule, PCSTR pszProcName)\n&#123;\n       &#x2F;&#x2F;得到函数的真实地址\n       FARPROC pfn &#x3D; ::GetProcAddress(hModule, pszProcName);\n       &#x2F;&#x2F;看它是否我们要HOOK的函数\n       CAPIHook *p &#x3D; sm_pHeader;\n       while(p !&#x3D; NULL)\n       &#123;\n              if (p-&gt;m_pfnOrig &#x3D;&#x3D; pfn)\n              &#123;\n                     pfn &#x3D; p-&gt;m_pfnHook;\n                     break;\n              &#125;\n              p &#x3D; p-&gt;m_pNext;\n       &#125;\n       return pfn;\n&#125;</code></pre>\n","text":"权限权限管理 UAC机制管理方式在管理员账户下，运行一个程序，也是低权限，只有选择管理员方式运行，才会分配高权限。 调整UAC方法1：gpedit 方法2 ：设置 使用案例BOOL CMy01UACDlg::OnInitDialog() &#123; CDialogEx::OnI...","link":"","photos":[],"count_time":{"symbolsCount":"38k","symbolsTime":"34 mins."},"categories":[{"name":"Windows安全","slug":"Windows安全","count":4,"path":"api/categories/Windows安全.json"}],"tags":[{"name":"Windows注入","slug":"Windows注入","count":1,"path":"api/tags/Windows注入.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9D%83%E9%99%90\"><span class=\"toc-text\">权限</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">权限管理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#UAC%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">UAC机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F\"><span class=\"toc-text\">管理方式</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B0%83%E6%95%B4UAC\"><span class=\"toc-text\">调整UAC</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8%E6%A1%88%E4%BE%8B\"><span class=\"toc-text\">使用案例</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">内存管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%A0%86%E7%9A%84%E7%AE%A1%E7%90%86\"><span class=\"toc-text\">堆的管理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">基本使用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%81%8D%E5%8E%86%E5%A0%86\"><span class=\"toc-text\">遍历堆</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">虚拟内存管理函数</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%89%E5%85%A8%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">安全属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%94%B3%E8%AF%B7%E5%92%8C%E9%87%8A%E6%94%BE\"><span class=\"toc-text\">申请和释放</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BF%AE%E6%94%B9%E4%BF%9D%E6%8A%A4%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">修改保护属性</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E6%98%A0%E5%B0%84\"><span class=\"toc-text\">文件映射</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E8%AE%AF\"><span class=\"toc-text\">进程间通讯</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%AE%AFA%E7%AB%AF\"><span class=\"toc-text\">通讯A端</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%80%9A%E8%AE%AFB%E7%AB%AF\"><span class=\"toc-text\">通讯B端</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%9A%84%E9%81%8D%E5%8E%86\"><span class=\"toc-text\">虚拟内存的遍历</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A1%B5%E9%9D%A2%E7%9A%84%E7%8A%B6%E6%80%81\"><span class=\"toc-text\">页面的状态</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%A1%B5%E9%9D%A2%E7%B1%BB%E5%9E%8B\"><span class=\"toc-text\">页面类型</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%81%8D%E5%8E%86%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">遍历代码</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Dll%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">Dll注入</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">远程线程注入</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B6%88%E6%81%AF%E9%92%A9%E5%AD%90%E6%B3%A8%E5%85%A5\"><span class=\"toc-text\">消息钩子注入</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#DLL%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">DLL测试代码</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#InLine-HOOK\"><span class=\"toc-text\">InLine_HOOK</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IAT-HOOK\"><span class=\"toc-text\">IAT_HOOK</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Process-Hook\"><span class=\"toc-text\">Process_Hook</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#DLL%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">DLL文件</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">测试文件</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#CAPIHook%E5%87%BD%E6%95%B0%E5%B0%81%E8%A3%85\"><span class=\"toc-text\">CAPIHook函数封装</span></a></li></ol>","author":{"name":"Akpigs","slug":"blog-author","avatar":"https://img1.imgtp.com/2022/12/28/m2fD4XcB.jpg","link":"/","description":"Sharp tools make good work, 玉不琢，不成器；人不学，不知道。","socials":{"github":"https://github.com/akpigs","twitter":"https://twitter.com/EmilyLe443","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://akpigs.blog.csdn.net/","juejin":"","customs":{"discord":{"icon":"/svg/discord.svg","link":"https://discord.gg/vS7yaWgW"},"bilibili":{"icon":"/svg/bilibili.svg","link":"https://www.bilibili.com"},"facebook":{"icon":"/svg/facebook.svg","link":"https://facebook.com"}}}},"mapped":true,"prev_post":{"title":"Windows脱壳-基础","uid":"d5e1f921b320f1d632be0f3eb7b4b1ce","slug":"Windows脱壳-基础","date":"2020-10-25T03:08:33.000Z","updated":"2022-12-30T15:19:13.929Z","comments":true,"path":"api/articles/Windows脱壳-基础.json","keywords":null,"cover":"https://img1.imgtp.com/2022/12/29/JgdMGRJU.jpg","text":" 旅行者,本破站点旨在原创文章记录学习经历&amp;&amp;收集优秀资源减少学习成本，如果您又更好的想法请联系我。让我们一起传承开源精神🤓…… 知识点回顾1、PE文件的Magic code(魔数、幻数)是什么？ MZ头、PE头 2、PE文件中文件头的信息有哪些？ 运行平台、时间...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"Windows安全","slug":"Windows安全","count":4,"path":"api/categories/Windows安全.json"}],"tags":[{"name":"脱壳","slug":"脱壳","count":1,"path":"api/tags/脱壳.json"}],"author":{"name":"Akpigs","slug":"blog-author","avatar":"https://img1.imgtp.com/2022/12/28/m2fD4XcB.jpg","link":"/","description":"Sharp tools make good work, 玉不琢，不成器；人不学，不知道。","socials":{"github":"https://github.com/akpigs","twitter":"https://twitter.com/EmilyLe443","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://akpigs.blog.csdn.net/","juejin":"","customs":{"discord":{"icon":"/svg/discord.svg","link":"https://discord.gg/vS7yaWgW"},"bilibili":{"icon":"/svg/bilibili.svg","link":"https://www.bilibili.com"},"facebook":{"icon":"/svg/facebook.svg","link":"https://facebook.com"}}}}},"next_post":{"title":"内核基础","uid":"ebb230849b36768b2e4833fd7043c535","slug":"内核基础","date":"2019-05-24T08:06:18.000Z","updated":"2022-12-30T15:25:42.269Z","comments":true,"path":"api/articles/内核基础.json","keywords":null,"cover":"https://img1.imgtp.com/2022/12/30/Lg0NMJmk.jpg","text":"分段机制 在 32 位保护模式下，段寄存器就不会再直接保存段基址了，而是分成了可见的 16 位段选择子部分和不可见的 80 位高速缓冲部分，对于访问内存需要用到的一些信息，例如段的基址、限长和访问属性等都会被保存在这里的不可见部分。这一部分的内容无法人为的直接读取到，在段寄存器进...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[{"name":"内核","slug":"内核","count":1,"path":"api/categories/内核.json"}],"tags":[{"name":"内核基础","slug":"内核基础","count":1,"path":"api/tags/内核基础.json"}],"author":{"name":"Akpigs","slug":"blog-author","avatar":"https://img1.imgtp.com/2022/12/28/m2fD4XcB.jpg","link":"/","description":"Sharp tools make good work, 玉不琢，不成器；人不学，不知道。","socials":{"github":"https://github.com/akpigs","twitter":"https://twitter.com/EmilyLe443","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://akpigs.blog.csdn.net/","juejin":"","customs":{"discord":{"icon":"/svg/discord.svg","link":"https://discord.gg/vS7yaWgW"},"bilibili":{"icon":"/svg/bilibili.svg","link":"https://www.bilibili.com"},"facebook":{"icon":"/svg/facebook.svg","link":"https://facebook.com"}}}}}}