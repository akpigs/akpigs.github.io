{"title":"PE文件结构","uid":"86f54a7f49d13d2fe3670c2f70767f91","slug":"PE文件结构","date":"2020-11-24T06:55:09.000Z","updated":"2022-12-30T15:23:07.668Z","comments":true,"path":"api/articles/PE文件结构.json","keywords":null,"cover":"https://img1.imgtp.com/2022/12/30/tRphgbmC.jpg","content":"<h2 id=\"什么是文件\"><a href=\"#什么是文件\" class=\"headerlink\" title=\"什么是文件\"></a>什么是文件</h2><p>存储数据的实体。</p>\n<p>不同的文件是给不同的软件去使用的。不同的文件主要是格式不同。</p>\n<p>格式就是数组的排列组织方式</p>\n<p>。软件读取文件，按照固定的形式去解析文件的。</p>\n<h2 id=\"什么是PE文件\"><a href=\"#什么是PE文件\" class=\"headerlink\" title=\"什么是PE文件\"></a>什么是PE文件</h2><p>（Portable Executable）可执行 文件的缩写。这种类型的文件，是供windows系统解析，解析完了之后能够创建出进程去运行的文件。</p>\n<h2 id=\"PE头部信息\"><a href=\"#PE头部信息\" class=\"headerlink\" title=\"PE头部信息\"></a>PE头部信息</h2><p>（DOS头，NT头，区段表）</p>\n<p>我们学习PE文件学习的是什么呢？？学习的就是PE文件的格式，学习格式就是在学习一堆结构体。很多东西需要记忆。</p>\n<p>为了便于我们记忆，需要一些辅助性的工具。</p>\n<h3 id=\"PE头部粗略图\"><a href=\"#PE头部粗略图\" class=\"headerlink\" title=\"PE头部粗略图\"></a>PE头部粗略图</h3><img src=\"https://img1.imgtp.com/2022/12/29/mO31cuPA.png\" alt=\"1.png\" title=\"1.png\" />\n\n<h2 id=\"DOS头\"><a href=\"#DOS头\" class=\"headerlink\" title=\"DOS头\"></a>DOS头</h2><h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><p>在windows系统中的可执行文件在设计的时候，考虑到了兼容性问题。在正常的可执行文件的一开始的部分。嵌入了一个DOS可执行文件。作用就是在MS-DOS系统下能够输出一行这个程序不是运行在此系统下的。</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/Csm0f4gP.png\" alt=\"2.png\" title=\"2.png\" />\n\n<p>这里有两个字段是有用的：</p>\n<p>第一个 e_magic 永远都是 0x4D 0x5A 0x5A4D 你需要知道大端和小端的知识。</p>\n<p>最后一个 e_lfanew 它是真正的可执行文件的起始位置。</p>\n<ul>\n<li>实验一:假如我们修改了e_magic字段或者e_lfanew，PE文件是否还能运行？<ul>\n<li>将e_magic修改为”OZ”，保存执行</li>\n<li>将e_magic改回”MZ”，e_lfanew改为0x1000，保存执行</li>\n</ul>\n</li>\n</ul>\n<p>尝试之后不行，这两个字段是重要字段，抹掉程序就无法运行了。</p>\n<ul>\n<li>实验二：抹掉除了e_magic和e_lfanew之外的字段，可不可以。</li>\n</ul>\n<h3 id=\"怎么找到DOS头\"><a href=\"#怎么找到DOS头\" class=\"headerlink\" title=\"怎么找到DOS头\"></a>怎么找到DOS头</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;lpImage是ReadFile打开文件后的写入的缓冲区（堆空间）\nPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n&#x2F;&#x2F;pDos的e_magic字段，作为是否为PE文件的标志\npDos-&gt;e_magic &#x3D;&#x3D; IMAGE_DOS_SIGNATURE\n&#x2F;&#x2F;pDos的e_lfanew字段可以指向NT头的空间\nPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)pDos-&gt;e_lfanew;\n\n&#x2F;&#x2F;例：\n&#x2F;&#x2F;1 打开文件\n\tHANDLE hFile &#x3D; CreateFile(\n\t\tPATH,\n\t\tGENERIC_ALL,\n\t\tNULL,\n\t\tNULL,\n\t\tOPEN_EXISTING,\n\t\tFILE_ATTRIBUTE_NORMAL,\n\t\tNULL\n\t);\n\t&#x2F;&#x2F;2 获取文件大小\n\tDWORD dwFileSize &#x3D; GetFileSize(hFile, NULL);\n\t&#x2F;&#x2F;3 申请空间并初始化\n\tchar* buf &#x3D; new char[dwFileSize] &#123;0&#125;;\n\t&#x2F;&#x2F;4 读取文件\n\tDWORD dwRealSize &#x3D; 0;\n\tReadFile(hFile, buf, dwFileSize, &amp;dwRealSize, NULL);</code></pre>\n\n<h2 id=\"NT头\"><a href=\"#NT头\" class=\"headerlink\" title=\"NT头\"></a>NT头</h2><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef struct _IMAGE_NT_HEADERS\n&#123;\n    DWORD Signature;                        &#x2F;&#x2F; [0x00]PE标识\n    IMAGE_FILE_HEADER FileHeader;           &#x2F;&#x2F; [0x04]文件头\n    IMAGE_OPTIONAL_HEADER32 OptionalHeader; &#x2F;&#x2F; [0x18]扩展头\n&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</code></pre>\n\n<p>怎么找到Nt头?</p>\n<p>通过DOS头的最后一个字段：e_lfanew 指定的是NT头的位置</p>\n<p>Signature：</p>\n<p>标识：PE00</p>\n<p>可以和魔数配合，判断是否是PE文件。</p>\n<p>永远都是 0x50 0x45 0x00 0x00 0x00004550</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;打开PE文件后，第一个段就是DOS头部\nPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n&#x2F;&#x2F;pDos的e_lfanew字段可以指向NT头的空间，使用NT头接收\nPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)pDos-&gt;e_lfanew;</code></pre>\n\n<p>IMAGE_FILE_HEADER：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef struct _IMAGE_FILE_HEADER &#123;\n    WORD     Machine;\t\t\t        &#x2F;&#x2F;[0x04] （1）运行平台\n    WORD     NumberOfSections;\t\t&#x2F;&#x2F;[0x06] （2）区段的数量*\n    DWORD   TimeDateStamp;\t\t    &#x2F;&#x2F;[0x08] （3）文件创建时间\n    DWORD   PointerToSymbolTable;\t&#x2F;&#x2F;[0x0C] （4）符号表指针\n    DWORD   NumberOfSymbols;\t\t  &#x2F;&#x2F;[0x10] （5）符号的数量\n    WORD     SizeOfOptionalHeader;&#x2F;&#x2F;[0x14] （6）扩展头大小*\n    WORD     Characteristics;\t\t  &#x2F;&#x2F;[0x16] （7）文件属性\n&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</code></pre>\n\n<img src=\"https://img1.imgtp.com/2022/12/29/kgFwUgaI.png\" alt=\"3.png\" title=\"3.png\" />\n\n<p>重要的：</p>\n<p>NumberOfSection：区段的数量</p>\n<p>SizeOfOptionalHeader：扩展头的大小。因为扩展头中数据目录表的个数是不确定的。所以这里需要一个大小</p>\n<p>有用的：</p>\n<p>Machine：运行平台</p>\n<p>TimeDateStamp：时间戳 表明是在什么时候编译的</p>\n<p>手工解析</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Code\n50 45 00 00 4C 01 05 00 91 CF 44 54 00 00 00 00\n00 00 00 00 E0 00 02 01 </code></pre>\n\n<p>50 45 00 00 PE标识</p>\n<p>01 4C 运行平台</p>\n<p>00 没用</p>\n<p>05 区段数量</p>\n<p>91 CF 44 54 时间戳</p>\n<p>E0 扩展头大小</p>\n<p>0201 属性</p>\n<p>因为大端小端，我们需要反过来看</p>\n<h3 id=\"关于镜像，映像，虚拟地址，相对虚拟地址\"><a href=\"#关于镜像，映像，虚拟地址，相对虚拟地址\" class=\"headerlink\" title=\"关于镜像，映像，虚拟地址，相对虚拟地址\"></a>关于镜像，映像，虚拟地址，相对虚拟地址</h3><p>镜像：就是PE文件自身</p>\n<p>映像：就是根据PE文件映射出来的，</p>\n<p>虚拟地址：程序中的内存地址，就是虚拟地址。</p>\n<p>相对虚拟地址：就是相对于加载基址的偏移。</p>\n<h2 id=\"文件头\"><a href=\"#文件头\" class=\"headerlink\" title=\"文件头\"></a>文件头</h2><p>IMAGE_FILE_HEADER</p>\n<h3 id=\"文件头结构体\"><a href=\"#文件头结构体\" class=\"headerlink\" title=\"文件头结构体\"></a>文件头结构体</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef struct _IMAGE_FILE_HEADER &#123;\n    WORD    Machine;\t\t\t\t\t\t&#x2F;&#x2F;运行平台\n    WORD    NumberOfSections;\t\t\t\t&#x2F;&#x2F;区段的数量\n    DWORD   TimeDateStamp;\t\t\t\t\t&#x2F;&#x2F;文件创建的时间\n    DWORD   PointerToSymbolTable;\t\t\t&#x2F;&#x2F;符号表偏移\n    DWORD   NumberOfSymbols;\t\t\t\t&#x2F;&#x2F;符号个数\n    WORD    SizeOfOptionalHeader;\t\t\t&#x2F;&#x2F;扩展头大小\n    WORD    Characteristics;\t\t\t\t&#x2F;&#x2F;PE文件的一些属性\n&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</code></pre>\n\n<h3 id=\"怎么找到文件头\"><a href=\"#怎么找到文件头\" class=\"headerlink\" title=\"怎么找到文件头\"></a>怎么找到文件头</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;打开PE文件后，第一个段就是DOS头部\nPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n&#x2F;&#x2F;pDos的e_lfanew字段可以指向NT头的空间，使用NT头接收\nPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)pDos-&gt;e_lfanew;\n&#x2F;&#x2F;NT头结构体的第二个参数就是指向扩展头\nPIMAGE_FILE_HEADER pFile &#x3D; (PIMAGE_FILE_HEADER)&amp;pNt-&gt;FileHeader;</code></pre>\n\n<h2 id=\"扩展头\"><a href=\"#扩展头\" class=\"headerlink\" title=\"扩展头\"></a>扩展头</h2><p>IMAGE_OPTIONAL_HEADER：</p>\n<h3 id=\"找到扩展头\"><a href=\"#找到扩展头\" class=\"headerlink\" title=\"找到扩展头\"></a>找到扩展头</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;打开PE文件后，第一个段就是DOS头部\nPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n&#x2F;&#x2F;pDos的e_lfanew字段可以指向NT头的空间，使用NT头接收\nPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)pDos-&gt;e_lfanew;\n&#x2F;&#x2F;NT头结构体的第三个参数就是指向扩展头\n\tPIMAGE_OPTIONAL_HEADER pOption &#x3D;  (PIMAGE_OPTIONAL_HEADER)&amp;pNt-&gt;OptionalHeader;</code></pre>\n\n<h3 id=\"扩展头结构体\"><a href=\"#扩展头结构体\" class=\"headerlink\" title=\"扩展头结构体\"></a>扩展头结构体</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef struct _IMAGE_OPTIONAL_HEADER &#123;\n    &#x2F;&#x2F; 标准域\n    WORD    Magic;\t\t\t\t\t\t&#x2F;&#x2F;[0x18] (1) 标志位\n    BYTE    MajorLinkerVersion; \t\t&#x2F;&#x2F;[0x1A] (2) 连接器主版本号\n    BYTE    MinorLinkerVersion; \t\t&#x2F;&#x2F;[0x1B] (3) 连接器子版本号\n    DWORD   SizeOfCode; \t\t\t\t&#x2F;&#x2F;[0x1C] (4) 所有代码段 的总大小\n    DWORD   SizeOfInitializedData; \t\t&#x2F;&#x2F;[0x20] (5) 所有初始化段总大小\n    DWORD   SizeOfUninitializedData;\t&#x2F;&#x2F;[0x24] (6) 所有未初始化段总大小\n    DWORD   AddressOfEntryPoint;\t\t&#x2F;&#x2F;[0x28] (7) 程序执行入口RVA*\n    DWORD   BaseOfCode; \t\t\t\t&#x2F;&#x2F;[0x2C] (8) 代码段起始RVA\n    DWORD   BaseOfData; \t\t\t\t&#x2F;&#x2F;[0x30] (9) 数据段起始RVA\n    &#x2F;&#x2F; NT 附加域\n    DWORD   ImageBase; \t\t\t\t\t&#x2F;&#x2F;[0x34] (10) 程序默认载入基地址*\n    DWORD   SectionAlignment; \t\t\t&#x2F;&#x2F;[0x38] (11) 内存中的段对齐值\n    DWORD   FileAlignment; \t\t\t\t&#x2F;&#x2F;[0x3C] (12) 文件中的段对齐值\n    WORD    MajorOperatingSystemVersion; &#x2F;&#x2F;[0x40] (13) 系统主版本号\n    WORD    MinorOperatingSystemVersion; &#x2F;&#x2F;[0x42] (14) 系统子版本号\n    WORD    MajorImageVersion; \t\t\t&#x2F;&#x2F;[0x44] (15) 自定义的主版本号\n    WORD    MinorImageVersion;\t\t\t&#x2F;&#x2F;[0x46] (16) 自定义的子版本号\n    WORD    MajorSubsystemVersion; \t\t&#x2F;&#x2F;[0x48] (17) 所需子系统主版本号\n    WORD    MinorSubsystemVersion; \t\t&#x2F;&#x2F;[0x4A] (18) 所需子系统子版本号\n DWORD   Win32VersionValue;\t\t\t\t&#x2F;&#x2F;[0x4C] (19) 保留，通常为0x00\n    DWORD   SizeOfImage; \t\t\t\t&#x2F;&#x2F;[0x50] (20) 内存中映像总尺寸*\n    DWORD   SizeOfHeaders; \t\t\t\t&#x2F;&#x2F;[0x54] (21) 各个文件头的总尺寸*\n    DWORD   CheckSum; \t\t\t\t\t&#x2F;&#x2F;[0x58] (22) 映像文件校验和\n    WORD     Subsystem; \t            &#x2F;&#x2F;[0x5C] (23) 文件子系统\n    WORD     DllCharacteristics; \t\t&#x2F;&#x2F;[0x5E] (24) DLL标志位\n    DWORD   SizeOfStackReserve;         &#x2F;&#x2F;[0x60] (25) 初始化栈大小\n    DWORD   SizeOfStackCommit;        \t&#x2F;&#x2F;[0x64] (26) 初始化实际提交栈大小\n    DWORD   SizeOfHeapReserve;         \t&#x2F;&#x2F;[0x68] (27) 初始化保留栈大小\n    DWORD   SizeOfHeapCommit;         \t&#x2F;&#x2F;[0x6C] (28) 初始化实际保留栈大小\n    DWORD   LoaderFlags;                &#x2F;&#x2F;[0x70] (29) 调试相关，默认0x00\n    DWORD   NumberOfRvaAndSizes;  \t\t&#x2F;&#x2F;[0x74] (30) 数据目录表的数量*\n    IMAGE_DATA_DIRECTORY DataDirectory[0x10]; &#x2F;&#x2F;[0x78] (31) 数据目录表*\n&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</code></pre>\n\n<img src=\"https://img1.imgtp.com/2022/12/29/KdnXSTpJ.png\" alt=\"4.png\" title=\"4.png\" />\n\n<p><strong>非常重要的：</strong></p>\n<p>ImageBase：程序的默认加载基址。</p>\n<p>AddressOfEntryPoint： 程序的入口点（EP）。</p>\n<p>比较重要的：</p>\n<p>SectionAlignment： 内存对齐 0x1000（因为一页内存是4KB）</p>\n<p>FileAlignment： 文件对齐 0x200</p>\n<p>SizeOfImage： 映像大小（我这个PE文件被加载到内存，占用空间应该是多大）</p>\n<p>SIzeOfHeader： 头部大小 DOS头+NT头+区块表的大小。</p>\n<p>NumberOfRvaAndSizes: 数据目录表的元素个数</p>\n<p>DllCharacteristics： PE的一组属性。。。。</p>\n<p>极为重要的：</p>\n<h2 id=\"数据目录表\"><a href=\"#数据目录表\" class=\"headerlink\" title=\"数据目录表\"></a>数据目录表</h2><p>DataDirectory</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;打开PE文件后，第一个段就是DOS头部\nPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n&#x2F;&#x2F;pDos的e_lfanew字段可以指向NT头的空间，使用NT头接收\nPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)pDos-&gt;e_lfanew;\n&#x2F;&#x2F;NT头结构体的第三个参数就是指向扩展头\n\tPIMAGE_OPTIONAL_HEADER pOption &#x3D;  (PIMAGE_OPTIONAL_HEADER)&amp;pNt-&gt;OptionalHeader;\n&#x2F;&#x2F;扩展头最后一个参数就是数据目录表\nPIMAGE_DATA_DIRECTORY pDataDir &#x3D; pOption-&gt;DataDirectory;</code></pre>\n\n<p>描述了PE文件中16个非常重要的数据块的大小和位置。</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/mdfMOCQ8.png\" alt=\"5.png\" title=\"5.png\" />\n\n<h3 id=\"导出表\"><a href=\"#导出表\" class=\"headerlink\" title=\"导出表\"></a>导出表</h3><h4 id=\"什么是导出\"><a href=\"#什么是导出\" class=\"headerlink\" title=\"什么是导出\"></a>什么是导出</h4><p>提供函数给其他模块使用的一种行为</p>\n<h4 id=\"怎么导出\"><a href=\"#怎么导出\" class=\"headerlink\" title=\"怎么导出\"></a>怎么导出</h4><p>方法1：声明导出</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#pragma once\nextern &quot;C&quot; _declspec(dllexport) void Fun1();\nextern &quot;C&quot; _declspec(dllexport) void Fun2();</code></pre>\n\n<p>方法2：def文件导出</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">EXPORTS \nFun3 @1 \nFun4 @2 NONAME</code></pre>\n\n<p>注意：NONAME 是只导出序号，没有名字</p>\n<p>导出表的作用是什么? 没有它exe能运行吗?</p>\n<p>用以记录本模块能够给其他模块提供的函数的信息。</p>\n<p>函数名 函数地址 函数的序号</p>\n<p>程序运行的时候，会检查主模块的导入表，看用了哪些其他模块，就会将此模块加载到进程空间中。加载进来之后，分析INT（IAT）得到函数名称，用这个名称去导出表中找到函数地址的RVA，RVA+模块基址，就是真正的函数地址，将此函数地址填充到IAT中，从而完成加载后的IAT功能。</p>\n<p>一个PE文件，可以没有导出表的，比如exe文件，一般都没有。</p>\n<p>已知一个dll名,和一个dll导出函数的名字, 如何得到这个函数名的地址?</p>\n<p>得到DLL的导出表，然后在函数名称表中找函数名，如果找到了，由于序号表和名称表位置是一一对应的，就会得到序号表的下标，然后就将序号当成地址表的下标，从而得到地址。</p>\n<p>GetProcAddress();</p>\n<p>怎么才能知道一个exe都使用了哪些API?</p>\n<p>分析exe的导入表即可，其中记录了模块名和函数名。</p>\n<p>如何判断导入函数是以序号导入或是以名称导入?</p>\n<p>IMAGE_THUNK_DATA32这个结构体，他的最高位是1的话，那么就只有序号，如果最高位是0的话，那么久有序号，也有名称。</p>\n<p>怎么才知道导出函数是仅以序号导出还是以名称导出?</p>\n<p>对于一个导出函数而言，他的地址表的下标，就是此函数的序号，如果这个序号，在序号表中，没有记录，那么他就是一个虚序号，也就是没有名称，只有序号。</p>\n<h4 id=\"怎么找到一个PE文件的导出信息\"><a href=\"#怎么找到一个PE文件的导出信息\" class=\"headerlink\" title=\"怎么找到一个PE文件的导出信息\"></a>怎么找到一个PE文件的导出信息</h4><p>通过数据目录表的第0项：</p>\n<h4 id=\"手工分析过程：\"><a href=\"#手工分析过程：\" class=\"headerlink\" title=\"手工分析过程：\"></a>手工分析过程：</h4><img src=\"https://img1.imgtp.com/2022/12/29/g6agubP8.png\" alt=\"6.png\" title=\"6.png\" />\n\n<h5 id=\"获得信息：\"><a href=\"#获得信息：\" class=\"headerlink\" title=\"获得信息：\"></a>获得信息：</h5><p>导出表的RVA：00018D90 ——&gt;FOA： 7590 (FOA&#x3D; RVA - RVA区段+ FOA区段)</p>\n<p>备注：</p>\n<p> FOA:文件的偏移位置</p>\n<p> RVA：相对虚拟地址</p>\n<p> RVA区段：该段段首地址</p>\n<p> FOA区段：文件偏移的段首地址</p>\n<p>SIZE：5F21</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/os6hDixL.png\" alt=\"7.png\" title=\"7.png\" />\n\n<p>模块名称在12个字节后的四个字节中，也就是0x0001DBEA</p>\n<p>Base:00 00 00 01 索引基数</p>\n<p>NumberOfFunctions:00 00 13 88 导出地址表中成员个数</p>\n<p>NumberOfNames:00 00 00 03</p>\n<p>AddressOfFunctions(rva):00 01 8D B8 导出地址表（EAT）</p>\n<p>AddressOfNames(rva):00 01 DB D8 导出名称表（ENT）</p>\n<p>AddressOfNameOrdinals;：0x1DBE4 指向导出序号表</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef struct _IMAGE_EXPORT_DIRECTORY &#123;\n    DWORD  Characteristics;\t   &#x2F;&#x2F; (1) 保留，恒为0x00000000\n    DWORD  TimeDateStamp;\t   &#x2F;&#x2F; (2) 时间戳\n    WORD   MajorVersion;\t   &#x2F;&#x2F; (3) 主版本号，一般不赋值\n    WORD   MinorVersion;\t   &#x2F;&#x2F; (4) 子版本号，一般不赋值\n    DWORD  Name;\t\t   &#x2F;&#x2F; (5) 模块名称*\n    DWORD  Base;\t\t   &#x2F;&#x2F; (6) 索引基数*\n    DWORD  NumberOfFunctions;  &#x2F;&#x2F; (7) 导出地址表中成员个数*\n    DWORD  NumberOfNames; \t   &#x2F;&#x2F; (8) 导出名称表中成员个数*\n    DWORD  AddressOfFunctions; &#x2F;&#x2F; (9) 导出地址表（EAT）*\n    DWORD  AddressOfNames;\t   &#x2F;&#x2F; (10) 导出名称表（ENT）*\n    DWORD  AddressOfNameOrdinals; &#x2F;&#x2F; (11) 指向导出序号表*\n&#125;IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY;</code></pre>\n\n<p>模块名称0x0001DBEA 转换RVA —FOA: C3EA</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/P70b8f0i.png\" alt=\"8.png\" title=\"8.png\" />\n\n<p>找到dll.dll</p>\n<p>地址表成员个数为1388转换成字节：1388h&#x3D;5000d 十六进制转换为十进制</p>\n<p> 1388*4&#x3D;4E20 十六进制数乘4</p>\n<p> 5000*4&#x3D;20000 十进制数乘4</p>\n<p>我们从地址表：0x 18DB8开始找，由于18DB8是RVA，这里需要转换FOA:75B8</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/uAvpx6Wj.png\" alt=\"9.png\" title=\"9.png\" />\n\n<p>AddressOfNameOrdinals;：1DBE4 指向导出序号表 转换FOA:C3E4</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/s0usBvHI.png\" alt=\"10.png\" title=\"10.png\" />\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;Windows.h&gt;\n#define PATH L&quot;C:\\\\Users\\\\SouLinker\\\\Desktop\\\\dll.dll&quot;\n&#x2F;&#x2F; 判断是不是PE文件\n\n\nDWORD RvaToFoa(char* lpImage, DWORD dwRva);\nBOOL IsPE_File(char* lpImage);\nvoid AnalyzeExportsTabel(char* lpImage);\nint main()\n&#123;\n\t&#x2F;&#x2F;1 打开文件\n\tHANDLE hFile &#x3D; CreateFile(\n\t\tPATH,\n\t\tGENERIC_ALL,\n\t\tNULL,\n\t\tNULL,\n\t\tOPEN_EXISTING,\n\t\tFILE_ATTRIBUTE_NORMAL,\n\t\tNULL\n\t);\n\t&#x2F;&#x2F;2 获取文件大小\n\tDWORD dwFileSize &#x3D; GetFileSize(hFile, NULL);\n\t&#x2F;&#x2F;3 申请空间并初始化\n\tchar* buf &#x3D; new char[dwFileSize] &#123;0&#125;;\n\t&#x2F;&#x2F;4 读取文件\n\tDWORD dwRealSize &#x3D; 0;\n\tReadFile(hFile, buf, dwFileSize, &amp;dwRealSize, NULL);\n\t&#x2F;&#x2F;5 判断是不是PE文件\n\tif (IsPE_File(buf) &#x3D;&#x3D; TRUE)\n\t&#123;\n\t\t&#x2F;&#x2F;printf(&quot;这是一个PE文件&quot;);\n\t\tAnalyzeExportsTabel(buf);\n\t&#125;\n\telse\n\t&#123;\n\t\tprintf(&quot;这不是一个PE文件&quot;);\n\t&#125;\n\tdelete[]buf;\n\tbuf &#x3D; nullptr;\n\treturn 0;\n&#125;\n\nDWORD RvaToFoa(char* lpImage, DWORD dwRva)\n&#123;\n\t&#x2F;&#x2F;1 获取区段表的起始位置\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n\tPIMAGE_SECTION_HEADER pHeader &#x3D; IMAGE_FIRST_SECTION(pNt);\n\n\tif (dwRva &lt; pNt-&gt;OptionalHeader.SizeOfHeaders)\n\t&#123;\n\t\treturn dwRva;\n\t&#125;\n\t&#x2F;&#x2F;2 循环判断RVA落在了哪个区段中\n\tfor (int i &#x3D; 0; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)\n\t&#123;\n\t\tDWORD dwSectionRva &#x3D; pHeader[i].VirtualAddress;\n\t\tDWORD dwSectionEndRva &#x3D; dwSectionRva + pHeader[i].SizeOfRawData;\n\t\tDWORD dwSectionFOA &#x3D; pHeader[i].PointerToRawData;\n\t\tif (dwRva &gt;&#x3D; dwSectionRva &amp;&amp; dwRva &lt;&#x3D; dwSectionEndRva)\n\t\t&#123;\n\t\t\tpHeader[i].VirtualAddress;\n\t\t\tDWORD dwFOA &#x3D; dwRva - dwSectionRva + dwSectionFOA;\n\t\t\treturn dwFOA;\n\t\t&#125;\n\t&#125;\n\treturn -1;\n&#125;\nBOOL IsPE_File(char* lpImage)\n&#123;\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tif (pDos-&gt;e_magic !&#x3D; IMAGE_DOS_SIGNATURE)\n\t&#123;\n\t\treturn FALSE;\n\t&#125;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n\n\tif (pNt-&gt;Signature !&#x3D; IMAGE_NT_SIGNATURE)\n\t&#123;\n\t\treturn FALSE;\n\t&#125;\n\treturn TRUE;\n&#125;\n\nvoid AnalyzeExportsTabel(char* lpImage)\n&#123;\n\t&#x2F;&#x2F;1 获取到导出表的结构\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n\t&#x2F;&#x2F;1 获取到导出表的数据目录结构\n\tPIMAGE_DATA_DIRECTORY pExportDir &#x3D;  &amp;pNt-&gt;OptionalHeader.DataDirectory[0];\n\t&#x2F;&#x2F;1 导出表的数据目录结构中，有导出表的RVA，咱们需要将其转换为FOA，才能在文件中使用\n\tDWORD dwExportFOA &#x3D; RvaToFoa(lpImage, pExportDir-&gt;VirtualAddress);\n\t&#x2F;&#x2F;1 已经得到了FOA，直接就能够找到导出表的结构\n\tPIMAGE_EXPORT_DIRECTORY pExport &#x3D; (PIMAGE_EXPORT_DIRECTORY)(lpImage + dwExportFOA);\n\t&#x2F;&#x2F;typedef struct _IMAGE_EXPORT_DIRECTORY &#123;\n\t&#x2F;&#x2F;\tDWORD   Characteristics;\n\t&#x2F;&#x2F;\tDWORD   TimeDateStamp;\n\t&#x2F;&#x2F;\tWORD    MajorVersion;\n\t&#x2F;&#x2F;\tWORD    MinorVersion;\n\t&#x2F;&#x2F;\tDWORD   Name;\n\t&#x2F;&#x2F;\tDWORD   Base;\n\t&#x2F;&#x2F;\tDWORD   NumberOfFunctions;\n\t&#x2F;&#x2F;\tDWORD   NumberOfNames;\n\t&#x2F;&#x2F;\tDWORD   AddressOfFunctions;     &#x2F;&#x2F; RVA from base of image\n\t&#x2F;&#x2F;\tDWORD   AddressOfNames;         &#x2F;&#x2F; RVA from base of image\n\t&#x2F;&#x2F;\tDWORD   AddressOfNameOrdinals;  &#x2F;&#x2F; RVA from base of image\n\t&#x2F;&#x2F;&#125; IMAGE_EXPORT_DIRECTORY, * PIMAGE_EXPORT_DIRECTORY;\n\tDWORD dwBase &#x3D; pExport-&gt;Base;\n\t&#x2F;&#x2F;2 得到地址表，名称表，序号表的 FOA\n\tDWORD EatFoa &#x3D; RvaToFoa(lpImage,pExport-&gt;AddressOfFunctions);\n\tDWORD EntFoa &#x3D; RvaToFoa(lpImage, pExport-&gt;AddressOfNames);\n\tDWORD EotFoa &#x3D; RvaToFoa(lpImage, pExport-&gt;AddressOfNameOrdinals);\n\t&#x2F;&#x2F;3 得到地址表，名称表，序号表在文件中的位置\n\tPDWORD  pEat&#x3D; (PDWORD)(lpImage + EatFoa);\n\tPDWORD  pEnt &#x3D; (PDWORD)(lpImage + EntFoa);\n\tPWORD pEot &#x3D; (PWORD)(lpImage + EotFoa);\n\t&#x2F;&#x2F;4 开始解析\n\tfor (int i &#x3D; 0; i &lt; pExport-&gt;NumberOfFunctions; i++)\n\t&#123;\n\t\t&#x2F;&#x2F;4.1 无效地址\n\t\tif (pEat[i] &#x3D;&#x3D; 0)\n\t\t&#123;\n\t\t\tcontinue;\n\t\t&#125;\n\t\t&#x2F;&#x2F;4.2 有效地址将下标放到序号表中去寻找\n\t\tint  j &#x3D; 0;\n\t\tint nSign &#x3D; FALSE;\n\t\tfor (; j &lt; pExport-&gt;NumberOfNames; j++)\n\t\t&#123;\n\t\t\tif (i &#x3D;&#x3D; pEot[j])\n\t\t\t&#123;\n\t\t\t\tnSign &#x3D; TRUE;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t\t&#x2F;&#x2F;4.2.1 找到了，就是有名字的函数\n\t\tif (nSign&#x3D;&#x3D; TRUE)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;名称表中，存储的是RVA，需要转为FOA\n\t\t\tDWORD dwFunNameFOA &#x3D;  RvaToFoa(lpImage, pEnt[j]);\n\t\t\tchar* pFunName &#x3D; lpImage + dwFunNameFOA;\n\t\t\tprintf(&quot;序号:%4x 地址:%x 名称:%s\\n&quot;, i+ dwBase, pEat[i], pFunName);\n\t\t&#125;\n\t\t&#x2F;&#x2F;4.2.2 没有找到，就是没有名字的函数，虚序号\n\t\telse\n\t\t&#123;\n\t\t\tprintf(&quot;序号:%4x 地址:%x 名称:NULL\\n&quot;, i + dwBase, pEat[i]);\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<h3 id=\"导入表\"><a href=\"#导入表\" class=\"headerlink\" title=\"导入表\"></a>导入表</h3><h4 id=\"什么是导入\"><a href=\"#什么是导入\" class=\"headerlink\" title=\"什么是导入\"></a>什么是导入</h4><p>当一个可执行文件使用到了其他模块中的函数的时候，就是导入行为。在PE文件中，有一个位置记录了此可执行文件 使用的所有其他模块的函数信息。这个位置就是导入表。</p>\n<p>导入表的作用是什么?</p>\n<p>在加载之前，导入表里面记录本模块所使用的哪些DLL中的哪些函数的名称信息。</p>\n<p>在加载之后，导入表能够记录所使用的函数的地址。供程序运行期间，找到所使用的函数。</p>\n<p>导入表结构体</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">C++\ntypedef struct _IMAGE_IMPORT_DESCRIPTOR &#123;\n    union &#123;\n        DWORD Characteristics; \n        DWORD OriginalFirstThunk;&#x2F;&#x2F;(1) 指向导入名称表(INT)的RAV*\n    &#125;;\n    DWORD   TimeDateStamp;\t&#x2F;&#x2F; (2) 时间标识\n    DWORD   ForwarderChain;\t&#x2F;&#x2F; (3) 转发链，如果不转发则此值为0\n    DWORD   Name;\t\t&#x2F;&#x2F; (4) 指向导入映像文件的名字*\n    DWORD   FirstThunk;\t&#x2F;&#x2F; (5) 指向导入地址表（IAT）的RAV*\n&#125; IMAGE_IMPORT_DESCRIPTOR;</code></pre>\n\n<p>OriginalFirstThunk与FirstThunk得到位置，也是一个结构体数组，定义如下：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef struct _IMAGE_THUNK_DATA32 &#123;\n    union &#123;\n        PBYTE  ForwarderString;\t                                          &#x2F;&#x2F; (1) 转发字符串的RAV\n        PDWORD Function;\t\t                &#x2F;&#x2F; (2) 被导入函数的地址\n        DWORD Ordinal;\t\t                &#x2F;&#x2F; (3) 被导入函数的序号\n        PIMAGE_IMPORT_BY_NAME  AddressOfData;    &#x2F;&#x2F; (4) 指向输入名称表\n&#125; u1;\n&#125; IMAGE_THUNK_DATA32;</code></pre>\n\n<ol>\n<li>当此结构体最高位为0的时候，且此时存储的是导入名称信息，PIMAGE_IMPORT_BY_NAME起作用</li>\n<li>当此结构体最高位为1的时候，且此时存储的是导入名称信息， DWORD Ordinal起作用</li>\n<li>当此结构体存储的是导入地址信息的时候，PDWORD Function起作用</li>\n</ol>\n<h4 id=\"手工解析\"><a href=\"#手工解析\" class=\"headerlink\" title=\"手工解析\"></a>手工解析</h4><p>数据目录表的第1项，就是导入表信息：</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/9fFfj1Tg.png\" alt=\"11.png\" title=\"11.png\" />\n\n<p>RVA：19CE90 ———》 转为FOA： B890</p>\n<p>SIZE：0168</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/Ep4MHHQ2.png\" alt=\"12.png\" title=\"12.png\" />\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef struct _IMAGE_IMPORT_DESCRIPTOR &#123;\n    union &#123;\n        DWORD Characteristics; \n        DWORD OriginalFirstThunk;&#x2F;&#x2F;(1) 指向导入名称表(INT)的RAV*\n    &#125;;\n    DWORD   TimeDateStamp;\t&#x2F;&#x2F; (2) 时间标识\n    DWORD   ForwarderChain;\t&#x2F;&#x2F; (3) 转发链，如果不转发则此值为0\n    DWORD   Name;\t\t&#x2F;&#x2F; (4) 指向导入映像文件的名字*\n    DWORD   FirstThunk;\t&#x2F;&#x2F; (5) 指向导入地址表（IAT）的RAV*\n&#125; IMAGE_IMPORT_DESCRIPTOR;</code></pre>\n\n<p>Name: 0019E460 —–&gt; 19CE60</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/vt9Ry6eK.png\" alt=\"13.png\" title=\"13.png\" />\n\n<p>OriginalFirstThunk: 0019D1CC —–&gt;19BBCC (INT)</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/X6hS4ARi.png\" alt=\"14.png\" title=\"14.png\" />\n\n<p>irstThunk: 001504D4 —–&gt; 14EED4（IAT）</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/yrrM8owN.png\" alt=\"15.png\" title=\"15.png\" />\n\n<p>加载之后，INT中的内容还是原来的内容</p>\n<p>在OD中，加载之后，IAT里面，存储的已经是各个API的地址了。</p>\n<h4 id=\"测试代码\"><a href=\"#测试代码\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F; 02_解析导入表.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。\n&#x2F;&#x2F;\n\n#include &lt;iostream&gt;\n#include &lt;Windows.h&gt;\n#define PATH L&quot;C:\\\\Users\\\\hugan\\\\Desktop\\\\FileCleaner2.0.exe&quot;\n&#x2F;&#x2F; 判断是不是PE文件\n\n\nDWORD RvaToFoa(char* lpImage, DWORD dwRva);\nBOOL IsPE_File(char* lpImage);\nvoid AnalyzeImportTabel(char* lpImage, bool bAnalyzeInt);\nint main()\n&#123;\n\t&#x2F;&#x2F;1 打开文件\n\tHANDLE hFile &#x3D; CreateFile(\n\t\tPATH,\n\t\tGENERIC_ALL,\n\t\tNULL,\n\t\tNULL,\n\t\tOPEN_EXISTING,\n\t\tFILE_ATTRIBUTE_NORMAL,\n\t\tNULL\n\t);\n\t&#x2F;&#x2F;2 获取文件大小\n\tDWORD dwFileSize &#x3D; GetFileSize(hFile, NULL);\n\t&#x2F;&#x2F;3 申请空间并初始化\n\tchar* buf &#x3D; new char[dwFileSize] &#123;0&#125;;\n\t&#x2F;&#x2F;4 读取文件\n\tDWORD dwRealSize &#x3D; 0;\n\tReadFile(hFile, buf, dwFileSize, &amp;dwRealSize, NULL);\n\t&#x2F;&#x2F;5 判断是不是PE文件\n\tif (IsPE_File(buf) &#x3D;&#x3D; TRUE)\n\t&#123;\n\t\t&#x2F;&#x2F;printf(&quot;这是一个PE文件&quot;);\n\t\tAnalyzeImportTabel(buf,true);\n\t&#125;\n\telse\n\t&#123;\n\t\tprintf(&quot;这不是一个PE文件&quot;);\n\t&#125;\n\tdelete[]buf;\n\tbuf &#x3D; nullptr;\n\treturn 0;\n&#125;\n\nDWORD RvaToFoa(char* lpImage, DWORD dwRva)\n&#123;\n\t&#x2F;&#x2F;1 获取区段表的起始位置\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n\tPIMAGE_SECTION_HEADER pHeader &#x3D; IMAGE_FIRST_SECTION(pNt);\n\n\tif (dwRva &lt; pNt-&gt;OptionalHeader.SizeOfHeaders)\n\t&#123;\n\t\treturn dwRva;\n\t&#125;\n\t&#x2F;&#x2F;2 循环判断RVA落在了哪个区段中\n\tfor (int i &#x3D; 0; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)\n\t&#123;\n\t\tDWORD dwSectionRva &#x3D; pHeader[i].VirtualAddress;\n\t\tDWORD dwSectionEndRva &#x3D; dwSectionRva + pHeader[i].SizeOfRawData;\n\t\tDWORD dwSectionFOA &#x3D; pHeader[i].PointerToRawData;\n\t\tif (dwRva &gt;&#x3D; dwSectionRva &amp;&amp; dwRva &lt;&#x3D; dwSectionEndRva)\n\t\t&#123;\n\t\t\tpHeader[i].VirtualAddress;\n\t\t\tDWORD dwFOA &#x3D; dwRva - dwSectionRva + dwSectionFOA;\n\t\t\treturn dwFOA;\n\t\t&#125;\n\t&#125;\n\treturn -1;\n&#125;\nBOOL IsPE_File(char* lpImage)\n&#123;\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tif (pDos-&gt;e_magic !&#x3D; IMAGE_DOS_SIGNATURE)\n\t&#123;\n\t\treturn FALSE;\n\t&#125;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n\n\tif (pNt-&gt;Signature !&#x3D; IMAGE_NT_SIGNATURE)\n\t&#123;\n\t\treturn FALSE;\n\t&#125;\n\treturn TRUE;\n&#125;\n\nvoid AnalyzeImportTabel(char* lpImage,bool bAnalyzeInt)\n&#123;\n\t&#x2F;&#x2F;1 获取到导入表的结构\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n\t&#x2F;&#x2F;1 获取到导入表的数据目录结构\n\tPIMAGE_DATA_DIRECTORY dwImportDir &#x3D; &amp;pNt-&gt;OptionalHeader.DataDirectory[1];\n\t&#x2F;&#x2F;1 导入表的数据目录结构中，有导出表的RVA，咱们需要将其转换为FOA，才能在文件中使用\n\tDWORD dwImportFOA &#x3D; RvaToFoa(lpImage, dwImportDir-&gt;VirtualAddress);\n\t&#x2F;&#x2F;1 已经得到了FOA，直接就能够找到导出表的结构\n\tPIMAGE_IMPORT_DESCRIPTOR pImportTable &#x3D; (PIMAGE_IMPORT_DESCRIPTOR)(lpImage + dwImportFOA);\n\t\n\t&#x2F;&#x2F;2 开始解析\n\twhile (pImportTable-&gt;Name!&#x3D;0)\n\t&#123;\n\t\t&#x2F;&#x2F;2.1 先解析DLL的名字\n\t\t DWORD dwNameFoa &#x3D;  RvaToFoa(lpImage,pImportTable-&gt;Name);\n\t\t char* pDllName &#x3D; (char*)(dwNameFoa + lpImage);\n\t\t printf(&quot;DllName:%s\\n&quot;, pDllName);\n\n\t\t &#x2F;&#x2F;2.2 解析函数名字，选择用什么去解析\n\t\t PIMAGE_THUNK_DATA32 pNameTable &#x3D; NULL;\n\t\tif (bAnalyzeInt &#x3D;&#x3D; true)\n\t\t&#123;\n\t\t\tDWORD Foa  &#x3D; RvaToFoa(lpImage, pImportTable-&gt;OriginalFirstThunk);\n\t\t\tpNameTable &#x3D; (PIMAGE_THUNK_DATA32)(lpImage + Foa);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tDWORD Foa &#x3D; RvaToFoa(lpImage, pImportTable-&gt;FirstThunk);\n\t\t\tpNameTable &#x3D; (PIMAGE_THUNK_DATA32)(lpImage + Foa);\n\t\t&#125;\n\t\t&#x2F;&#x2F;2.3 开始解析名字\n\t\twhile (pNameTable-&gt;u1.Ordinal!&#x3D;0)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;2.3.1 判断最高位是不是1\n\t\t\tif (IMAGE_SNAP_BY_ORDINAL32(pNameTable-&gt;u1.Ordinal)&#x3D;&#x3D;1)\n\t\t\t&#123;\n\t\t\t\t&#x2F;&#x2F;只有序号\n\t\t\t\tprintf(&quot;  序号:%x,名称:NULL\\n&quot;, pNameTable-&gt;u1.Ordinal&amp;0x7FFFFFFF);\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\t&#x2F;&#x2F;既有名字，又有序号\n\t\t\t\tDWORD dwNameFoa &#x3D; RvaToFoa(lpImage, pNameTable-&gt;u1.AddressOfData);\n\t\t\t\tPIMAGE_IMPORT_BY_NAME pName  &#x3D; (PIMAGE_IMPORT_BY_NAME)(dwNameFoa + lpImage);\n\t\t\t\tprintf(&quot;  序号:%x,名称:%s\\n&quot;, pName-&gt;Hint,pName-&gt;Name);\n\t\t\t&#125;\n\t\t\tpNameTable++;\n\t\t&#125;\n\t\tprintf(&quot;----------------------------\\n&quot;);\n\t\tpImportTable++;\n\t&#125;\n&#125;</code></pre>\n\n<h3 id=\"重定位表\"><a href=\"#重定位表\" class=\"headerlink\" title=\"重定位表\"></a>重定位表</h3><h4 id=\"什么叫做重定位\"><a href=\"#什么叫做重定位\" class=\"headerlink\" title=\"什么叫做重定位\"></a>什么叫做重定位</h4><p>一般情况下，exe的默认加载基址是0x0040 0000</p>\n<p>会有一些代码，是这样的：</p>\n<p>lea eax, ds:[0x0040 1100]</p>\n<p>push eax</p>\n<p>call printf</p>\n<p>但是目前来看，几乎都不会加载到默认基址上。</p>\n<p>比如说，exe加载到0x0050 0000上，那么以上的代码还对么？？</p>\n<p>不对了，怎么才能对呢？？</p>\n<p>lea eax, ds:[0x0050 1100]</p>\n<p>push eax</p>\n<p>call printf</p>\n<p>这样就对了。</p>\n<p>由于一个模块加载到什么位置，几乎是不确定的，所以每次程序运行，都需要将使用了VA的地方进行一次修改。这个修改的过程就称之为重定位。</p>\n<p>有一个区域就记录着，程序中的哪些位置使用了VA。这个区域就叫做重定位表。</p>\n<p>为什么模块不加载到默认基址上？？</p>\n<ol>\n<li>对于dll来说，他默认基址上经常已经被别的模块使用了。</li>\n<li>对于exe来说，每次都加载到默认基址，是一个危险的行为。数据和代码的地址每次都是固定的，就很危险。对于exe来说，就有一个随机基址的功能，使得每次运行，基址都不一样。</li>\n</ol>\n<h4 id=\"手工解析重定位\"><a href=\"#手工解析重定位\" class=\"headerlink\" title=\"手工解析重定位\"></a>手工解析重定位</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef struct _IMAGE_BASE_RELOCATION &#123;\n    DWORD   VirtualAddress;\t&#x2F;&#x2F; (1) 需重定位数据的起始RVA\n    DWORD   SizeOfBlock;\t&#x2F;&#x2F; (2) 本结构与TypeOffset总大小\n&#x2F;&#x2F;  WORD    TypeOffset[1];\t&#x2F;&#x2F; (3) 原则上不属于本结构\n&#125; IMAGE_BASE_RELOCATION;\ntypedef  IMAGE_BASE_RELOCATION UNALIGNED IMAGE_BASE_RELOCATION;</code></pre>\n\n<img src=\"https://img1.imgtp.com/2022/12/29/qQaLnAwn.png\" alt=\"16.png\" title=\"16.png\" />\n\n<p>VirtualAddress:0A9000 ——-&gt;FOA:76E00</p>\n<p>size:3ACC</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/MZQeXljO.png\" alt=\"17.png\" title=\"17.png\" />\n\n<p>VirtualAddress:031000</p>\n<p>SizeofBlock:30</p>\n<table>\n<thead>\n<tr>\n<th>数据</th>\n<th>偏移</th>\n<th>重定位位置</th>\n<th>FOA</th>\n<th>要重定位的数据</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>3A7F</td>\n<td>A7F</td>\n<td>031000+A7F</td>\n<td>2E7F</td>\n<td>004A4840</td>\n</tr>\n<tr>\n<td>3A85</td>\n<td>A85</td>\n<td>031000+A85</td>\n<td>2E85</td>\n<td>0048FC88</td>\n</tr>\n<tr>\n<td>3A92</td>\n<td>A92</td>\n<td>031000+A92</td>\n<td>2E92</td>\n<td>004A4844</td>\n</tr>\n</tbody></table>\n<p>咱们再OD中，去看RVA是031000+A7F的地址，发现确实是被重定位过的了。</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/M0Dpl3Hm.png\" alt=\"18.png\" title=\"18.png\" />\n\n<p>怎么重定位的呢？？</p>\n<p>原始VA - 默认基址 &#x3D; 新VA - 新基址</p>\n<p>验证：</p>\n<p>0x00D6 0000 - 0x0040 0000 + 004A4840 得到就是0xE04840</p>\n<h4 id=\"测试代码-1\"><a href=\"#测试代码-1\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;Windows.h&gt;\n#define PATH L&quot;C:\\\\Users\\\\hugan\\\\Desktop\\\\FileCleaner2.0.exe&quot;\n\n\n\nDWORD RvaToFoa(char* lpImage, DWORD dwRva);\nBOOL IsPE_File(char* lpImage);\nvoid AnalyzeReloc(char* lpImage);\nint main()\n&#123;\n\tsetlocale(LC_ALL, &quot;chs&quot;);\n\t&#x2F;&#x2F;1 打开文件\n\tHANDLE hFile &#x3D; CreateFile(\n\t\tPATH,\n\t\tGENERIC_ALL,\n\t\tNULL,\n\t\tNULL,\n\t\tOPEN_EXISTING,\n\t\tFILE_ATTRIBUTE_NORMAL,\n\t\tNULL\n\t);\n\t&#x2F;&#x2F;2 获取文件大小\n\tDWORD dwFileSize &#x3D; GetFileSize(hFile, NULL);\n\t&#x2F;&#x2F;3 申请空间并初始化\n\tchar* buf &#x3D; new char[dwFileSize] &#123;0&#125;;\n\t&#x2F;&#x2F;4 读取文件\n\tDWORD dwRealSize &#x3D; 0;\n\tReadFile(hFile, buf, dwFileSize, &amp;dwRealSize, NULL);\n\t&#x2F;&#x2F;5 判断是不是PE文件\n\tif (IsPE_File(buf) &#x3D;&#x3D; TRUE)\n\t&#123;\n\t\t&#x2F;&#x2F;printf(&quot;这是一个PE文件&quot;);\n\t\tAnalyzeReloc(buf);\n\t&#125;\n\telse\n\t&#123;\n\t\tprintf(&quot;这不是一个PE文件&quot;);\n\t&#125;\n\tdelete[]buf;\n\tbuf &#x3D; nullptr;\n\treturn 0;\n&#125;\n\nDWORD RvaToFoa(char* lpImage, DWORD dwRva)\n&#123;\n\t&#x2F;&#x2F;1 获取区段表的起始位置\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n\tPIMAGE_SECTION_HEADER pHeader &#x3D; IMAGE_FIRST_SECTION(pNt);\n\n\tif (dwRva &lt; pNt-&gt;OptionalHeader.SizeOfHeaders)\n\t&#123;\n\t\treturn dwRva;\n\t&#125;\n\t&#x2F;&#x2F;2 循环判断RVA落在了哪个区段中\n\tfor (int i &#x3D; 0; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)\n\t&#123;\n\t\tDWORD dwSectionRva &#x3D; pHeader[i].VirtualAddress;\n\t\tDWORD dwSectionEndRva &#x3D; dwSectionRva + pHeader[i].SizeOfRawData;\n\t\tDWORD dwSectionFOA &#x3D; pHeader[i].PointerToRawData;\n\t\tif (dwRva &gt;&#x3D; dwSectionRva &amp;&amp; dwRva &lt; dwSectionEndRva)\n\t\t&#123;\n\t\t\tpHeader[i].VirtualAddress;\n\t\t\tDWORD dwFOA &#x3D; dwRva - dwSectionRva + dwSectionFOA;\n\t\t\treturn dwFOA;\n\t\t&#125;\n\t&#125;\n\treturn -1;\n&#125;\nBOOL IsPE_File(char* lpImage)\n&#123;\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tif (pDos-&gt;e_magic !&#x3D; IMAGE_DOS_SIGNATURE)\n\t&#123;\n\t\treturn FALSE;\n\t&#125;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n\n\tif (pNt-&gt;Signature !&#x3D; IMAGE_NT_SIGNATURE)\n\t&#123;\n\t\treturn FALSE;\n\t&#125;\n\treturn TRUE;\n&#125;\nstruct TYPEOFFSET &#123;\n\tWORD OFFSET : 12;\n\tWORD TYPE : 4;\n&#125;;\nvoid AnalyzeReloc(char* lpImage)\n&#123;\n\t&#x2F;&#x2F;1. 找到重定位的结构体\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n\tPIMAGE_OPTIONAL_HEADER pOption &#x3D; &amp;pNt-&gt;OptionalHeader;\n\t&#x2F;&#x2F;1. 得到了重定位的数据目录\n\tPIMAGE_DATA_DIRECTORY pRelocDir &#x3D; &amp;pOption-&gt;DataDirectory[5];\n\n\t&#x2F;&#x2F;2. 得到重定位表\n\tPIMAGE_BASE_RELOCATION pReloc &#x3D; \n\t\t(PIMAGE_BASE_RELOCATION)\n\t(RvaToFoa(lpImage, pRelocDir-&gt;VirtualAddress)+ lpImage);\n\t&#x2F;&#x2F;3. 开始解析重定位\n\twhile (pReloc-&gt;SizeOfBlock!&#x3D;0)\n\t&#123;\n\t\t&#x2F;&#x2F;得到描述每一个位置偏移的数组\n\t\tTYPEOFFSET* typeoffset &#x3D; (TYPEOFFSET*)(pReloc + 1);\n\t\tDWORD dwCount &#x3D; (pReloc-&gt;SizeOfBlock - 8) &#x2F; 2;\n\t\tDWORD dwBeginRva &#x3D;  pReloc-&gt;VirtualAddress;\n\t\tprintf(&quot;----------------------------------\\n&quot;);\n\t\tfor (int i &#x3D; 0; i &lt; dwCount; i++)\n\t\t&#123;\n\t\t\tif (typeoffset[i].TYPE&#x3D;&#x3D;3)\n\t\t\t&#123;\n\t\t\t\tDWORD dwRelocRva &#x3D; (dwBeginRva + typeoffset[i].OFFSET);\n\t\t\t\tprintf(&quot;要重定位的位置RVA：%p\\n&quot;, dwRelocRva);\n\t\t\t\tPDWORD pRelocData &#x3D; (PDWORD)(RvaToFoa(lpImage, dwRelocRva) + lpImage);\n\t\t\t\tprintf(&quot;要重定位的数据：%p\\n&quot;, *pRelocData);\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;类型是%d&quot;, typeoffset[i].TYPE);\n\t\t\t&#125;\n\n\t\t&#125;\n\t\tprintf(&quot;----------------------------------\\n&quot;);\n\t\t&#x2F;&#x2F;找到下一个0x1000字节重定位信息\n\t\tpReloc &#x3D; (PIMAGE_BASE_RELOCATION)((char*)pReloc + pReloc-&gt;SizeOfBlock);\n\t&#125;\n\n&#125;</code></pre>\n\n<h3 id=\"资源表\"><a href=\"#资源表\" class=\"headerlink\" title=\"资源表\"></a>资源表</h3><p>菜单，对话框，图标，光标，位图，工具栏…..他们称之为资源,资源就是PE文件在运行的时候需要使用到的一些通用数据。编译的时候，将他们独立保存在一个区域中。</p>\n<p>记录这些区域的一个结构，就是资源表了。</p>\n<h4 id=\"理解资源表\"><a href=\"#理解资源表\" class=\"headerlink\" title=\"理解资源表\"></a>理解资源表</h4><p>当咱们通过数据目录表找到资源表的时候，这个资源表分成了3层结构：</p>\n<p>第一层：一共有多少种资源</p>\n<p>第二层：这种资源有多少个</p>\n<p>第三层：这个资源的位置</p>\n<h4 id=\"手工解析PE文件\"><a href=\"#手工解析PE文件\" class=\"headerlink\" title=\"手工解析PE文件\"></a>手工解析PE文件</h4><h5 id=\"找到资源表\"><a href=\"#找到资源表\" class=\"headerlink\" title=\"找到资源表\"></a>找到资源表</h5><p>找到资源表的数据目录：</p>\n<p>RVA:1AF000———–&gt; FOA:1A5400</p>\n<p>SIZE:153058</p>\n<h5 id=\"分析第一层\"><a href=\"#分析第一层\" class=\"headerlink\" title=\"分析第一层\"></a>分析第一层</h5><img src=\"https://img1.imgtp.com/2022/12/29/iHA0iwgu.png\" alt=\"19.png\" title=\"19.png\" />\n\n<p><strong>NumberOfNamedEntries：0x2</strong></p>\n<p><strong>NumberOfIdEntries：0xC</strong></p>\n<p>代表着后面有14个下面的结构体：</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY &#123;\n    union &#123;\n        struct &#123;\n            DWORD NameOffset   :31;\t&#x2F;&#x2F; (1) 资源名偏移\n            DWORD NameIsString:1;\t&#x2F;&#x2F; (2) 资源名为字符串\n        &#125;;\n        DWORD   Name;\t\t&#x2F;&#x2F; (3) 资源&#x2F;语言类型\n        WORD    Id;\t\t&#x2F;&#x2F; (4) 资源数字ID\n    &#125;;\n    union &#123;\n        DWORD   OffsetToData;\t&#x2F;&#x2F; (5) 数据偏移地址\n        struct &#123;\n            DWORD   OffsetToDirectory:31;&#x2F;&#x2F; (6) 子目录偏移地址\n            DWORD   DataIsDirectory   :1;&#x2F;&#x2F; (7) 数据为目录\n        &#125;;\n    &#125;;\n&#125;IMAGE_RESOURCE_DIRECTORY_ENTRY,*PIMAGE_RESOURCE_DIRECTORY_ENTRY;</code></pre>\n\n<p>第一个资源的信息：</p>\n<p>Id：0x80008CC8 最高位是1，所以是以字符串为标识所以NameOffset：8CC8 这是一个相对于资源表起始位置的偏移</p>\n<p>他不是RVA</p>\n<p> 1A5400+8CC8 &#x3D; 1AE0C8</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/NSjuPUko.png\" alt=\"20.png\" title=\"20.png\" />\n\n<p>OffsetToData：0x80 00 00 80 最高位为1，所以下一层是目录</p>\n<p>OffsetToDirectory：80 这是一个相对于资源表起始位置的偏移</p>\n<p> 他不是RVA</p>\n<p>1A5400+80 &#x3D; 1A5480</p>\n<h5 id=\"这个就是第二层的位置\"><a href=\"#这个就是第二层的位置\" class=\"headerlink\" title=\"这个就是第二层的位置\"></a>这个就是第二层的位置</h5><img src=\"https://img1.imgtp.com/2022/12/29/1VgkW1xT.png\" alt=\"21.png\" title=\"21.png\" />\n\n<p>Id：0x800095E0</p>\n<p>NameOffset：95E0</p>\n<p>1A5400+95E0 &#x3D; 1AE9E0</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/QdBj4Boc.png\" alt=\"22.png\" title=\"22.png\" />\n\n<p>OffsetToData：0x80001890</p>\n<p>OffsetToDirectory：1890</p>\n<p>1A5400+1890 &#x3D; 1A6C90</p>\n<h5 id=\"这个就是第三层的位置了\"><a href=\"#这个就是第三层的位置了\" class=\"headerlink\" title=\"这个就是第三层的位置了\"></a>这个就是第三层的位置了</h5><img src=\"https://img1.imgtp.com/2022/12/29/aNIpqz0S.png\" alt=\"23.png\" title=\"23.png\" />\n\n<p>OffsetToData：5F20</p>\n<p> 1A5400+5E20 &#x3D;1AB220</p>\n<p>和LordPE种解析出来的是一样的</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/A2nktIMM.png\" alt=\"24.png\" title=\"24.png\" />\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;iostream&gt;\n#include &lt;Windows.h&gt;\n#define PATH L&quot;C:\\\\Users\\\\SouLinker\\\\Desktop\\\\FileCleaner2.0.exe&quot;\n&#x2F;&#x2F; 判断是不是PE文件\n#include &lt;map&gt;\nusing std::map;\n\nmap&lt;int, const char*&gt; g_mapResourceInfo;\nmap&lt;const char*, const char*&gt; abc;\nvoid InitResourceInfo()\n&#123;\n\tg_mapResourceInfo[0x1] &#x3D; &quot;Cursor&quot;;\n\tg_mapResourceInfo[0x2] &#x3D; &quot;BitMap&quot;;\n\tg_mapResourceInfo[0x3] &#x3D; &quot;Icon&quot;;\n\tg_mapResourceInfo[0x4] &#x3D; &quot;Menu&quot;;\n\tg_mapResourceInfo[0x5] &#x3D; &quot;Dialog&quot;;\n\tg_mapResourceInfo[0x6] &#x3D; &quot;String Table&quot;;\n\tg_mapResourceInfo[0x7] &#x3D; &quot;Font Directory&quot;;\n\tg_mapResourceInfo[0x8] &#x3D; &quot;Font&quot;;\n\tg_mapResourceInfo[0x9] &#x3D; &quot;Accelerators&quot;;\n\tg_mapResourceInfo[0xA] &#x3D; &quot;UnFormatted&quot;;\n\tg_mapResourceInfo[0xB] &#x3D; &quot;Message Table&quot;;\n\tg_mapResourceInfo[0xC] &#x3D; &quot;Group Cursor&quot;;\n\tg_mapResourceInfo[0xE] &#x3D; &quot;Group Icon&quot;;\n\tg_mapResourceInfo[0x10] &#x3D; &quot;Version Information&quot;;\n&#125;\n\n\n\nDWORD RvaToFoa(char* lpImage, DWORD dwRva);\nBOOL IsPE_File(char* lpImage);\nvoid AnalyzeResource(char* lpImage);\nint main()\n&#123;\n\tsetlocale(LC_ALL, &quot;chs&quot;);\n\tInitResourceInfo();\n\t&#x2F;&#x2F;1 打开文件\n\tHANDLE hFile &#x3D; CreateFile(\n\t\tPATH,\n\t\tGENERIC_ALL,\n\t\tNULL,\n\t\tNULL,\n\t\tOPEN_EXISTING,\n\t\tFILE_ATTRIBUTE_NORMAL,\n\t\tNULL\n\t);\n\t&#x2F;&#x2F;2 获取文件大小\n\tDWORD dwFileSize &#x3D; GetFileSize(hFile, NULL);\n\t&#x2F;&#x2F;3 申请空间并初始化\n\tchar* buf &#x3D; new char[dwFileSize] &#123;0&#125;;\n\t&#x2F;&#x2F;4 读取文件\n\tDWORD dwRealSize &#x3D; 0;\n\tReadFile(hFile, buf, dwFileSize, &amp;dwRealSize, NULL);\n\t&#x2F;&#x2F;5 判断是不是PE文件\n\tif (IsPE_File(buf) &#x3D;&#x3D; TRUE)\n\t&#123;\n\t\t&#x2F;&#x2F;printf(&quot;这是一个PE文件&quot;);\n\t\tAnalyzeResource(buf);\n\t&#125;\n\telse\n\t&#123;\n\t\tprintf(&quot;这不是一个PE文件&quot;);\n\t&#125;\n\tdelete[]buf;\n\tbuf &#x3D; nullptr;\n\treturn 0;\n&#125;\n\nDWORD RvaToFoa(char* lpImage, DWORD dwRva)\n&#123;\n\t&#x2F;&#x2F;1 获取区段表的起始位置\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n\tPIMAGE_SECTION_HEADER pHeader &#x3D; IMAGE_FIRST_SECTION(pNt);\n\n\tif (dwRva &lt; pNt-&gt;OptionalHeader.SizeOfHeaders)\n\t&#123;\n\t\treturn dwRva;\n\t&#125;\n\t&#x2F;&#x2F;2 循环判断RVA落在了哪个区段中\n\tfor (int i &#x3D; 0; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)\n\t&#123;\n\t\tDWORD dwSectionRva &#x3D; pHeader[i].VirtualAddress;\n\t\tDWORD dwSectionEndRva &#x3D; dwSectionRva + pHeader[i].SizeOfRawData;\n\t\tDWORD dwSectionFOA &#x3D; pHeader[i].PointerToRawData;\n\t\tif (dwRva &gt;&#x3D; dwSectionRva &amp;&amp; dwRva &lt; dwSectionEndRva)\n\t\t&#123;\n\t\t\tpHeader[i].VirtualAddress;\n\t\t\tDWORD dwFOA &#x3D; dwRva - dwSectionRva + dwSectionFOA;\n\t\t\treturn dwFOA;\n\t\t&#125;\n\t&#125;\n\treturn -1;\n&#125;\nBOOL IsPE_File(char* lpImage)\n&#123;\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tif (pDos-&gt;e_magic !&#x3D; IMAGE_DOS_SIGNATURE)\n\t&#123;\n\t\treturn FALSE;\n\t&#125;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n\n\tif (pNt-&gt;Signature !&#x3D; IMAGE_NT_SIGNATURE)\n\t&#123;\n\t\treturn FALSE;\n\t&#125;\n\treturn TRUE;\n&#125;\n\nvoid AnalyzeResource(char* lpImage)\n&#123;\n\t&#x2F;&#x2F;1. 找到资源表的结构体\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n\tPIMAGE_OPTIONAL_HEADER pOption &#x3D;  &amp;pNt-&gt;OptionalHeader;\n\t&#x2F;&#x2F;1. 得到了资源表的数据目录\n\tPIMAGE_DATA_DIRECTORY pResourceDir&#x3D; &amp;pOption-&gt;DataDirectory[2];\n\n\t&#x2F;&#x2F;2. 得到资源表第一层的位置\n\tDWORD dwResourceFOA &#x3D;  RvaToFoa(lpImage, pResourceDir-&gt;VirtualAddress);\n\tPIMAGE_RESOURCE_DIRECTORY pFirstDir &#x3D;(PIMAGE_RESOURCE_DIRECTORY)(dwResourceFOA + lpImage);\n\tPIMAGE_RESOURCE_DIRECTORY_ENTRY pFirstRes &#x3D; (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pFirstDir + 1);\n\t&#x2F;&#x2F;3. 解析资源表\n\tDWORD dwFirstCount &#x3D; pFirstDir-&gt;NumberOfIdEntries + pFirstDir-&gt;NumberOfNamedEntries;\n\t&#x2F;&#x2F;3.1 解析第一层\n\tfor (int i &#x3D; 0; i &lt; dwFirstCount; i++)\n\t&#123;\n\t\t&#x2F;&#x2F;解析第一层的名称信息\n\t\tif (pFirstRes[i].NameIsString &#x3D;&#x3D; TRUE)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;以字符串作为标识\n\t\t\tPIMAGE_RESOURCE_DIR_STRING_U pNameInfo &#x3D; \n\t\t\t(PIMAGE_RESOURCE_DIR_STRING_U)(pFirstRes[i].NameOffset + (DWORD)pFirstDir);\n\t\t\tWCHAR* pName &#x3D; new WCHAR[pNameInfo-&gt;Length + 1]&#123;0&#125;;\n\t\t\t&#x2F;&#x2F;wcscpy_s(pName, pNameInfo-&gt;Length, pNameInfo-&gt;NameString);\n\t\t\tfor (int m &#x3D; 0; m &lt; pNameInfo-&gt;Length; m++)\n\t\t\t&#123;\n\t\t\t\tpName[m] &#x3D; pNameInfo-&gt;NameString[m];\n\t\t\t&#125;\n\t\t\twprintf(L&quot;资源种类标识:%s\\n&quot;, pName);\n\t\t&#125;\n\t\t&#x2F;&#x2F;以数字作为标识\n\t\telse\n\t\t&#123;\n\t\t\tif (g_mapResourceInfo.count(pFirstRes[i].Id) &#x3D;&#x3D; 1)\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;资源种类标识%s\\n&quot;, g_mapResourceInfo[pFirstRes[i].Id]);\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;资源种类标识%d\\n&quot;, pFirstRes[i].Id);\n\t\t\t&#125;\n\t\t\n\t\t&#125;\n\t\t&#x2F;&#x2F;解析第一层的位置信息，从而得到第二层\n\t\t\t\n\t\tif (pFirstRes[i].DataIsDirectory &#x3D;&#x3D; 1)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;根据偏移得到第二层的位置,以及数组\n\t\t\tPIMAGE_RESOURCE_DIRECTORY pSecondDir &#x3D;\n\t\t\t\t(PIMAGE_RESOURCE_DIRECTORY)(pFirstRes[i].OffsetToDirectory + (DWORD)pFirstDir);\n\t\t\tPIMAGE_RESOURCE_DIRECTORY_ENTRY pSecondRes &#x3D;\n\t\t\t\tPIMAGE_RESOURCE_DIRECTORY_ENTRY(pSecondDir + 1);\n\t\t\t\n\t\t\t\n\t\t\t&#x2F;&#x2F;第二层的资源个数\n\t\t\tDWORD dwSecondCount  &#x3D; \n\t\t\tpSecondDir-&gt;NumberOfIdEntries + pSecondDir-&gt;NumberOfNamedEntries;\n\t\t\tfor (int j &#x3D; 0; j &lt; dwSecondCount; j++)\n\t\t\t&#123;\n\t\t\t\t&#x2F;&#x2F;解析第二层的名称信息\n\t\t\t\tif (pSecondRes[j].NameIsString &#x3D;&#x3D; TRUE)\n\t\t\t\t&#123;\n\t\t\t\t\t&#x2F;&#x2F;以字符串作为标识\n\t\t\t\t\tPIMAGE_RESOURCE_DIR_STRING_U pNameInfo &#x3D;\n\t\t\t\t\t\t(PIMAGE_RESOURCE_DIR_STRING_U)(pSecondRes[j].NameOffset + (DWORD)pFirstDir);\n\t\t\t\t\tWCHAR* pName &#x3D; new WCHAR[pNameInfo-&gt;Length + 1]&#123; 0 &#125;;\n\t\t\t\t\t&#x2F;&#x2F;wcscpy_s(pName, pNameInfo-&gt;Length + 1, pNameInfo-&gt;NameString);\n\t\t\t\t\tfor (int m &#x3D; 0; m &lt; pNameInfo-&gt;Length; m++)\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tpName[m] &#x3D; pNameInfo-&gt;NameString[m];\n\t\t\t\t\t&#125;\n\t\t\t\t\twprintf(L&quot;   资源标识:%s\\n&quot;, pName);\n\t\t\t\t&#125;\n\t\t\t\telse\n\t\t\t\t&#123;\n\t\t\t\t\twprintf(L&quot;   资源标识:%d\\n&quot;, pSecondRes[j].Id);\n\t\t\t\t&#125;\n\t\t\t\t&#x2F;&#x2F;解析第二层的位置信息\n\t\t\t\tif (pSecondRes[j].DataIsDirectory &#x3D;&#x3D; TRUE)\n\t\t\t\t&#123;\n\t\t\t\t\t&#x2F;&#x2F;根据偏移得到第三层的位置,以及数组\n\t\t\t\t\tPIMAGE_RESOURCE_DIRECTORY pThirdDir &#x3D;\n\t\t\t\t\t\t(PIMAGE_RESOURCE_DIRECTORY)\n\t\t\t\t\t\t(pSecondRes[j].OffsetToDirectory+ (DWORD)pFirstDir);\n\t\t\t\t\tPIMAGE_RESOURCE_DIRECTORY_ENTRY pThirdRes &#x3D;\n\t\t\t\t\t(PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pThirdDir + 1);\n\n\t\t\t\t\t&#x2F;&#x2F;解析第三层，但是不需要循环了\n\t\t\t\t\tPIMAGE_RESOURCE_DATA_ENTRY pData &#x3D; \n\t\t\t\t\t(PIMAGE_RESOURCE_DATA_ENTRY)(pThirdRes-&gt;OffsetToData + (DWORD)pFirstDir);\n\t\t\t\t\t&#x2F;&#x2F;pData-&gt;OffsetToData 资源起始位置的RVA\n\t\t\t\t\t&#x2F;&#x2F;pData-&gt;Size  资源的大小\n\t\t\t\t\tprintf(&quot;            资源的起始RVA：%x  资源的大小：%x\\n&quot;, pData-&gt;OffsetToData, pData-&gt;Size);\n\t\t\t\t\t&#x2F;&#x2F;获取到资源的数据了，输出10个字节，用于对比\n\t\t\t\t\tunsigned char* pRes &#x3D; (unsigned char *)\n\t\t\t\t\t\t(RvaToFoa(lpImage, pData-&gt;OffsetToData) + lpImage);\n\t\t\t\t\tprintf(&quot;            &quot;);\n\t\t\t\t\tfor (size_t m&#x3D; 0; m &lt; 10; m++)\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tprintf(&quot;%x  &quot;, pRes[m]);\n\t\t\t\t\t&#125;\n\t\t\t\t\tprintf(&quot;\\n&quot;);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<h3 id=\"TLS表\"><a href=\"#TLS表\" class=\"headerlink\" title=\"TLS表\"></a>TLS表</h3><h4 id=\"简介-1\"><a href=\"#简介-1\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>线程局部存储：可以将TLS全局变量，在每一个线程中都创建一份，从而解决一定的线程同步问题。</p>\n<h4 id=\"测试代码-2\"><a href=\"#测试代码-2\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h4><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">C++\n&#x2F;&#x2F; 03_TLS.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。\n&#x2F;&#x2F;\n\n#include &lt;iostream&gt;\n#include &lt;Windows.h&gt;\n#pragma comment(linker, &quot;&#x2F;INCLUDE:__tls_used&quot;)\nint g_nNum1 &#x3D; 100;\n_declspec(thread) int g_nNum2 &#x3D; 200;&#x2F;&#x2F;TLS的全局变量\n\n&#x2F;&#x2F; TLS回调函数A\nvoid NTAPI t_TlsCallBack_A(PVOID DllHandle, DWORD Reason, PVOID Red) &#123;\n\tif (DLL_PROCESS_ATTACH &#x3D;&#x3D; Reason)\n\t&#123;\n\t\tprintf(&quot;i am a  mimidaima!\\r\\n&quot;);\n\t&#125;\n\tif (DLL_THREAD_DETACH &#x3D;&#x3D; Reason) &#x2F;&#x2F; 如果线程退出则打印信息\n\t\tprintf(&quot;t_TlsCallBack_A -&gt; ThreadDetach!\\r\\n&quot;);\n\treturn;\n&#125;\n&#x2F;&#x2F; TLS回调函数B\nvoid NTAPI t_TlsCallBack_B(PVOID DllHandle, DWORD Reason, PVOID Red) &#123;\n\tif (DLL_THREAD_DETACH &#x3D;&#x3D; Reason) &#x2F;&#x2F; 如果线程退出则打印信息\n\t\tprintf(&quot;t_TlsCallBack_B -&gt; ThreadDetach!\\r\\n&quot;);\n\treturn;\n&#125;\n\n&#x2F;*\n* 注册TLS回调函数，&quot;.CRT$XLB&quot;的含义是：\n* CRT表明使用C RunTime机制\n* X表示标识名随机\n* L表示TLS callback section\n* B其实也可以为B-Y的任意一个字母\n*&#x2F;\n#pragma data_seg(&quot;.CRT$XLB&quot;)\nPIMAGE_TLS_CALLBACK p_thread_callback[] &#x3D; &#123;\n\tt_TlsCallBack_A,\n\tt_TlsCallBack_B,\n\tNULL &#125;;\n#pragma data_seg()\n\nDWORD WINAPI t_ThreadFun(PVOID pParam) &#123;\n\t\n\tprintf(&quot;%p  &quot;, &amp;g_nNum1);\n\tprintf(&quot;%p\\n&quot;, &amp;g_nNum2);\n\treturn 0;\n&#125;\n\nint main()\n&#123;\n\tprintf(&quot;%p  &quot;, &amp;g_nNum1);\n\tprintf(&quot;%p\\n&quot;, &amp;g_nNum2);\n\tHANDLE hThread &#x3D; CreateThread(NULL, 0, t_ThreadFun, NULL, 0, 0);\n\tWaitForSingleObject(hThread, -1);\n\treturn 0;\n&#125;</code></pre>\n\n<h2 id=\"区段表\"><a href=\"#区段表\" class=\"headerlink\" title=\"区段表\"></a>区段表</h2><h3 id=\"结构体数组\"><a href=\"#结构体数组\" class=\"headerlink\" title=\"结构体数组\"></a>结构体数组</h3><p>数组的元素个数由文件头中的NumberOfSection决定。</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">C++\ntypedef struct _IMAGE_SECTION_HEADER &#123;\n    BYTE    Name[0x8];\t                       &#x2F;&#x2F; (1) 区段名\n    union &#123;\n            DWORD   PhysicalAddress; \n            DWORD   VirtualSize;                  &#x2F;&#x2F; (2) *区段大小\n &#125; Misc;\t\t\t\t\t\n    DWORD   VirtualAddress;\t\t&#x2F;&#x2F; (3)区段的RVA地址*\n    DWORD   SizeOfRawData;\t\t&#x2F;&#x2F; (4) 文件中的区段对齐大小*\n    DWORD   PointerToRawData;\t\t&#x2F;&#x2F; (5) 区段在文件中的偏移*\n    DWORD   PointerToRelocations;\t&#x2F;&#x2F; (6) 重定位的偏移（OBJ）\n    DWORD   PointerToLinenumbers;\t&#x2F;&#x2F; (7) 行号表的偏移（调试）\n    WORD    NumberOfRelocations;\t&#x2F;&#x2F; (8) 重定位项数量（OBJ）\n    WORD    NumberOfLinenumbers;\t&#x2F;&#x2F; (9) 行号表项数量\n    DWORD   Characteristics;\t\t&#x2F;&#x2F; (10) 区段的属性\n&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</code></pre>\n\n<h3 id=\"怎么找到区段表\"><a href=\"#怎么找到区段表\" class=\"headerlink\" title=\"怎么找到区段表\"></a>怎么找到区段表</h3><p>宏：IMAGE_FIRST_SECTION(NT头的地址)</p>\n<p>计算：NT头的地址+0x4+0x14+0xE0</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;打开PE文件后，第一个段就是DOS头部\nPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n&#x2F;&#x2F;pDos的e_lfanew字段可以指向NT头的空间，使用NT头接收\nPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)pDos-&gt;e_lfanew;\n&#x2F;&#x2F;使用IMAGE_FIRST_SECTION这个宏，传图NT头来获取区段表\nPIMAGE_SECTION_HEADER pHeader &#x3D; IMAGE_FIRST_SECTION(pNt);</code></pre>\n\n<h4 id=\"区段表中的一个元素描述的就是一个区段的信息\"><a href=\"#区段表中的一个元素描述的就是一个区段的信息\" class=\"headerlink\" title=\"区段表中的一个元素描述的就是一个区段的信息\"></a>区段表中的一个元素描述的就是一个区段的信息</h4><p>1 Name：区段名</p>\n<p>2 PointerToRawData 在文件中的位置 FOA</p>\n<p>3 SizeOfRawData在文件中的大小</p>\n<p>4 VirtualAddress在内存中的位置 RVA</p>\n<p>5 Misc.VirtualSize:在内存中的大小</p>\n<p>6 Characteristics:区段的属性：可读 可写 可执行。。。。</p>\n<h4 id=\"区段表中的以下四个字段保存的是什么？\"><a href=\"#区段表中的以下四个字段保存的是什么？\" class=\"headerlink\" title=\"区段表中的以下四个字段保存的是什么？\"></a>区段表中的以下四个字段保存的是什么？</h4><p>VirtualAddress： 区段起始位置的RVA</p>\n<p>PointerToRawData： 区段在文件中的起始偏移</p>\n<p>VirtualSize： 区段在内存中的大小（没有对齐）</p>\n<p>SizeOfRawData： 区段在文件中的大小（对齐过的）</p>\n<p>是否VirtualSize 一定会小于SizeOfRawData？</p>\n<p>不是的，有可能是这个区段在文件中没有数据，运行起来之后，才有数据。</p>\n<h3 id=\"测试代码-3\"><a href=\"#测试代码-3\" class=\"headerlink\" title=\"测试代码\"></a>测试代码</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">C++\n#include &lt;Windows.h&gt;\nvoid AnalyzeNTHeader(char* lpImage)\n&#123;\n\t&#x2F;&#x2F;1 找到NT头\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n    PIMAGE_FILE_HEADER pFileHeader &#x3D; &amp;pNt-&gt;FileHeader;\n    PIMAGE_OPTIONAL_HEADER pOption &#x3D; &amp;pNt-&gt;OptionalHeader;\n\t&#x2F;&#x2F;2 开始解析文件头\n\tprintf(&quot;运行平台:%x\\n&quot;,pFileHeader-&gt;Machine);\n\tprintf(&quot;区段数量:%x\\n&quot;, pFileHeader-&gt;NumberOfSections);\n\tprintf(&quot;扩展头大小:%x\\n&quot;, pFileHeader-&gt;SizeOfOptionalHeader);\n\tprintf(&quot;时间戳:%x\\n&quot;, pFileHeader-&gt;TimeDateStamp);\n\tprintf(&quot;属性:%x\\n&quot;, pFileHeader-&gt;Characteristics);\n\t&#x2F;&#x2F;3 解析扩展头\n\t&#x2F;&#x2F;。。。\n&#125;\nvoid AnalyzeSectionTable(char* lpImage)\n&#123;\n\t&#x2F;&#x2F;1 获取区段表的起始位置\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n\tPIMAGE_SECTION_HEADER pHeader &#x3D; IMAGE_FIRST_SECTION(pNt);\n\t&#x2F;&#x2F;2 解析\n\tfor (int  i &#x3D; 0; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)\n\t&#123;\n\t\tprintf(&quot;区段名：%s\\t&quot;, pHeader[i].Name);\n\t\tprintf(&quot;内存中大小：%X\\t&quot;, pHeader[i].Misc.VirtualSize);\n\t\tprintf(&quot;内存中RVA：%X\\t&quot;, pHeader[i].VirtualAddress);\n\t\tprintf(&quot;文件中大小：%X\\t&quot;, pHeader[i].SizeOfRawData);\n\t\tprintf(&quot;文件中FOA：%X\\t&quot;, pHeader[i].PointerToRawData);\n\t\tprintf(&quot;属性：%X\\t&quot;, pHeader[i].Characteristics);\n\t\tprintf(&quot;\\n&quot;);\n\t&#125;\n&#125;</code></pre>\n\n<h2 id=\"RVA和FOA之间的转换\"><a href=\"#RVA和FOA之间的转换\" class=\"headerlink\" title=\"RVA和FOA之间的转换\"></a>RVA和FOA之间的转换</h2><p>文件偏移（FOA或者Offset）： 某一个数据距离文件开头的偏移</p>\n<h3 id=\"RVA怎么转换成FOA\"><a href=\"#RVA怎么转换成FOA\" class=\"headerlink\" title=\"RVA怎么转换成FOA\"></a>RVA怎么转换成FOA</h3><p>RVA - RVA区段 &#x3D; FOA -FOA区段</p>\n<p>FOA &#x3D; RVA - RVA区段+FOA区段</p>\n<h3 id=\"一般情况下，PE文件的头部在文件中是多大？\"><a href=\"#一般情况下，PE文件的头部在文件中是多大？\" class=\"headerlink\" title=\"一般情况下，PE文件的头部在文件中是多大？\"></a>一般情况下，PE文件的头部在文件中是多大？</h3><p>0x400</p>\n<h3 id=\"PE文件的头部在内存中是多大\"><a href=\"#PE文件的头部在内存中是多大\" class=\"headerlink\" title=\"PE文件的头部在内存中是多大\"></a>PE文件的头部在内存中是多大</h3><p>0x1000</p>\n<p>RVA为0x600的时候，转为FOA 转不了，在文件中没有对应的位置</p>\n<p>虚拟地址（VA）：程序在运行的时候，是将PE文件加载到进程的内存空间中。进程的这块内存空间就称之为 虚拟内存空间 32位程序虚拟内存空间是以字节为单位的，每一个字节都有一个编号从0x0000 0000到0xFFFFFFFF之间。这些编号就是<strong>虚拟地址</strong>。</p>\n<p>相对虚拟地址（RVA）：PE文件不会占满整个虚拟内存空间，而是会占用一部分。那么就会有一个起始位置，这个起始位置也成为加载基址。PE文件中的数据相对于加载基址的偏移就是<strong>相对虚拟地址。</strong></p>\n<p><strong>如果系统加载PE文件的时候，是将PE文件原封不动的复制到了内存中，那么某一个数据的FOA和RVA就是相等的。</strong></p>\n<p><strong>但是现实情况并非如此，系统加载PE文件到内存的之后，PE文件是被扩展了的。</strong></p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">DWORD RvaToFoa(char* lpImage,DWORD dwRva)\n&#123;\n\t&#x2F;&#x2F;1 获取区段表的起始位置\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n\tPIMAGE_SECTION_HEADER pHeader &#x3D; IMAGE_FIRST_SECTION(pNt);\n\t\n\tif (dwRva&lt; pNt-&gt;OptionalHeader.SizeOfHeaders)\n\t&#123;\n\t\treturn dwRva;\n\t&#125;\n\t&#x2F;&#x2F;2 循环判断RVA落在了哪个区段中\n\tfor (int i &#x3D; 0; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)\n\t&#123;\n\t\tDWORD dwSectionRva &#x3D;  pHeader[i].VirtualAddress;\n\t\tDWORD dwSectionEndRva &#x3D; dwSectionRva + pHeader[i].SizeOfRawData;\n\t\tDWORD dwSectionFOA &#x3D; pHeader[i].PointerToRawData;\n\t\tif (dwRva&gt;&#x3D; dwSectionRva &amp;&amp;dwRva&lt;&#x3D; dwSectionEndRva)\n\t\t&#123;\n\t\t\tpHeader[i].VirtualAddress;\n\t\t\tDWORD dwFOA &#x3D; dwRva - dwSectionRva+ dwSectionFOA;\n\t\t\treturn dwFOA;\n\t\t&#125;\n\t&#125;\n\treturn -1;\n&#125;</code></pre>\n\n<h2 id=\"小功能的实现\"><a href=\"#小功能的实现\" class=\"headerlink\" title=\"小功能的实现\"></a>小功能的实现</h2><h3 id=\"位置计算\"><a href=\"#位置计算\" class=\"headerlink\" title=\"位置计算\"></a>位置计算</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;位置计算器按钮\nvoid CPEDlg::OnBnClickedButton2()\n&#123;\n\tUpdateData(TRUE);\n\tif (m_strEditTest1 !&#x3D; L&quot;&quot;)\n\t&#123;\n\t\tCMGpsCalcDlg* pPrcPopDg &#x3D; new CMGpsCalcDlg;\n\n\t\tpPrcPopDg-&gt;Create(IDD_DIALOG1, this);\n\t\tpPrcPopDg-&gt;ShowWindow(SW_SHOW);\n\t\tpPrcPopDg-&gt;GetPath(buf);\n\t&#125;\n\n&#125;\n\nvoid CMGpsCalcDlg::RvaToFoa()\n&#123;\n\tUpdateData(TRUE);\n\t\n\tCString svPid &#x3D; m_strEditRva.GetString();\n\tDWORD dwRva &#x3D; _tcstoul(svPid, NULL, 16);\n\t\n\t\n\t\n\t&#x2F;&#x2F;1 获取区段表的起始位置\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)buf;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + buf);\n\tPIMAGE_SECTION_HEADER pHeader &#x3D; IMAGE_FIRST_SECTION(pNt);\n\tPIMAGE_OPTIONAL_HEADER pOption &#x3D; &amp;pNt-&gt;OptionalHeader;\n\n\tif (dwRva &lt; pNt-&gt;OptionalHeader.SizeOfHeaders)\n\t&#123;\n\t\tCString cd;\n\t\tcd.Format(L&quot;%x&quot;, dwRva);\n\t\tm_strEditFoa.SetString(cd);\n\t\tUpdateData(FALSE);\n\t\treturn;\n\t&#125;\n\t&#x2F;&#x2F;2 循环判断RVA落在了哪个区段中\n\tfor (int i &#x3D; 0; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)\n\t&#123;\n\t\tDWORD dwSectionRva &#x3D; pHeader[i].VirtualAddress;\n\t\tDWORD dwSectionEndRva &#x3D; dwSectionRva + pHeader[i].SizeOfRawData;\n\t\tDWORD dwSectionFOA &#x3D; pHeader[i].PointerToRawData;\n\t\tif (dwRva &gt;&#x3D; dwSectionRva &amp;&amp; dwRva &lt;&#x3D; dwSectionEndRva)\n\t\t&#123;\n\t\t\tpHeader[i].VirtualAddress;\n\t\t\t\n\t\t\t&#x2F;&#x2F;FOA\t\t&#x3D; RVA   - RVA区段\t   + FOA区段\n\t\t\tDWORD dwFOA &#x3D; dwRva - dwSectionRva + dwSectionFOA;\n\t\t\tCString foa;\n\t\t\tfoa.Format(L&quot;%x&quot;,dwFOA);\n\t\t\tm_strEditFoa.SetString(foa);\n\n\t\t\t&#x2F;&#x2F;va虚拟地址&#x3D; InmageBase(加载基址) + RVA(相对虚拟地址)\n\t\t\tDWORD dwVA &#x3D; pOption-&gt;ImageBase + dwRva;\n\t\t\tCString va;\n\t\t\tva.Format(L&quot;%x&quot;, dwVA);\n\t\t\tm_strEditVa.SetString(va);\n\n\t\t\t&#x2F;&#x2F;区段名\n\t\t\tCString name;\n\t\t\tname.Format(L&quot;%S&quot;, pHeader[i].Name);\n\t\t\tm_strEditName.SetString(name);\n\n\t\t\tUpdateData(FALSE);\n\t\t\treturn;\n\t\t&#125;\n\t&#125;\n\tMessageBox(L&quot;不存在该地址&quot;);\n&#125;</code></pre>\n\n<h3 id=\"响应拖拽\"><a href=\"#响应拖拽\" class=\"headerlink\" title=\"响应拖拽\"></a>响应拖拽</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;响应文件拖拽\nvoid CPEDlg::OnDropFiles(HDROP hDropInfo)\n&#123;\n\n\t&#x2F;&#x2F; 存放文件路径\n\twchar_t filePath[MAX_PATH] &#x3D; &#123;&#125;;\n\n\t&#x2F;&#x2F; 获取拖拽文件的路径\n\tDragQueryFile(hDropInfo, 0, filePath, MAX_PATH);\n\n\t&#x2F;&#x2F; 更新变量\n\tm_strEditPath &#x3D; filePath;\n\tUpdateData(FALSE);\n\n\tCDialogEx::OnDropFiles(hDropInfo);\n&#125;</code></pre>\n\n<h3 id=\"时间换算\"><a href=\"#时间换算\" class=\"headerlink\" title=\"时间换算\"></a>时间换算</h3><pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">&#x2F;&#x2F;时间转换\nvoid CPEDlg::OnBnClickedButton3()\n&#123;\n\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)buf;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + buf);\n\tPIMAGE_FILE_HEADER pFileHeader &#x3D; &amp;pNt-&gt;FileHeader;&#x2F;&#x2F;NT头\n\t\n\tstruct tm* p;\n\n\ttime_t t &#x3D;pFileHeader-&gt;TimeDateStamp;\n\tp &#x3D; localtime(&amp;t);\n\tCString Time;\n\tTime.Format(L&quot;%d年%d月%d日%d时%d分%d秒&quot;, 1900 + p-&gt;tm_year, 1 + p-&gt;tm_mon, p-&gt;tm_mday, p-&gt;tm_hour, p-&gt;tm_min, p-&gt;tm_sec);\n\tMessageBox(Time);\n&#125;</code></pre>\n\n<h2 id=\"PE文件结构图\"><a href=\"#PE文件结构图\" class=\"headerlink\" title=\"PE文件结构图\"></a>PE文件结构图</h2><img src=\"https://img1.imgtp.com/2022/12/29/VKHAlkJe.png\" alt=\"25.png\" title=\"25.png\" />\n\n","text":"什么是文件存储数据的实体。 不同的文件是给不同的软件去使用的。不同的文件主要是格式不同。 格式就是数组的排列组织方式 。软件读取文件，按照固定的形式去解析文件的。 什么是PE文件（Portable Executable）可执行 文件的缩写。这种类型的文件，是供windows系统解...","link":"","photos":[],"count_time":{"symbolsCount":"43k","symbolsTime":"39 mins."},"categories":[{"name":"Windows安全","slug":"Windows安全","count":4,"path":"api/categories/Windows安全.json"}],"tags":[{"name":"PE文件结构","slug":"PE文件结构","count":1,"path":"api/tags/PE文件结构.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">什么是文件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AFPE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">什么是PE文件</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#PE%E5%A4%B4%E9%83%A8%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">PE头部信息</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#PE%E5%A4%B4%E9%83%A8%E7%B2%97%E7%95%A5%E5%9B%BE\"><span class=\"toc-text\">PE头部粗略图</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#DOS%E5%A4%B4\"><span class=\"toc-text\">DOS头</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%AE%80%E4%BB%8B\"><span class=\"toc-text\">简介</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%8E%E4%B9%88%E6%89%BE%E5%88%B0DOS%E5%A4%B4\"><span class=\"toc-text\">怎么找到DOS头</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#NT%E5%A4%B4\"><span class=\"toc-text\">NT头</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%85%B3%E4%BA%8E%E9%95%9C%E5%83%8F%EF%BC%8C%E6%98%A0%E5%83%8F%EF%BC%8C%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%EF%BC%8C%E7%9B%B8%E5%AF%B9%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80\"><span class=\"toc-text\">关于镜像，映像，虚拟地址，相对虚拟地址</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E5%A4%B4\"><span class=\"toc-text\">文件头</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%96%87%E4%BB%B6%E5%A4%B4%E7%BB%93%E6%9E%84%E4%BD%93\"><span class=\"toc-text\">文件头结构体</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%8E%E4%B9%88%E6%89%BE%E5%88%B0%E6%96%87%E4%BB%B6%E5%A4%B4\"><span class=\"toc-text\">怎么找到文件头</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%89%A9%E5%B1%95%E5%A4%B4\"><span class=\"toc-text\">扩展头</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%BE%E5%88%B0%E6%89%A9%E5%B1%95%E5%A4%B4\"><span class=\"toc-text\">找到扩展头</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%A9%E5%B1%95%E5%A4%B4%E7%BB%93%E6%9E%84%E4%BD%93\"><span class=\"toc-text\">扩展头结构体</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E7%9B%AE%E5%BD%95%E8%A1%A8\"><span class=\"toc-text\">数据目录表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%BC%E5%87%BA%E8%A1%A8\"><span class=\"toc-text\">导出表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%BC%E5%87%BA\"><span class=\"toc-text\">什么是导出</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%80%8E%E4%B9%88%E5%AF%BC%E5%87%BA\"><span class=\"toc-text\">怎么导出</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%80%8E%E4%B9%88%E6%89%BE%E5%88%B0%E4%B8%80%E4%B8%AAPE%E6%96%87%E4%BB%B6%E7%9A%84%E5%AF%BC%E5%87%BA%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">怎么找到一个PE文件的导出信息</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%89%8B%E5%B7%A5%E5%88%86%E6%9E%90%E8%BF%87%E7%A8%8B%EF%BC%9A\"><span class=\"toc-text\">手工分析过程：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%8E%B7%E5%BE%97%E4%BF%A1%E6%81%AF%EF%BC%9A\"><span class=\"toc-text\">获得信息：</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AF%BC%E5%85%A5%E8%A1%A8\"><span class=\"toc-text\">导入表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AF%BC%E5%85%A5\"><span class=\"toc-text\">什么是导入</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%89%8B%E5%B7%A5%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">手工解析</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81\"><span class=\"toc-text\">测试代码</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E9%87%8D%E5%AE%9A%E4%BD%8D%E8%A1%A8\"><span class=\"toc-text\">重定位表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%80%E4%B9%88%E5%8F%AB%E5%81%9A%E9%87%8D%E5%AE%9A%E4%BD%8D\"><span class=\"toc-text\">什么叫做重定位</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%89%8B%E5%B7%A5%E8%A7%A3%E6%9E%90%E9%87%8D%E5%AE%9A%E4%BD%8D\"><span class=\"toc-text\">手工解析重定位</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81-1\"><span class=\"toc-text\">测试代码</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B5%84%E6%BA%90%E8%A1%A8\"><span class=\"toc-text\">资源表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%90%86%E8%A7%A3%E8%B5%84%E6%BA%90%E8%A1%A8\"><span class=\"toc-text\">理解资源表</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%89%8B%E5%B7%A5%E8%A7%A3%E6%9E%90PE%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">手工解析PE文件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E6%89%BE%E5%88%B0%E8%B5%84%E6%BA%90%E8%A1%A8\"><span class=\"toc-text\">找到资源表</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%9E%90%E7%AC%AC%E4%B8%80%E5%B1%82\"><span class=\"toc-text\">分析第一层</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%BF%99%E4%B8%AA%E5%B0%B1%E6%98%AF%E7%AC%AC%E4%BA%8C%E5%B1%82%E7%9A%84%E4%BD%8D%E7%BD%AE\"><span class=\"toc-text\">这个就是第二层的位置</span></a></li><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#%E8%BF%99%E4%B8%AA%E5%B0%B1%E6%98%AF%E7%AC%AC%E4%B8%89%E5%B1%82%E7%9A%84%E4%BD%8D%E7%BD%AE%E4%BA%86\"><span class=\"toc-text\">这个就是第三层的位置了</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#TLS%E8%A1%A8\"><span class=\"toc-text\">TLS表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E7%AE%80%E4%BB%8B-1\"><span class=\"toc-text\">简介</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81-2\"><span class=\"toc-text\">测试代码</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8C%BA%E6%AE%B5%E8%A1%A8\"><span class=\"toc-text\">区段表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84%E4%BD%93%E6%95%B0%E7%BB%84\"><span class=\"toc-text\">结构体数组</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%8E%E4%B9%88%E6%89%BE%E5%88%B0%E5%8C%BA%E6%AE%B5%E8%A1%A8\"><span class=\"toc-text\">怎么找到区段表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8C%BA%E6%AE%B5%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%8F%8F%E8%BF%B0%E7%9A%84%E5%B0%B1%E6%98%AF%E4%B8%80%E4%B8%AA%E5%8C%BA%E6%AE%B5%E7%9A%84%E4%BF%A1%E6%81%AF\"><span class=\"toc-text\">区段表中的一个元素描述的就是一个区段的信息</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%8C%BA%E6%AE%B5%E8%A1%A8%E4%B8%AD%E7%9A%84%E4%BB%A5%E4%B8%8B%E5%9B%9B%E4%B8%AA%E5%AD%97%E6%AE%B5%E4%BF%9D%E5%AD%98%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F\"><span class=\"toc-text\">区段表中的以下四个字段保存的是什么？</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%B5%8B%E8%AF%95%E4%BB%A3%E7%A0%81-3\"><span class=\"toc-text\">测试代码</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#RVA%E5%92%8CFOA%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2\"><span class=\"toc-text\">RVA和FOA之间的转换</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#RVA%E6%80%8E%E4%B9%88%E8%BD%AC%E6%8D%A2%E6%88%90FOA\"><span class=\"toc-text\">RVA怎么转换成FOA</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E4%B8%8B%EF%BC%8CPE%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%B4%E9%83%A8%E5%9C%A8%E6%96%87%E4%BB%B6%E4%B8%AD%E6%98%AF%E5%A4%9A%E5%A4%A7%EF%BC%9F\"><span class=\"toc-text\">一般情况下，PE文件的头部在文件中是多大？</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#PE%E6%96%87%E4%BB%B6%E7%9A%84%E5%A4%B4%E9%83%A8%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%AD%E6%98%AF%E5%A4%9A%E5%A4%A7\"><span class=\"toc-text\">PE文件的头部在内存中是多大</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E5%8A%9F%E8%83%BD%E7%9A%84%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">小功能的实现</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E4%BD%8D%E7%BD%AE%E8%AE%A1%E7%AE%97\"><span class=\"toc-text\">位置计算</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%93%8D%E5%BA%94%E6%8B%96%E6%8B%BD\"><span class=\"toc-text\">响应拖拽</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%97%B6%E9%97%B4%E6%8D%A2%E7%AE%97\"><span class=\"toc-text\">时间换算</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#PE%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%E5%9B%BE\"><span class=\"toc-text\">PE文件结构图</span></a></li></ol>","author":{"name":"Akpigs","slug":"blog-author","avatar":"https://img1.imgtp.com/2022/12/28/m2fD4XcB.jpg","link":"/","description":"Sharp tools make good work, 玉不琢，不成器；人不学，不知道。","socials":{"github":"https://github.com/akpigs","twitter":"https://twitter.com/EmilyLe443","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://akpigs.blog.csdn.net/","juejin":"","customs":{"discord":{"icon":"/svg/discord.svg","link":"https://discord.gg/vS7yaWgW"},"bilibili":{"icon":"/svg/bilibili.svg","link":"https://www.bilibili.com"},"facebook":{"icon":"/svg/facebook.svg","link":"https://facebook.com"}}}},"mapped":true,"prev_post":{"title":"简易导航","uid":"db8ececde0a48c813879a1c92a0b7bcc","slug":"简易导航","date":"2021-01-23T07:50:23.000Z","updated":"2021-12-23T07:20:52.000Z","comments":true,"path":"api/articles/简易导航.json","keywords":null,"cover":"https://img1.imgtp.com/2022/12/30/2ikMvVHI.jpg","text":" 下述的内容均收集于互联网，旅行者，本破站点旨在原创文章记录学习经历&amp;&amp;收集优秀资源减少学习成本，如果您又更好的想法请联系我。让我们一起传承开源精神🤓…… 值得推荐的网站——信息安全信息安全在线文件检查分析 微步在线云沙箱 病毒总数 腾讯哈勃分析系统 VirSCA...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"导航","slug":"导航","count":2,"path":"api/categories/导航.json"}],"tags":[{"name":"资源","slug":"资源","count":2,"path":"api/tags/资源.json"}],"author":{"name":"Akpigs","slug":"blog-author","avatar":"https://img1.imgtp.com/2022/12/28/m2fD4XcB.jpg","link":"/","description":"Sharp tools make good work, 玉不琢，不成器；人不学，不知道。","socials":{"github":"https://github.com/akpigs","twitter":"https://twitter.com/EmilyLe443","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://akpigs.blog.csdn.net/","juejin":"","customs":{"discord":{"icon":"/svg/discord.svg","link":"https://discord.gg/vS7yaWgW"},"bilibili":{"icon":"/svg/bilibili.svg","link":"https://www.bilibili.com"},"facebook":{"icon":"/svg/facebook.svg","link":"https://facebook.com"}}}}},"next_post":{"title":"python基础","uid":"6b3d24a06c11d699c5c6879ddbf2363d","slug":"python基础","date":"2020-11-24T03:30:44.000Z","updated":"2022-12-30T15:22:56.875Z","comments":true,"path":"api/articles/python基础.json","keywords":null,"cover":"https://img1.imgtp.com/2022/12/30/HxSFqoXO.png","text":" 旅行者,本破站点旨在原创文章记录学习经历&amp;&amp;收集优秀资源减少学习成本，如果您又更好的想法请联系我。让我们一起传承开源精神🤓…… 数值类型 类型 关键字 数据 整型 int 整数，无限 浮点型 float 小数 复数 complex 复数由实数部分和虚数部分构成 ...","link":"","photos":[],"count_time":{"symbolsCount":"33k","symbolsTime":"30 mins."},"categories":[{"name":"Python基础","slug":"Python基础","count":1,"path":"api/categories/Python基础.json"}],"tags":[{"name":"Python基础","slug":"Python基础","count":1,"path":"api/tags/Python基础.json"}],"author":{"name":"Akpigs","slug":"blog-author","avatar":"https://img1.imgtp.com/2022/12/28/m2fD4XcB.jpg","link":"/","description":"Sharp tools make good work, 玉不琢，不成器；人不学，不知道。","socials":{"github":"https://github.com/akpigs","twitter":"https://twitter.com/EmilyLe443","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://akpigs.blog.csdn.net/","juejin":"","customs":{"discord":{"icon":"/svg/discord.svg","link":"https://discord.gg/vS7yaWgW"},"bilibili":{"icon":"/svg/bilibili.svg","link":"https://www.bilibili.com"},"facebook":{"icon":"/svg/facebook.svg","link":"https://facebook.com"}}}}}}