{"title":"内核基础笔记","uid":"78d2bc526af29c27e612023c3b63efda","slug":"内核基础","date":"2019-05-24T08:06:18.000Z","updated":"2023-01-09T07:13:47.550Z","comments":true,"path":"api/articles/内核基础.json","keywords":null,"cover":"https://img1.imgtp.com/2022/12/30/Lg0NMJmk.jpg","content":"<h2 id=\"分段机制\"><a href=\"#分段机制\" class=\"headerlink\" title=\"分段机制\"></a>分段机制</h2><ul>\n<li>在 32 位保护模式下，段寄存器就不会再直接保存段基址了，而是分成了<strong>可见的 16 位段选择子</strong>部分和<strong>不可见的 80 位高速缓冲</strong>部分，对于访问内存需要用到的一些信息，例如段的基址、限长和访问属性等都会被保存在这里的不可见部分。这一部分的内容无法人为的直接读取到，在段寄存器进行切换时会被 CPU 自动加载。首先，会解析 16 位的段选择子部分，从 TI 位获取到要使用的是哪一张表(GDT?LDT?)，由于Windows没有使用LDT，所以目前保存的都是 0，再从 INDEX 获取表内元素的下标，再进行权限检查后，从中加载段的信息到不可见的高速缓存部分。</li>\n<li>在16位上是段基址，在32位上是段选择子</li>\n</ul>\n<h3 id=\"段选择子\"><a href=\"#段选择子\" class=\"headerlink\" title=\"段选择子\"></a>段选择子</h3><ul>\n<li>从下面的结构体定义可以看出，段选择子由 INDEX、TI 以及 RPL 组成，其中 RPL 全称为请求权限级别，表示当前使用什么样的权限发出请求，TI 位指定了当前查找的是 GDT(0) 还是 LDT(1)，INDEX 标识的是索引，需要将 index 配合 ti 位一起使用，找到最终的 <strong>段描述符</strong>。</li>\n<li>段选择子是一个16位的数值，高13位为全局描述表的索引，第三位索引GDT，LDT，低两位为请求特权级</li>\n</ul>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef struct _SELECTOR \n&#123;\n    unsigned short index: 13;\t\t\t\t&#x2F;&#x2F; index 是存在于 GDT 或 LDT 中元素的索引\n\tunsigned short    ti:  1;\t\t\t\t&#x2F;&#x2F; 为 0 表示 GDT 否则是 LDT，windows 始终各为 0\n    unsigned short   rpl:  2;\t\t\t\t&#x2F;&#x2F; 请求权限级别，表示使用什么样的权限访问\n&#125;</code></pre>\n\n<h3 id=\"段描述符\"><a href=\"#段描述符\" class=\"headerlink\" title=\"段描述符\"></a>段描述符</h3><ul>\n<li>GDT 或 LDT 中保存的就是段描述符，每一个段描述符都描述了段的一些信息，32位下，大小为 8 字节(64位)</li>\n<li>在 windbg 中使用 gdtr 寄存器可以获取段描述符的基址，gdtl 获取段描述符的限长。</li>\n<li>通过汇编指令 rgdt 获取 gdt 寄存器，还可以通过 lgdt(特权指令) 设置 gdt 寄存器的内容。</li>\n<li>描述一个段的位置和大小信息以及访问控制的状态信息，存在GDTR寄存器指向的内存中</li>\n</ul>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">typedef struct _DESCRIPTOR\n&#123;\n    unsigned int limit1: 16;\t\t\t\t&#x2F;&#x2F; 段限长 [0~15]\n    unsigned int base1:  16;\t\t\t\t&#x2F;&#x2F; 段基址 [0~15]\n    unsigned int base2:   8;\t\t\t\t&#x2F;&#x2F; 段基址 [16~23]\n    unsigned int type:    4;\t\t\t\t&#x2F;&#x2F; 段的类型\n    unsigned int s:\t\t  1;\t\t\t    &#x2F;&#x2F; 当前是系统段还是用户段\n    unsigned int dpl:     2;                &#x2F;&#x2F; 访问当前段需要用到的权限\n    unsigned int p:       1;                &#x2F;&#x2F; 表示当前的段是否是有效的\n    unsigned int limit2:  4;                &#x2F;&#x2F; 段限长 [16~19]\n    unsigned int avl:     1;                &#x2F;&#x2F; 保留给操作系统的\n    unsigned int L:       1;                &#x2F;&#x2F; 是否是长模式\n    unsigned int db:      1;                &#x2F;&#x2F; 默认使用的单位\n    unsigned int G:       1;                &#x2F;&#x2F; 表示 limit 的单位\n    unsigned int base3:   8;                &#x2F;&#x2F; 段基址 [24~31]\n&#125;</code></pre>\n\n<ul>\n<li><p>*Base: 由 3 个部分组成，分别对应了 32 位基址的 0 ~ 15、16 ~ 23 以及 24 ~ 31 位，表示段基地址</p>\n</li>\n<li><p>P: 是切换寄存器时检查的第一个位，表示当前的段描述符是否是有效的，如果有效为 1，否则为 0</p>\n</li>\n<li><p>AVL：对于 i386 的所有处理器来说，CPU 都不会使用它，会将它留给用户（操作）进行操作</p>\n</li>\n<li><p>L: 如果当前的处理哦其处于 64 位模式，就会提供 L 位进行标识，表示当前使用的是长模式</p>\n</li>\n<li><p>*DPL：目标请求级别，描述的是想要访问当前的段描述符必须拥有的权限，权限通常要小于RPL\\CPL，DPL是目标代码段的访问权限，CPL当前执行权限，RPL代码段权限</p>\n</li>\n<li><p>Limit 和 G 位：Limit 由两个部分组成，共使用了 20 位的数据表示段限长，当 G 位为 0 时，Limit 的单位就是 1Byte，当 G 位为 1 时，Limit 的单位就是 0x1000(4KB)，所以Limit 的值最大可能是下面的情况</p>\n<ul>\n<li>若 G 为 1：假设 Limit 为 0xFFFFF，此时最终限长为 0xFFFFF × 0x1000 + 0xFFF -&gt; 0xFFFFFFFF</li>\n<li>若 G 为 0：假设 Limit 为 0xFFFFF，此时最终限长为 0xFFFFF × 1 -&gt; 0xFFFFF</li>\n</ul>\n</li>\n<li><p>D\\B：用于设置默认操作数的大小和默认地址的大小。对于栈来说，通常将这一位成为 B 位，当 B 位为1时，默认对 ESP 的操作是以 4 字节计算的，例如 push 1 实际执行了 sub esp, 4 的操作。对于其它情况，该位被称作 D 位，表示默认使用的是 4 字节还是 2 字节。通过 OPCODE 指令前缀可以修改操作数和地址大小。</p>\n<p>当前是代码段时 D &#x3D; 1采用32位寻址方式,D &#x3D; 0 采用16位寻址方式</p>\n<p>当前是数据段是 D &#x3D; 1 无论是向上拓展还是向下都是4Gb, D&#x3D;0 它的拓展范围只有64kb</p>\n</li>\n</ul>\n<img src=\"https://img1.imgtp.com/2022/12/29/XXSN3AfL.png\" alt=\"1.png\" title=\"1.png\" />\n\n<p>用户段</p>\n<ul>\n<li>当 S 位为 1 时，表示当前就是用户段，用户段又存在了两种状态，分别是代码段和数据段，</li>\n<li>S位为0时，是系统，TYPE代表这个段的调用门，陷阱门，任务门</li>\n<li><img src=\"https://img1.imgtp.com/2022/12/29/cyKbehwz.png\" alt=\"2.png\" title=\"2.png\" /></li>\n<li>如果 TYPE 位的最高位为 1，就表示当前是代码段，此时看到的 TYPE 整体会大于 7<ul>\n<li>C: 表示当前是否是一致代码段。如果但其概念是一致代码段，就表示我们可以使用低权限访问高权限的内容。如果但其概念是非一致代码段，那么要求访问者个被访问者权限必须一致 。</li>\n<li>R: 当前的段是否是可读的</li>\n<li>A: 表示当前的段是否被访问了，如果被访问了就为 1</li>\n</ul>\n</li>\n<li>如果 TYPE 位的最高位为 0，就表示当前是数据段，此时看到的 TYPE 整体会小于 8</li>\n<li>E: 表示当前是向上扩展(extend-up)段还是向下扩展(extend-down)段</li>\n<li><img src=\"https://img1.imgtp.com/2022/12/29/nqrraoOQ.png\" alt=\"3.png\" title=\"3.png\" /></li>\n<li>W: 表示当前的段是可写的</li>\n<li>A: 表示当前的段是否被访问了，如果被访问了就为 1</li>\n</ul>\n<h3 id=\"手动解析\"><a href=\"#手动解析\" class=\"headerlink\" title=\"手动解析\"></a>手动解析</h3><ul>\n<li>0008 -&gt; 双机调试 CS &#x3D; 1(INDEX) + 0(TI) + 00(RPL)，通过 dq gdtr+(INDEX*8) 找到段描述符<ul>\n<li><strong>00</strong>cf9b<strong>00</strong>&#96;<strong>0000</strong>ffff: base 表示当前的<strong>段基址</strong>为 0</li>\n<li>00<strong>cf</strong>9b00&#96;0000<strong>ffff</strong>：limit 为 0xFFFFF，G位是C的最高位表示1，所以LIMIT 是 0xFFFFFFFF</li>\n<li>00<strong>c</strong>f9b00&#96;0000ffff：除了 G 位，分别为 DB(1)、L(0) 和 AVL(0)，只有 DB 是有意义的</li>\n<li>00cf<strong>9</strong>b00&#96;0000ffff：9对应了 P(1) + DPL(00) + S(1)，说明当前是一个有效的仅R0能访问的用户段</li>\n<li>00cf9<strong>b</strong>00&#96;0000ffff：b大于8，说明是代码段，三个属性分别是 0(非一致) 1(可读) 1(访问过)</li>\n</ul>\n</li>\n<li>001b -&gt; 用户程序CS &#x3D; 11(INDEX) + 0(TI) + 11(RPL)，通过 dq gdtr+(INDEX*8) 找到段描述符<ul>\n<li>00cffb00&#96;0000ffff：base 表示当前的<strong>段基址</strong>为 0</li>\n<li>00cffb00&#96;0000ffff：limit 为 0xFFFFF，G位是C的最高位表示1，所以LIMIT 是 0xFFFFFFFF</li>\n<li>00cffb00&#96;0000ffff：除了 G 位，分别为 DB(1)、L(0) 和 AVL(0)，只有 DB 是有意义的</li>\n<li>00cf<strong>f</strong>b00&#96;0000ffff：F对应了 P(1) + DPL(11) + S(1)，说明当前是一个有效的需要R3能访问的用户段</li>\n<li>00cff<strong>b</strong>00&#96;0000ffff：b大于8，说明是代码段，三个属性分别是 0(非一致) 1(可读) 1(访问过)</li>\n</ul>\n</li>\n<li>随便找的一个数据段，对应 TI 和 INDEX 分别是 0 和 10，DPL是0表示选择子最低两位应该是0<ul>\n<li><strong>00</strong>cf93<strong>00</strong>&#96;<strong>0000</strong>ffff：base 表示当前的<strong>段基址</strong>为 0</li>\n<li>00<strong>cf</strong>9300&#96;0000<strong>ffff</strong>：limit 为 0xFFFFF，G位是C的最高位表示1，所以LIMIT 是 0xFFFFFFFF</li>\n<li>00cf9300&#96;0000ffff：除了 G 位，分别为 DB(1)、L(0) 和 AVL(0)，只有 DB 是有意义的</li>\n<li>00cf<strong>9</strong>300&#96;0000ffff：9对应了 P(1) + DPL(00) + S(1)，说明当前是一个有效的仅R0能访问的用户段</li>\n<li>00cf9<strong>3</strong>00&#96;0000ffff：3小于 7 是数据段，三个属性分别是 E(向上扩展) W(可写) A(访问了)</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"权限检查\"><a href=\"#权限检查\" class=\"headerlink\" title=\"权限检查\"></a>权限检查</h4><ul>\n<li><p>通过 lxs 和 mov xs, ax 可以切换段选择子 加载段选择符进入段寄存器的时候</p>\n<ul>\n<li>CS寄存器只能存放代码段的选择符</li>\n<li>代码段选择符可以被加载到数据段寄存器，但是不可读的代码段选择符不能被加载进入数据段寄存器（因为数据段都是可读的）</li>\n<li>只有可读可写数据段选择符才能加载到SS寄存器（SS寄存器一定是可写的）</li>\n</ul>\n</li>\n<li><p>当前接触到的三种权限：</p>\n<ul>\n<li><p>CPL：特指 CS 段寄存器的最低两位，表示当前所拥有(当前执行代码)的权限</p>\n<ul>\n<li>当前操作系统登录用户的权限</li>\n</ul>\n</li>\n<li><p>RPL：指任何一个段选择子的最低两位，表示使用什么样的权限进行请求</p>\n<ul>\n<li>当前是否使用了管理员方式打开目标程序</li>\n</ul>\n</li>\n<li><p>DPL：想要切换到当前的段描述符需要什么样的权限</p>\n<ul>\n<li>当前的应用程序最少需要使用什么样的权限</li>\n<li><img src=\"https://img1.imgtp.com/2022/12/29/5NxUdGVP.png\" alt=\"4.png\" title=\"4.png\" /></li>\n</ul>\n<h4 id=\"代码间的跳转\"><a href=\"#代码间的跳转\" class=\"headerlink\" title=\"代码间的跳转\"></a>代码间的跳转</h4><p>JMP 0x20:0x004183D7 CPU怎么指向这段代码</p>\n<ol>\n<li><p>段选择子拆分</p>\n<p>0x20对应二进制 0000 0000 0010 0000</p>\n<p>RPL &#x3D; 00</p>\n<p>Ti &#x3D; 0</p>\n<p>Index &#x3D; 4</p>\n</li>\n<li><p>查表得到段描述符</p>\n<p>Ti &#x3D; 0 所以查GDT表</p>\n<p>Index &#x3D; 4 找到对应的段描述符</p>\n<p>四种情况可以跳转: 代码段,调用门,TSS任务段,任务门</p>\n</li>\n<li><p>权限检查</p>\n<p>如果是非一致代码段,要求CPL &#x3D;&#x3D; DPL &amp;&amp; RPL &lt;&#x3D; DPL</p>\n<p>如果是一致代码段,要求CPL &gt;&#x3D; DPL</p>\n</li>\n<li><p>加载段描述符</p>\n<p>通过上面的权限检查后,cpu会将段描述符加载到cs段寄存器中</p>\n</li>\n<li><p>代码执行</p>\n<p>cpu将 cs.base + Offset 的值写入eip然后执行cs:eip处的代码,段间跳转结束</p>\n</li>\n</ol>\n<h3 id=\"调用门\"><a href=\"#调用门\" class=\"headerlink\" title=\"调用门\"></a>调用门</h3></li>\n</ul>\n</li>\n</ul>\n<img src=\"https://img1.imgtp.com/2022/12/29/nGOtftHH.png\" alt=\"5.png\" title=\"5.png\" />\n\n<p>1100</p>\n<p>查看GDT表</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">kd&gt; r gdtr\ngdtr&#x3D;80b95000\nkd&gt; r gdtl\ngdtl&#x3D;000003ff</code></pre>\n\n<h4 id=\"跨段调用\"><a href=\"#跨段调用\" class=\"headerlink\" title=\"跨段调用\"></a>跨段调用</h4><p>调用提权</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/XGKRR3QG.png\" alt=\"6.png\" title=\"6.png\" />\n\n<p>调用不提权</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/JzQINif2.png\" alt=\"7.png\" title=\"7.png\" />\n\n<p>跨段调用时,一旦有权限切换,就会跟着切换栈</p>\n<p>CS的权限一旦改变,SS的权限也要随着改变,CS与SS的等级必须一样</p>\n<p>JMP FAR 只能跳转到同级的一致代码段,但CALL FAR可以通过调用门提权,提升CPL权限</p>\n<p>注: SS与ESP从那里来?参见TSS段</p>\n<h4 id=\"调用门执行流程\"><a href=\"#调用门执行流程\" class=\"headerlink\" title=\"调用门执行流程\"></a>调用门执行流程</h4><p>指令格式 CALL CS:EIP(EIP是废弃的)</p>\n<p>执行步骤:</p>\n<p> 根据CS的值查GDT表,找到对应的段描述符,这个描述符是一个调用门</p>\n<p> 在调用门描述符中存储另一个代码段的段选择子</p>\n<p> 选择子指向的段 段.Base + 偏移地址 就是真正要执行的地址</p>\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\n\n\ntypedef struct _CALLGATE \n&#123;\n\tunsigned int offset1 : 16;\t\t\t\t&#x2F;&#x2F; 提权后执行代码的低地址\n\tunsigned int selector : 16;\t\t\t\t&#x2F;&#x2F; 需要提升的权限对应的选择子\n\tunsigned int paramcount : 5;\t\t\t&#x2F;&#x2F; 提权后执行的代码用到的参数\n\tunsigned int : 3;\t\t\t\t\t\t&#x2F;&#x2F; 保留位\n\tunsigned int type : 4;\t\t\t\t\t&#x2F;&#x2F; 对于调用门始终是 1100 \n\tunsigned int S : 1;\t\t\t\t\t\t&#x2F;&#x2F; 对于调用门始终是 0\n\tunsigned int DPL : 2;\t\t\t\t\t&#x2F;&#x2F; 访问我需要的权限，应该写 3\n\tunsigned int P : 1;\t\t\t\t\t\t&#x2F;&#x2F; 必须是有效的段描述符\n\tunsigned int offset2 : 16;\t\t\t\t&#x2F;&#x2F; 提权后执行代码的高地址\n&#125; CALLGATE, *PCALLGATE;\n\n&#x2F;&#x2F; 在进行权限切换的过程中，栈也会随之改变\nshort r0_ss &#x3D; 0;\nint r0_esp &#x3D; 0;\n\n&#x2F;&#x2F; 裸函数，只生成用户编写的代码，在其中操作高地址空间\n_declspec(naked) void r0_function()\n&#123;\n\t__asm\n\t&#123;\n\t\tint 3\n\t\tmov r0_ss, ss\t\t; 获取 r0 权限的 ss\n\t\tmov r0_esp, esp\t\t; 获取 r0 权限的 esp\n\t\tretf\t\t\t\t; 调用门必须使用 retf 进行返回\n\n\t\t; 实现通过调用门读取到 gdt 中的第 3 项\n\t\t; sgdt 可以获取 gdt 的地址\n\t\t; 对于中断门和陷阱门必须使用 iretd\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\t&#x2F;&#x2F; 1. 根据当前函数的位置，构建一个调用门，用于进行跳转\n\t&#x2F;&#x2F; offset: 0045???? ????6c20\t-&gt; 需要跳转的偏移\n\t&#x2F;&#x2F; selector: ???????? 0008???? (1 0 00) -&gt;  需要切换的权限\n\t&#x2F;&#x2F; DPL: ????E??? ????????\t-&gt; 访问当前调用门的权限\n\t&#x2F;&#x2F; TYPE: ?????C?? ????????\t-&gt; 当前是一个调用门描述符\n\t&#x2F;&#x2F;00456BC0 00456BC0\n\t&#x2F;&#x2F; 0045EC00&#96;00086BC0\n\n\n\n\t&#x2F;&#x2F; 2. 构建一个远跳的地址，在远跳中，偏移是没有意义的，给什么都哦可以\n\t&#x2F;&#x2F;\t后面保存的是段选择子，可以用于找到调用门描述符，要求 RPL &lt;&#x3D; DPL\n\t&#x2F;&#x2F;\t- 0x004B -&gt; 01001(INDEX) 0(TI) 11(RPL)\n\tBYTE dest[] &#x3D; &#123; 0x00, 0x00, 0x00, 0x00, 0x4B, 0x00 &#125;;\n\t&#x2F;&#x2F;char dest[6] &#x3D; &#123;&#125;;\n\t&#x2F;&#x2F;*(DWORD*)&amp;dest[0] &#x3D; 0x12345678;\n\t&#x2F;&#x2F;*(DWORD*)&amp;dest[4] &#x3D; 0x48;\n\n\t&#x2F;&#x2F; 3. 使用 call far 语句，跳转到指定的调用门中，在进行R3到R0 的转化的\n\t&#x2F;&#x2F;\t时候 CPU 会默认的将用户 SS ESP CS IP 保存到栈中\n\t__asm push fs\n\t__asm call fword ptr dest;\n\t__asm pop fs\n\n\t&#x2F;&#x2F; 4. 输出 R0 下的 esp 和 ss，如果R0代码设置断点，那么 fs 会被改变，调\n\t&#x2F;&#x2F;\t用函数会崩溃，需要在进入门之前先进行保存\n\tprintf(&quot;%04X: %08X\\n&quot;, r0_ss, r0_esp);\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;</code></pre>\n\n<p>将构造的门描述符填写到索引处,再将生成好到程序放到虚拟机中执行</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/6qC47ifp.png\" alt=\"8.png\" title=\"8.png\" />\n\n<p>输入指令 g 直接运行</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/6750nzcQ.png\" alt=\"9.png\" title=\"9.png\" />\n\n<p>注意，如果在返回时需要改变特权级，将会检查段寄存器DS、ES、FS、GS的内容，如果在它们之中，某个寄存器的中的选择子所指向的数据段描述符的DPL权限比返回后的CPL(CS.RPL)高,即数值上返回后的CPL&gt;数据断描述符的DPL,处理器将会把数值0填充到相应的段寄存器。</p>\n<h3 id=\"IDT表\"><a href=\"#IDT表\" class=\"headerlink\" title=\"IDT表\"></a>IDT表</h3><h4 id=\"IDT表概述\"><a href=\"#IDT表概述\" class=\"headerlink\" title=\"IDT表概述\"></a>IDT表概述</h4><p>IDT即中断描述符表,同GDT一样,IDT也是由一系列描述符组成,每个描述符占8个字节.但要注意的是,IDT表的第一个元素不是NULL</p>\n<p>在Windbg中查看IDT表的基址和长度</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">kd&gt; r idtr\nidtr&#x3D;80b95400\nkd&gt; r idtl\nidtl&#x3D;000007ff</code></pre>\n\n<h4 id=\"IDT表构成\"><a href=\"#IDT表构成\" class=\"headerlink\" title=\"IDT表构成\"></a>IDT表构成</h4><p>IDT表可以包含三种门描述符:</p>\n<p>iretd 返回</p>\n<h4 id=\"中断门描述符\"><a href=\"#中断门描述符\" class=\"headerlink\" title=\"中断门描述符\"></a>中断门描述符</h4><p>中断门</p>\n<p>1110</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/wE0h5hLO.png\" alt=\"10.png\" title=\"10.png\" />\n\n<pre class=\"line-numbers language-c++\" data-language=\"c++\"><code class=\"language-c++\">#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\n\n\n&#x2F;&#x2F; 在进行权限切换的过程中，栈也会随之改变\nshort r0_ss &#x3D; 0;\nint r0_esp &#x3D; 0;\n\n\n&#x2F;&#x2F; 裸函数，只生成用户编写的代码，在其中操作高地址空间\n_declspec(naked) void r0_function()\n&#123;\n\t__asm\n\t&#123;\n\t\t&#x2F;&#x2F;int 3\n\t\tmov r0_ss, ss; 获取 r0 权限的 ss\n\t\tmov r0_esp, esp; 获取 r0 权限的 esp\n\t\tiretd; \n\t&#125;\n&#125;\n\n\n\nint main()\n&#123;\n\t&#x2F;&#x2F;中断门\n\t&#x2F;&#x2F; 1. 根据当前函数的位置，构建一个中断门，用于进行跳转\n\t&#x2F;&#x2F; offset: 0045???? ????6c20\t-&gt; 需要跳转的偏移\n\t&#x2F;&#x2F; selector: ???????? 0008???? (1 0 00) -&gt;  需要切换的权限\n\t&#x2F;&#x2F; DPL: ????E??? ????????\t-&gt; 访问当前中断门的权限\n\t&#x2F;&#x2F; TYPE: ?????E?? ????????\t-&gt; 当前是一个中断门描述符\n\t&#x2F;&#x2F;制造中断,使其调用中断门描述符\n\t&#x2F;&#x2F;00456BC0\n\n\t&#x2F;&#x2F;0045EE0000086BC0\n\t_asm\n\t&#123;\n\t\tpush fs\n\t\tint 32\n\t\tpop fs\n\t&#125;\n\n\tprintf(&quot;%04X: %08X\\n&quot;, r0_ss, r0_esp);\n\tsystem(&quot;pause&quot;);\n\treturn 0;\n&#125;</code></pre>\n\n<img src=\"https://img1.imgtp.com/2022/12/29/hUYjzKXS.png\" alt=\"11.png\" title=\"11.png\" />\n\n<h4 id=\"陷阱门描述符\"><a href=\"#陷阱门描述符\" class=\"headerlink\" title=\"陷阱门描述符\"></a>陷阱门描述符</h4><p>1111</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/wxoAOyij.png\" alt=\"12.png\" title=\"12.png\" />\n\n<p>陷阱门与中断门的区别</p>\n<p>中断门执行时,将IF位清零,陷阱门</p>\n<h4 id=\"任务门描述符\"><a href=\"#任务门描述符\" class=\"headerlink\" title=\"任务门描述符\"></a>任务门描述符</h4><p>在调用门,中断门与陷阱门中一旦出现权限切换,那么就会有堆栈切换.而且,由于CS的CPL发送改变,也导致了SS也必须切换,切换时,会有ESP和SS(CS是由中断门或者调用门指定)这2个值从TSS(Task-state segment),任务状态段</p>\n<h5 id=\"TSS\"><a href=\"#TSS\" class=\"headerlink\" title=\"TSS\"></a>TSS</h5><p>TSS是一块内存,大小104字节</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/XWmiDGKr.png\" alt=\"13.png\" title=\"13.png\" />\n\n<p>不要把TSS与任务切换联系到一起,TSS的意义就在于可以同时换掉一堆寄存器</p>\n<p>CPU怎么找到TSS,</p>\n<p>TR段寄存器</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/yzyiPLJk.png\" alt=\"14.png\" title=\"14.png\" />\n\n<p>TSS段描述符</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/csKosx1X.png\" alt=\"15.png\" title=\"15.png\" />\n\n<p>构造TSS段描述符:xx00e9xx&#96;xxxx0068</p>\n<p>TR寄存器读写</p>\n<p>1,将TSS段描述符加载到TR寄存器</p>\n<p>指令:LTR</p>\n<p>说明:用LTR指令去装载 仅仅是改变TR寄存器的值96位,并没有真正改变TSS,LTR指令只能在系统层使用,加载后TSS段描述符状态为会发生改变</p>\n<p>2,读TR寄存器</p>\n<p>指令:STR</p>\n<p>说明:如果用STR去读的花,只读了TR的16位,也就是选择子</p>\n<h2 id=\"分页机制\"><a href=\"#分页机制\" class=\"headerlink\" title=\"分页机制\"></a>分页机制</h2><h3 id=\"PDE与PTE\"><a href=\"#PDE与PTE\" class=\"headerlink\" title=\"PDE与PTE\"></a>PDE与PTE</h3><p>80x86映射表分两级</p>\n<p>第一级:页目录表(PDT)</p>\n<p>第二级:页表(PTT)</p>\n<img src=\"https://img1.imgtp.com/2022/12/29/JWKSVlTn.png\" alt=\"16.png\" title=\"16.png\" />\n\n<h3 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h3><img src=\"https://img1.imgtp.com/2022/12/29/VwGYz0Cr.png\" alt=\"17.png\" title=\"17.png\" />\n\n<p><strong>P位：</strong></p>\n<p> 存在</p>\n<p><strong>R&#x2F;W位：</strong></p>\n<p> R&#x2F;W &#x3D; 0 只读</p>\n<p> R&#x2F;W &#x3D; 1 可读可写</p>\n<p><strong>U&#x2F;S 位：</strong></p>\n<p> U&#x2F;S &#x3D; 0 特权用户才能访问</p>\n<p> U&#x2F;S &#x3D; 1 普通用户特权用户都能访问</p>\n<p><strong>P&#x2F;S 位：只对PDE有意义</strong></p>\n<p> 当ps&#x3D;1时PDE直接指向物理页无PTE，低22位是页内偏移，页大小位4M</p>\n<p> 当ps&#x3D;0时，指向下一级页表</p>\n<p><strong>D位：</strong></p>\n<p> 是否被写过，写过就置为1</p>\n<p>Windows是通过页目录</p>\n<ol>\n<li><p>在 8086 CPU 下，我们是如何进行寻址的？</p>\n<p>我们使用 <strong>段寄存器:段内偏移</strong> 的形式访问一个物理地址，实际访问到的地址是：段寄存器*0x10+段内偏移，CPU所处的模式是实模式。</p>\n</li>\n<li><p>在 80386 系列的 CPU 下，拥有几种 CPU 模式？</p>\n<p>三种。分别是<strong>实模式</strong>、<strong>保护模式</strong>以及<strong>虚拟8086模式</strong>。当计算机通电的时候，CPU肯定处于实模式，在进行一些初始化后，会切换到保护模式中。</p>\n</li>\n<li><p>在保护模式下，我们是如何进行寻址的？<br>我们使用 <strong>段寄存器:段内偏移</strong> 的形式访问一个虚拟地址，此时段寄存器保存的并不是段基址，而是段选择子，通过段选择子可以找到段描述符，在进行段选择子切换的时候，CPU会将段描述符中的部分内容加载到不可见的高速缓存部分，在实际寻址时，会使用这一部分的信息。</p>\n</li>\n<li><p>当切换段选择子的时候，CPU会进行什么样的基本权限检查？<br><strong>CPL</strong>特指CS段的低两位，表示当前所拥有的权限、<strong>RPL</strong>指段选择子的低两位，表示当前使用的是什么权限、<strong>DPL</strong>表示想要访问指定段描述符所需要的权限，实际的权限检查公式为：MAX(CPL, RPL) &lt;&#x3D; DPL</p>\n</li>\n<li><p>中断门或陷阱门保存在哪里，如何触发？<br>中断门和陷阱门都应该由 IDT 进行处理，构建完成后，使用 int n 触发它，在进入中断门\\陷阱门后，使用 iretd 跳出到用户层。</p>\n</li>\n</ol>\n<p>地址的种类</p>\n<ul>\n<li>逻辑地址：指 <strong>段寄存器+段内偏移</strong> 表示的一个地址。</li>\n<li>线性地址：指 <strong>进程独有虚拟内存空间中</strong> 的地址。 <strong>分段机制将逻辑地址转换为线性地址。</strong></li>\n<li>物理地址：指 <strong>实际访问到的内存条</strong> 的地址。<strong>分页机制将线性地址转换为物理地址。</strong></li>\n</ul>\n<h3 id=\"WinDbg-相关指令\"><a href=\"#WinDbg-相关指令\" class=\"headerlink\" title=\"WinDbg 相关指令\"></a>WinDbg 相关指令</h3><ul>\n<li>!process 0 0: 列出当前系统中的所有进程的信息</li>\n<li>!process 0 0 notepad.exe： 列出指定进程的信息</li>\n<li>.process 进程的 EPROCESS: 切换到目标进程中，使用它的 CR3</li>\n<li>s -u 0x00000000 L0x1000000 “mmmmmwwwww”: 从指定位置开始搜索指定的字符串</li>\n</ul>\n<h3 id=\"虚拟地址转换（无PAE）\"><a href=\"#虚拟地址转换（无PAE）\" class=\"headerlink\" title=\"虚拟地址转换（无PAE）\"></a>虚拟地址转换（无PAE）</h3><ul>\n<li><p>x86环境下，每一个进程都会拥有自己的 4GB 虚拟地址空间，主要由 CR3 进行区分</p>\n<ul>\n<li>CR3寄存器保存了每一个进程独有的页目录表(PDT)，页目录表是一个元素个数为 1024 的表，其中的每一项占有 4 个字节，叫做 页目录项（PDTE），页目录表项配合虚拟地址的高 10 位组成的索引可以寻址。</li>\n<li>寻址到的页目录表项，它的低12位保存的是属性位，除开属性位就是页表(PT)，页表是一个元素个数为1024 的表，其中的每一项占 4 字节，描述了一个页的信息</li>\n</ul>\n</li>\n<li><p>找到了页表后，配合中间的10位，寻址到最终的页(PAGE)</p>\n</li>\n<li><p>寻址过程</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">0042d f48: 001 + 02d + f48\n\nkd&gt; !dd 5bdf1000  \t\t\t\t\t页目录表\n#5bdf1000 45031867 02b3e867 00000000 00000000\n#5bdf1010 03393867 3929e867 02ad9867 36deb867\n#5bdf1020 023ec867 09401867 32d03867 38a74867\n\nkd&gt; !dd 5bdf1000+(1*4)              页目录表项 -&gt; 页表\n#5bdf1004 02b3e867 00000000 00000000 03393867\n#5bdf1014 3929e867 02ad9867 36deb867 023ec867\n\nkd&gt; !dd 02b3e000+(4*2d)             页表 -&gt; 页\n# 2b3e0b4 019ac867 01406867 44608867 01209867\n# 2b3e0c4 0210a867 0251e867 02825867 00924867\n# 2b3e0d4 36e29867 37d28867 36d2f867 38930867\n\nkd&gt; !du 019ac000+f48                页 -&gt; 物理地址\n# 19acf48 &quot;1233211234567..F&quot;\n\n\n00130bd4： 000(页目录表索引) + 130(页表索引) + bd4(页内偏移)\n\nkd&gt; !dd 5bdf1000  \t\t\t\t\t页目录表\n#5bdf1000 45031867 02b3e867 00000000 00000000\n#5bdf1010 03393867 3929e867 02ad9867 36deb867\n#5bdf1020 023ec867 09401867 32d03867 38a74867\n\nkd&gt; !dd 5bdf1000+(0*4)\n#5bdf1000 45031867 02b3e867 00000000 00000000\n#5bdf1010 03393867 3929e867 02ad9867 36deb867\n#5bdf1020 023ec867 09401867 32d03867 38a74867\n\nkd&gt; !dd 45031000 + (4*130)\n#450314c0 376c5867 00000080 00000080 00000080\n#450314d0 028c7867 372c6867 00000080 00000080\n#450314e0 029c9867 01acd867 445c8867 028ce867\n\nkd&gt; !du 376c5000 + bd4\n#376c5bd4 &quot;1233211234567&quot;</code></pre>\n\n<h3 id=\"开启PAE的情况\"><a href=\"#开启PAE的情况\" class=\"headerlink\" title=\"开启PAE的情况\"></a>开启PAE的情况</h3><ul>\n<li>2：页目录表指针表(4) + 9:页目录表(512) + 9: 页表(512) + 12:偏移(0x1000)</li>\n<li>不管有没有开启 PAE，能够描述的页都是一样多的，但是和没有PAE的情况相比，开了的每一个项占了8字节空间，所以可以充分利用大于 4 GB的物理内存。</li>\n</ul>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">kd&gt; !process 0 0 notepad.exe\nPROCESS 87bfbc00  SessionId: 1  Cid: 029c    Peb: 7ffd3000  ParentCid: 05ac\n    DirBase: 7f5fe560  ObjectTable: 90a553c8  HandleCount:  61.\n    Image: notepad.exe\n\n\n\nkd&gt; .process 87bfbc00\nImplicit process is now 87bfbc00\nWARNING: .cache forcedecodeuser is not enabled\n\n\n\nkd&gt; s -u 0x00000000 L0x01000000 &quot;1234567654321&quot;\n\n0040e100  0031 0032 0033 0034 0035 0036 0037 0036  1.2.3.4.5.6.7.6.\n01890bd4  0031 0032 0033 0034 0035 0036 0037 0036  1.2.3.4.5.6.7.6.\n\n\n0040e100 转换为二进制 \t\t00 000000010      000001110 \t\t  000100000000\n\t\t\t\t\t\t\t0\t\t  2\t\t\t\t e\t\t\t  100\nkd&gt; du 0040e100\n0040e100  &quot;1234567654321321&quot;\n\n\nkd&gt; !dq 7f5fe560\n#7f5fe560 00000000&#96;57f0c801 00000000&#96;5828d801\n#7f5fe570 00000000&#96;5838e801 00000000&#96;5860f801\n#7f5fe580 00000000&#96;78201801 00000000&#96;79182801\n#7f5fe590 00000000&#96;79103801 00000000&#96;79504801\n#7f5fe5a0 00000000&#96;7815c801 00000000&#96;77f5d801\n\n\n\nkd&gt; !dq 57f0c000+(2*8)\n#57f0c010 00000000&#96;58707867 00000000&#96;5825f867\n#57f0c020 00000000&#96;00000000 00000000&#96;00000000\n#57f0c030 00000000&#96;00000000 00000000&#96;00000000\n#57f0c040 00000000&#96;00000000 00000000&#96;582af867\n#57f0c050 00000000&#96;572ed867 00000000&#96;566bb867\n#57f0c060 00000000&#96;57851867 00000000&#96;00000000\n\n\n\n\nkd&gt; !dq 58707000 +(e*8)\n#58707070 80000000&#96;5762b867 80000000&#96;58069867\n#58707080 80000000&#96;56aea867 80000000&#96;570eb867\n#58707090 80000000&#96;57d6c867 80000000&#96;5796e867\n#587070a0 80000000&#96;5686f867 80000000&#96;57771867\n#587070b0 80000000&#96;56cf0867 80000000&#96;57b73867\n#587070c0 80000000&#96;571f2867 80000000&#96;57874867\n\n\n\nkd&gt; !du 5762b100\n#5762b100 &quot;1234567654321321&quot;\n\n&#x2F;&#x2F;第二个地址\n01890bd4  00 000001100 010010000 101111010100\n\t\t  0\t\t\tc    0x90\t\t\tbd4\n\nkd&gt; du 01890bd4\n01890bd4  &quot;1234567654321&quot;\n\n\n\nkd&gt; !dq 7f5fe560\n#7f5fe560 00000000&#96;57f0c801 00000000&#96;5828d801\n#7f5fe570 00000000&#96;5838e801 00000000&#96;5860f801\n#7f5fe580 00000000&#96;78201801 00000000&#96;79182801\n#7f5fe590 00000000&#96;79103801 00000000&#96;79504801\n#7f5fe5a0 00000000&#96;7815c801 00000000&#96;77f5d801\n\n\nkd&gt; !dq 57f0c000 + (0xc * 8)\n#57f0c060 00000000&#96;57851867 00000000&#96;00000000\n#57f0c070 00000000&#96;5810d867 00000000&#96;5848f867\n#57f0c080 00000000&#96;5860e867 00000000&#96;00000000\n#57f0c090 00000000&#96;580a6867 00000000&#96;57628867\n#57f0c0a0 00000000&#96;58329867 00000000&#96;00000000\n\n\nkd&gt; !dq 57851000 + (0x90 * 8)\n#57851480 80000000&#96;587e6867 00000000&#96;00000080\n#57851490 00000000&#96;00000080 00000000&#96;00000080\n#578514a0 80000000&#96;584e8867 80000000&#96;57ae7867\n#578514b0 00000000&#96;00000080 00000000&#96;00000080\n\n\nkd&gt; !du 587e6000 + 0xbd4\n#587e6bd4 &quot;1234567654321&quot;</code></pre>\n\n<h2 id=\"补充内容\"><a href=\"#补充内容\" class=\"headerlink\" title=\"补充内容\"></a>补充内容</h2><h3 id=\"控制寄存器\"><a href=\"#控制寄存器\" class=\"headerlink\" title=\"控制寄存器\"></a>控制寄存器</h3><p>CPU中有一系列控制寄存器用于控制和确定CPU的保护模式，CR0-CR4</p>\n<p>CR1 保留</p>\n<p>CR3页目录基址</p>\n<h4 id=\"CR0寄存器\"><a href=\"#CR0寄存器\" class=\"headerlink\" title=\"CR0寄存器\"></a>CR0寄存器</h4><table>\n<thead>\n<tr>\n<th>31</th>\n<th>30</th>\n<th>29</th>\n<th>28-19</th>\n<th>18</th>\n<th>17</th>\n<th>16</th>\n<th>15-6</th>\n<th>5</th>\n<th>4</th>\n<th>3</th>\n<th>2</th>\n<th>1</th>\n<th>0</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>PG</td>\n<td>CD</td>\n<td>NW</td>\n<td></td>\n<td>AM</td>\n<td></td>\n<td>WP</td>\n<td></td>\n<td>NE</td>\n<td>ET</td>\n<td>TS</td>\n<td>EM</td>\n<td>MP</td>\n<td>PE</td>\n</tr>\n</tbody></table>\n<p>PE：CR0的0位是启用保护（Protection Enable）标志</p>\n<p> PE &#x3D; 1保护模式 PE &#x3D; 0 实地址模式这个标志仅开启段级保护，而并没有启用分页机制。若要启用分页机制，那么PE和PG都要置位</p>\n<p>PG：当设置该位时即开启了分页机制。在开启这个标志之前必须已经或同时开启了PE标志</p>\n<p> PG &#x3D; 0 且PE &#x3D; 0 处理器工作在实地址模式下</p>\n<p> PG &#x3D; 0 且PE &#x3D; 1处理器工作在没有开启分页机制的保护模式下（没有这种操作系统）</p>\n<p> PG &#x3D; 1 且PE &#x3D; 0在PE没有开启的情况下，无法开启PG</p>\n<p> PG &#x3D; 1 且PE &#x3D; 1处理器工作在开启了分页机制的保护模式下（也就是我们的操作系统）</p>\n<h4 id=\"CR2寄存器\"><a href=\"#CR2寄存器\" class=\"headerlink\" title=\"CR2寄存器\"></a>CR2寄存器</h4><p>当CPU访问莫格无效页面时，会产生缺页现象，此时，CPU会将引起异常的线性地址存放在CR2中</p>\n<h4 id=\"CR4寄存器\"><a href=\"#CR4寄存器\" class=\"headerlink\" title=\"CR4寄存器\"></a>CR4寄存器</h4><table>\n<thead>\n<tr>\n<th>31-11</th>\n<th>10</th>\n<th>9</th>\n<th>8</th>\n<th>7</th>\n<th>6</th>\n<th>5</th>\n<th>4</th>\n<th>3</th>\n<th>2</th>\n<th>1</th>\n<th>0</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>保留位（置0）</td>\n<td></td>\n<td></td>\n<td>PCE</td>\n<td>PGE</td>\n<td>MCE</td>\n<td>PAE</td>\n<td>PSE</td>\n<td>DE</td>\n<td>TSD</td>\n<td>PVI</td>\n<td>VME</td>\n</tr>\n</tbody></table>\n<p>PAE&#x2F;PSE:</p>\n<p>PAE &#x3D; 1 是PAE分页 PAE &#x3D; 0 是普通分页</p>\n<h3 id=\"MSR寄存器\"><a href=\"#MSR寄存器\" class=\"headerlink\" title=\"MSR寄存器\"></a>MSR寄存器</h3><p>CPU中有一组寄存器，称之为特殊模块寄存器，这类寄存器数量庞大，功能各异：</p>\n<p> 性能监视计数</p>\n<p> 调试扩展支持</p>\n<p> 机器检查</p>\n<p> 功耗与温控管理</p>\n<p> 特殊指令的支持</p>\n<p> 处理器特性和处理器莫斯支持</p>\n<p>每一个MSR寄存器都有它的编号可以使用下面的指令分别对其读写，一下指令只能在0环特权级才能执行</p>\n<p> rdmsr： ecx 存放序号，执行完后数据存放在eax中</p>\n<p> wrmsr： eax 存放数据，ecx存放序号，执行后将eax写入到相应的寄存器</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>发明保护模式是为了进行多任务设计，避免任务之间相互干扰，保护模式实现的是通过分段和分页机制来进行的。通过设置CR0的PE标志位可以让处理器工作在保护模式下，PG位可以开启分页保护机制。</p>\n<p>通过分段保护机制，处理器使用段寄存器中选择符（RPL和CPL）和段描述符各个字段来执行保护验证。</p>\n<p>对于分页机制，主要用页目录和页表项中的R&#x2F;W和U&#x2F;S标志来实现保护操作，VirtualProtect函数就是通过修改R&#x2F;W来修改分页的读写属性</p>\n","text":"分段机制 在 32 位保护模式下，段寄存器就不会再直接保存段基址了，而是分成了可见的 16 位段选择子部分和不可见的 80 位高速缓冲部分，对于访问内存需要用到的一些信息，例如段的基址、限长和访问属性等都会被保存在这里的不可见部分。这一部分的内容无法人为的直接读取到，在段寄存器进...","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[{"name":"内核","slug":"内核","count":1,"path":"api/categories/内核.json"}],"tags":[{"name":"内核基础","slug":"内核基础","count":1,"path":"api/tags/内核基础.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">分段机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AE%B5%E9%80%89%E6%8B%A9%E5%AD%90\"><span class=\"toc-text\">段选择子</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6\"><span class=\"toc-text\">段描述符</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%89%8B%E5%8A%A8%E8%A7%A3%E6%9E%90\"><span class=\"toc-text\">手动解析</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E6%9D%83%E9%99%90%E6%A3%80%E6%9F%A5\"><span class=\"toc-text\">权限检查</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%A3%E7%A0%81%E9%97%B4%E7%9A%84%E8%B7%B3%E8%BD%AC\"><span class=\"toc-text\">代码间的跳转</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%B0%83%E7%94%A8%E9%97%A8\"><span class=\"toc-text\">调用门</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B7%A8%E6%AE%B5%E8%B0%83%E7%94%A8\"><span class=\"toc-text\">跨段调用</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E8%B0%83%E7%94%A8%E9%97%A8%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">调用门执行流程</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#IDT%E8%A1%A8\"><span class=\"toc-text\">IDT表</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#IDT%E8%A1%A8%E6%A6%82%E8%BF%B0\"><span class=\"toc-text\">IDT表概述</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#IDT%E8%A1%A8%E6%9E%84%E6%88%90\"><span class=\"toc-text\">IDT表构成</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%B8%AD%E6%96%AD%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6\"><span class=\"toc-text\">中断门描述符</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E9%99%B7%E9%98%B1%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6\"><span class=\"toc-text\">陷阱门描述符</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E4%BB%BB%E5%8A%A1%E9%97%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6\"><span class=\"toc-text\">任务门描述符</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-5\"><a class=\"toc-link\" href=\"#TSS\"><span class=\"toc-text\">TSS</span></a></li></ol></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">分页机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#PDE%E4%B8%8EPTE\"><span class=\"toc-text\">PDE与PTE</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%B1%9E%E6%80%A7\"><span class=\"toc-text\">属性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#WinDbg-%E7%9B%B8%E5%85%B3%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">WinDbg 相关指令</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%EF%BC%88%E6%97%A0PAE%EF%BC%89\"><span class=\"toc-text\">虚拟地址转换（无PAE）</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%BC%80%E5%90%AFPAE%E7%9A%84%E6%83%85%E5%86%B5\"><span class=\"toc-text\">开启PAE的情况</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E8%A1%A5%E5%85%85%E5%86%85%E5%AE%B9\"><span class=\"toc-text\">补充内容</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%8E%A7%E5%88%B6%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">控制寄存器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#CR0%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">CR0寄存器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#CR2%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">CR2寄存器</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#CR4%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">CR4寄存器</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#MSR%E5%AF%84%E5%AD%98%E5%99%A8\"><span class=\"toc-text\">MSR寄存器</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%80%BB%E7%BB%93\"><span class=\"toc-text\">总结</span></a></li></ol>","author":{"name":"Akpigs","slug":"blog-author","avatar":"https://img1.imgtp.com/2022/12/28/m2fD4XcB.jpg","link":"/","description":"Sharp tools make good work, 2023新年快乐！","socials":{"github":"https://github.com/akpigs","twitter":"https://twitter.com/EmilyLe443","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://akpigs.blog.csdn.net/","juejin":"","customs":{"discord":{"icon":"/svg/discord.svg","link":"https://discord.gg/vS7yaWgW"},"bilibili":{"icon":"/svg/bilibili.svg","link":"https://www.bilibili.com"},"facebook":{"icon":"/svg/facebook.svg","link":"https://facebook.com"}}}},"mapped":true,"prev_post":{"title":"代码注入与拦截笔记","uid":"a3bf57902eea4812078182b128b2a45c","slug":"代码注入与拦截","date":"2020-06-21T07:47:31.000Z","updated":"2020-08-09T04:20:21.000Z","comments":true,"path":"api/articles/代码注入与拦截.json","keywords":null,"cover":"https://img1.imgtp.com/2022/12/30/dLfWgNue.jpg","text":"权限权限管理 UAC机制管理方式在管理员账户下，运行一个程序，也是低权限，只有选择管理员方式运行，才会分配高权限。 调整UAC方法1：gpedit 方法2 ：设置 使用案例BOOL CMy01UACDlg::OnInitDialog() &#123; CDialogEx::OnI...","link":"","photos":[],"count_time":{"symbolsCount":"38k","symbolsTime":"34 mins."},"categories":[{"name":"Windows安全","slug":"Windows安全","count":4,"path":"api/categories/Windows安全.json"}],"tags":[{"name":"Windows注入","slug":"Windows注入","count":1,"path":"api/tags/Windows注入.json"}],"author":{"name":"Akpigs","slug":"blog-author","avatar":"https://img1.imgtp.com/2022/12/28/m2fD4XcB.jpg","link":"/","description":"Sharp tools make good work, 2023新年快乐！","socials":{"github":"https://github.com/akpigs","twitter":"https://twitter.com/EmilyLe443","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"https://akpigs.blog.csdn.net/","juejin":"","customs":{"discord":{"icon":"/svg/discord.svg","link":"https://discord.gg/vS7yaWgW"},"bilibili":{"icon":"/svg/bilibili.svg","link":"https://www.bilibili.com"},"facebook":{"icon":"/svg/facebook.svg","link":"https://facebook.com"}}}}},"next_post":{}}